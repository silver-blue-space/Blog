<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[westwood]]></title><description><![CDATA[westwood's personal website]]></description><link>https://lizhi1026.cc</link><generator>GatsbyJS</generator><lastBuildDate>Sun, 19 Jan 2020 06:51:31 GMT</lastBuildDate><item><title><![CDATA[如何系统地提高自己的智慧]]></title><description><![CDATA[…]]></description><link>https://lizhi1026.cc/2020/01-19/wisdom-update-ics</link><guid isPermaLink="false">https://lizhi1026.cc/2020/01-19/wisdom-update-ics</guid><pubDate>Sun, 19 Jan 2020 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;人一切的迷茫都来自：信息不足×思考不足。无论是寻找真爱之人，还是寻找毕生事业。信息量不足就没有选择的依据，思考不足就没有选择的原则，最后只能无从选择。&lt;/p&gt;
&lt;p&gt;千万不要以为当下的困境是最重要的，更重要的是目前的困境揭示了什么，其实是在提醒你：知道的太少、思考的太少、不知道自己到底要什么。&lt;/p&gt;
&lt;p&gt;即便你磕磕绊绊度过这次困境，核心问题不解决，下次纠结的困境自然会找上你。90％的人都在蹉跎中过一生，迷茫、纠结、无知、无助、哀怨伴随一生，都因为不正视问题的根源&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在的你，比三年前更有智慧吗？&lt;/p&gt;
&lt;p&gt;我问过很多朋友这个问题，得到最多的答案是没有。有些朋友甚至感叹一句：现在还不如读大学的时候呢，那时候比现在聪明。我相信相当一部分朋友是谦虚。毕竟随着工作时间越来越长，经验越来越多。年龄越来越大，阅历也随之增加。除非你在做机械的工作，或过着机械的生活，人的智慧怎么能不提高呢？&lt;/p&gt;
&lt;p&gt;但有趣的是，大部分人智慧的提高也仅限于此。如下图中的曲线A，这种提高受限于时间，以年为单位，缓慢而被动。此外，很明显这种提高是边际递减的，很多人在中年时，智慧慢慢达到一种较为稳定的状态。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 600px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 56.166666666666664%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB35QB/8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQABBQJf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAFxAAAwEAAAAAAAAAAAAAAAAAABEgcf/aAAgBAQABPyExz//aAAwDAQACAAMAAAAQQ8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAEAAQQDAAAAAAAAAAAAAAABABARITFxgZH/2gAIAQEAAT8Q2IsCzh2WiZlufYan/9k=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;11&quot;
        title=&quot;11&quot;
        src=&quot;/static/31b17c22753603f44451217020e85c9f/82472/11.jpg&quot;
        srcset=&quot;/static/31b17c22753603f44451217020e85c9f/afcd2/11.jpg 300w,
/static/31b17c22753603f44451217020e85c9f/82472/11.jpg 600w&quot;
        sizes=&quot;(max-width: 600px) 100vw, 600px&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我认为这是造成很多人职业天花板的一个主要原因之一。从某种意义上来说，这有点像是耗尽了自己的潜力和积累。&lt;/p&gt;
&lt;p&gt;那我们有没有可能摆脱这种曲线呢？&lt;/p&gt;
&lt;p&gt;如果我们可以找到一种方法，主动的系统性提高自己的智慧，那么曲线A就会转变成曲线E。主动系统的智慧提高可能开始时不起眼，但却是在积累势能，从本质上它是指数式的，随着长期的坚持，我们的智慧也越来越远离普通人的平均水平。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;这种主动系统性地智慧提升，很多时候并不来源于平时的工作&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大概有几个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;除去少数经历特别或运气好的人，一般在开始工作的数年里，我们都是很难决定自己做什么事、以及去什么岗位的。这就使得学习东西的范围相对狭窄&lt;/li&gt;
&lt;li&gt;有很多职位有一半以上的工作是重复性的，这就限制了学习东西的速度。&lt;/li&gt;
&lt;li&gt;有很多职位只需要高中毕业的教育水平，就可以无障碍的完成工作。这会让人无法体会到提升智慧的必要性，享受智慧提升带来的快感&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，不排除有人的工作每天都充满挑战，或如大学教授一样，需要不断提高自己的智慧。但对一般人来说，我认为是否能在平时工作之外，找到一种方法，主动的系统性提高自己的智慧，部分决定了他/她可以走多远。&lt;/p&gt;
&lt;p&gt;那么如何系统的提高自己的智慧呢？&lt;/p&gt;
&lt;p&gt;读一本书，和一个更有智慧的朋友交谈，都是对智慧的一种提高。但这里的关键词是系统地。有时候会有些惊讶，很多人对于生活工作中的小事精明谨慎，对于像提高自己智慧这种问题却出人意科的忽视和盲目。&lt;/p&gt;
&lt;p&gt;所以才会有“读了很多书，但是都忘掉了，读书的意义在哪里？”这种问题，才会有罗辑思维下面这种类型的产品出现。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 600px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 56.166666666666664%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIEBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHcRp4rFD//xAAaEAACAgMAAAAAAAAAAAAAAAABAhFCAxIx/9oACAEBAAEFArPtI5bM5VkMr//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABURAQEAAAAAAAAAAAAAAAAAAAAB/9oACAECAQE/AUf/xAAYEAEBAQEBAAAAAAAAAAAAAAABABECEP/aAAgBAQAGPwKMT3nGL//EABgQAAMBAQAAAAAAAAAAAAAAAAABETEh/9oACAEBAAE/Ie0JQop2lzdHoVck9HNPT//aAAwDAQACAAMAAAAQTD//xAAXEQEBAQEAAAAAAAAAAAAAAAABEQAh/9oACAEDAQE/EDrMkZv/xAAXEQEBAQEAAAAAAAAAAAAAAAABEQAh/9oACAECAQE/EHhcqXf/xAAbEAEBAQEAAwEAAAAAAAAAAAABEQAhMUGBYf/aAAgBAQABPxBrqyHMkmkALX5iKR9k8bn9poZCxBvTI3Udfu//2Q==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;22&quot;
        title=&quot;22&quot;
        src=&quot;/static/b4ea265276e64197ea2b64dcc11cd50d/82472/22.jpg&quot;
        srcset=&quot;/static/b4ea265276e64197ea2b64dcc11cd50d/afcd2/22.jpg 300w,
/static/b4ea265276e64197ea2b64dcc11cd50d/82472/22.jpg 600w&quot;
        sizes=&quot;(max-width: 600px) 100vw, 600px&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果像做其他事一样，对智慧提升过程有更深入的思考，和系统的方法，会大大加快我们成长的速度和收获，最终迎来指数曲线的拐点。&lt;/p&gt;
&lt;p&gt;在这方面，我们是幸运的。有很多非常有智慧的人分享了他们的经验和心得，比如巴菲特和他的合伙人芒格，诺贝尔物理学奖得主，著名的理论物理学家理查德·费曼，图灵奖和诺贝尔经济学奖得主赫伯特·西蒙等……&lt;/p&gt;
&lt;p&gt;这是我想通过接下来的一些文章，和分享大家的内容。我没有聪明到把这一切自己弄清楚，但幸运的是我们可以站在巨人的肩膀上。&lt;/p&gt;
&lt;p&gt;2013年的一次访谈中，主持人问巴菲特和芒格，为什么他们可以远超同龄人和竞争对手。芒格说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为对于那些本来比我们聪明的人，我们学到了变得比他们更聪明的方法&lt;/p&gt;
&lt;p&gt;智慧是一种运用知识、经验、理解、常识和洞见进行思考和行动的能力&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我过去的公司里，我们常说一句话：“做任何事的时候，一定要记得从消费者的角度思考问题。”但如果我们仔细思考这句话，就会发现这是不可能的。如果我是一个洗发水品牌的管理者，全国13亿人，几乎可以假定所有人都是我们的消费者，我们如何从13亿人的角度思考问题？即便这个品牌是一个面向18-25岁男性的洗发水品牌，这个群体，也有超过6000万人口。&lt;/p&gt;
&lt;p&gt;所以，另一句话我们也常用：当你做一个品牌的时候，你要闭上眼想一想，你周围的人里谁是这个品牌最准确的目标消费者？他/她有什么样的消费习惯和偏好？当我们说“考虑消费者”的时候，有两种可能，一种是我们考虑很多关于消费者的概念，类似“他是一个对生活品质有要求的年轻男性”，“他喜欢挑战”等。还有一种是我们去想某一个特定的符合标准的人。&lt;/p&gt;
&lt;p&gt;这其实是一个有趣的启示。如果你想考虑6000万人，你必须要学会忘记99.99%的人。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;在建立了抽象的概念、标签、分类以后，你才能真正开始思考。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正如下图所画的，右侧是我们眼前的真实世界，左侧是我们脑中的世界。真实世界有海量的事实、数据、信息等等，纷繁复杂的，且无时不在变化。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 600px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 50.5%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAgABBf/EABUBAQEAAAAAAAAAAAAAAAAAAAEA/9oADAMBAAIQAxAAAAHtNYAlN//EABsQAQABBQEAAAAAAAAAAAAAAAIhAAERIjEy/9oACAEBAAEFAs7qCJNX4fP/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAgEBPwEn/8QAGBAAAgMAAAAAAAAAAAAAAAAAAAERICH/2gAIAQEABj8Cjao//8QAGxAAAwACAwAAAAAAAAAAAAAAAAERECExgaH/2gAIAQEAAT8hW2g1GyKb7xyHgP/aAAwDAQACAAMAAAAQfP8A/8QAFxEBAQEBAAAAAAAAAAAAAAAAAQAhMf/aAAgBAwEBPxB5Bl//xAAWEQEBAQAAAAAAAAAAAAAAAAAAARH/2gAIAQIBAT8QjFf/xAAcEAEBAQACAwEAAAAAAAAAAAABEQAxQSFRYcH/2gAIAQEAAT8Q5yfGQ/cdJA65zAF17edC2F94iaUjiECZ/9k=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;333&quot;
        title=&quot;333&quot;
        src=&quot;/static/70e939a5161fca517a785f266d34794a/82472/333.jpg&quot;
        srcset=&quot;/static/70e939a5161fca517a785f266d34794a/afcd2/333.jpg 300w,
/static/70e939a5161fca517a785f266d34794a/82472/333.jpg 600w&quot;
        sizes=&quot;(max-width: 600px) 100vw, 600px&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如何理解这个复杂的现实世界呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们建立对这个现实世界的简化模型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这些模型可以是一种分类&lt;/strong&gt;，比如彩虹包含一切可见光，是连续光谱，是无穷尽的颜色集合，我们把这一难理解的物理事实安置到一个尺寸相对比较合适、更容易管理的框架中：彩虹是七色的，红、橙、黄、绿、蓝、靛、紫。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这些模型也可以是关于事实的一个模糊的概念&lt;/strong&gt;，每个人都可以自信地说自己知道谷歌的标志是什么样子，那是由红黄蓝三原色组成的6个字母。不过你能准确无误地告诉我哪个颜色被使用了两次吗？你的模型只在某一程度上帮助你理解事物（在这里，它帮助你把谷歌的标志和其他公司的区分开来），却并不完美的反映现实。&lt;/p&gt;
&lt;p&gt;你可以把大脑想象成一个巨大的冰箱，有隔层，也有抽屉。这是一个可以整理现实的混沌，并把一切变得井井有条的方法。我们都按照自己的意愿整理冰箱，把同类东西放在一起。若是没有把实际发生的事情做一个分类和排序，没有人可以应对如此纷繁复杂的人生。&lt;/p&gt;
&lt;p&gt;这就像是我们玩的象棋游戏，现实世界就像是一个真实的战场，而我们在自己脑中建立了棋盘战场和楚河汉界。&lt;/p&gt;
&lt;h4 id=&quot;演绎和归纳&quot;&gt;&lt;a href=&quot;#%E6%BC%94%E7%BB%8E%E5%92%8C%E5%BD%92%E7%BA%B3&quot; aria-label=&quot;演绎和归纳 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;演绎和归纳&lt;/h4&gt;
&lt;p&gt;在清楚了这个游戏的背影设定后，我们考虑的下一个问题自然是：这个游戏的规则是什么？&lt;/p&gt;
&lt;p&gt;回到上面的图，思考的时候，我们有两种行为。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一种是我们从自己脑海移向真实的世界，另一种是从真实的世界移向脑海。前者叫演绎，后者叫归纳。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演绎就像是数学公式的证明，一步一步推导，完全依赖于逻辑。A&gt;B，B&gt;C，所以A&gt;C。如文章开始时的那个例子，当一个品牌对于目标消费者有了清楚的概念和分类，那么针对不同的消费者可以投放什么样的广告，怎样投放就是一种演绎。演绎源于我们的脑海，作用于现实世界产生影响。&lt;/p&gt;
&lt;p&gt;归纳则恰恰现反。归纳源于现实世界的各种信息和事实。它是我们将一切串联、总结到脑海中，形成新的思维模型的过程。如果演绎是根据财务报表，分析企业亏损的来源和解决方案的话，那么归纳就是第一个发明财务报表这一思维模型的过程。&lt;/p&gt;
&lt;p&gt;所以，沿着这样的思路，我们可以给思考下一个定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;思考大概就是使用和建立思维模型的过程&lt;/li&gt;
&lt;li&gt;智慧的第一步是学会质疑，质疑会把我们引向问题，问题会把我们引向真理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;思维模型帮助我们简化世界，更加快速的思考，但同时也是禁锢我们的牢笼。&lt;/p&gt;
&lt;p&gt;且不说一个狭隘片面的思维模型让晋惠帝闹了“百姓无粟米充饥，何不食肉糜？”的笑话，即使是最显而易见、最广为人知的思维模型与现实事实仍然是两回事。&lt;/p&gt;
&lt;p&gt;财务报表应该是商业世界里使用最广泛的思维模型之一了。&lt;/p&gt;
&lt;p&gt;但对于从15世纪改造至今的这个思维模型，我们依然可以提出很多的疑问：比如财务报表的净利润计算中，将应收账款计入营业收入，但这笔钱在现实中真的会收到吗？将折旧计入费用中，这一笔钱又真的支出了吗？&lt;/p&gt;
&lt;p&gt;这些处理方法是这个模型的假设之一，当然有其合理性。这是我们对现实的简化，&lt;strong&gt;但却不能过于执着于思维模型，而忽略了真实的世界。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;揣摩自己思维模型的本质，询问它存在的原因，努力理解它背后的假设和限制，这是我们通往智慧的第一步。&lt;/p&gt;
&lt;p&gt;我相信，变得更有智慧的故事是一首自由的史诗：为了智慧，你必须先越狱，但在越狱之前，你必须首先意识到你是一个囚徒。&lt;/p&gt;
&lt;p&gt;-&lt;/p&gt;
&lt;p&gt;如何系统地提高自己的智慧呢？&lt;/p&gt;
&lt;p&gt;一个直接的答案是阅读、学习，或找优秀的朋友交流。毫无疑问，这些都是很好的智慧来源，但问题是少有人反思我们学到的东西到底如何实用到我们的生活中。&lt;/p&gt;
&lt;p&gt;你可能今天读了一本叫《从0到1》的畅销书，明天学习了一门MOOC上的经济学课程，后天和某大牛朋友促膝长谈两小时。你感觉收获了很多，生活很充实，但你的智慧在以最大的速度形成指数式的积累吗？学习从本质上来讲，一定是复利的。但为什么很少有人能享受到复利的巨大收益呢？&lt;/p&gt;
&lt;h4 id=&quot;从分散的概念到思维模式&quot;&gt;&lt;a href=&quot;#%E4%BB%8E%E5%88%86%E6%95%A3%E7%9A%84%E6%A6%82%E5%BF%B5%E5%88%B0%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%BC%8F&quot; aria-label=&quot;从分散的概念到思维模式 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;从分散的概念到思维模式&lt;/h4&gt;
&lt;p&gt;思维模型是我们对真实世界的简化，可能是一个概念，一个分类等。&lt;/p&gt;
&lt;p&gt;INSEAD教授，前BCG欧洲合伙人 Luc De Brabandere 在”What Managers Can Learn from Philosophy”课程指出，当我们思考时，其实是对这些思维模型进行处理的过程。他对“思考”的定义是：&lt;strong&gt;思考就是使用和建立思维模型的过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但问题在于我们建立了很多的思维模型或独立的概念，但却无法将它们串联成一个有机的系统。正如查理·芒格所说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;基本的、普世的智慧是什么？嗯，第一条规则是，如果你们只是记得一些孤立的事物，试图把它们硬凑起来，那么你们无法真正地理解任何东西。如果这些事物不在一个理论框架中相互联系，你们就无法把它们派上用场。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;你们必须在头脑中拥有一些思维模式。你们必须依靠这些模式组成的框架来安排你的经验，包括间接的和直接的。你们也许已经注意到，有些学生试图死记硬背，以此来应付考试。他们在学校中是失败者，在生活中也是失败者。你必须把经验悬挂在头脑中的一个由许多思维模式组成的框架上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这就是芒格著名的“格栅理论”。Peter Beverlin在”Seeking Wisdom”一书中有一个关于“思维模式”的进一步解释:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个思维模式就是帮助我们更好的理解世界运转规律的想法。一个思维模式往往阐释了结果，并且回答了像“Why”和”How”这类问题。&lt;/p&gt;
&lt;p&gt;比如“社会认同”（心理学的一种理论）这一模式告诉我们当人们不确定时，他们经常自动选择模仿其他人做的事情，而不会想真正正确的事是什么。这样的理论解释了人们为什么做（Why），同时预测了在特定情景下人们又会如何做一件事（How）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再举个例子&lt;/p&gt;
&lt;p&gt;你可能知道，在化学领域，有一种自催化（Autocatalysis）的现象。当一个化学反应的产物能够对这个反应的速率有进一步催化作用时，反应的速率以极快的速度提高，这种反应被称为自催化反应。在这种思维模式中，你只需要做A，但会得到A+B+C的效果。&lt;/p&gt;
&lt;p&gt;作为一种典型的思维模式，这种自催化现象你可以在很多地方遇到。一个很明显的例子是亚马逊。关于亚马逊战略的总结&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;贝佐斯与其助理团队描绘了公司步入良性循环的前景，他们相信这会成为公司发展的强大动力。公司的未来蓝图是这样的：以更低的价格来吸引更多的顾客。更多的顾客意味着更高的销量，而且也会把付给亚马逊佣金的第三方销售商更多地吸引到网站来。这也会使亚马逊从固定成本中赚取更多的利润，如物流中心和运行网站的服务器。更高的效率会使价格进一步降低。他们推断，任何一个飞轮只要运行顺畅，就会加速整个的循环过程。
—— 《一网打尽》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这其实是一种非常典型的自催化模式。&lt;/p&gt;
&lt;p&gt;另一个应用自催化模式的例子是迪士尼。我一直私以为迪士尼是全球最好的商业模式之一。&lt;/p&gt;
&lt;p&gt;迪士尼最重要的是做好一件事：电影制作。电影会产生巨额的收入，一个电影传播越广，这个电影的IP就越经典。迪士尼乐园、电影衍生品IP授权等其他的业务都会因此获益。更重要的是，这个模式是互相催化的。消费者越喜欢迪士尼乐园、购买电影的衍生品，也会进一步购买迪士尼出产的电影。&lt;/p&gt;
&lt;p&gt;此外，你还可以发现和建立自己的自催化模式，来加速达到你的目标。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;建立思维模式是非常重要的。因为思维模式的丰富度和质量，决定了我们是否可以从更全面的角度思考问题，给出深入的解析&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;另一个有趣的例子来自著名的理论物理学家，诺贝尔物理学奖得主费曼。他在普林斯顿读博士期间，经常溜去数学系，为那些天才的数学系博士生解决他们解决不了的问题。他在《别闹了，费曼先生》一书中，透露了他的秘密&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;…我在麻省理工或普林斯顿的朋友被某些积分难住，原因却是他们从学校学来的标准方法不管用。如果那是围道积分或级数展开，他们都懂得怎么把答案找出；现在他们却碰壁了。这时我便使出“积分符号内取微分”的方法——这是因为我有一个与众不同的工具箱。当其他人用光了他们的工具，还没法找到解答时，便把问题交给我了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“积分符号内取微分”的方法就是费曼不一样的“思维模式”的一种。费曼因为拥有不一样的“工具箱”，所以可以解出天才的数学系博士生都无法解决的问题。&lt;/p&gt;
&lt;p&gt;我们很多人每天工作、阅读和学习，形成了很多概念、记住了很多散布各领域的事实和结论，但却没有主动的寻找和总结类似的思维模式形成自己与众不同的工具箱，这无疑是提高智慧过程中缺失的重要一环。&lt;/p&gt;
&lt;p&gt;从某种意义上说，提高智慧的过程，就是不断通过阅读和学习发现掌握新的思维模式，充实我们工具箱的过程。&lt;/p&gt;
&lt;h4 id=&quot;你需要同时使用多种思维模式&quot;&gt;&lt;a href=&quot;#%E4%BD%A0%E9%9C%80%E8%A6%81%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%A7%8D%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%BC%8F&quot; aria-label=&quot;你需要同时使用多种思维模式 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;你需要同时使用多种思维模式&lt;/h4&gt;
&lt;p&gt;诺贝尔经济学奖得主，卡内基梅隆大学计算机科学和心理学教授 Herbert Simon 是首次提出思维模式这一思想的人。他在自传”Models of My Life”中写到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;非常有经验的决策者和新手一个很大的不同不是那些无形的“直觉”，如果我们能够进入非常有经验的决策者的脑海，会发现 1) 他们很清楚所有可能的行动，2) 在行动之前，他们有一个要思考问题的核查清单，3) 他们脑子里有一个机制在相关的决策环境出现时，可以唤醒所有相关的清单事项&lt;/p&gt;
&lt;p&gt;不同的思维模式，或思考问题的角度构成了Herbert Simon所说的”核查清单”。很明显，只掌握一种思维模式是远远不够的，但这恰恰是很多人的现状。芒格尖锐的指出&lt;/p&gt;
&lt;p&gt;你必须拥有多元思维模型——因为如果你只能使用一两个，研究人性的心理学表明，你将会扭曲现实，直到它符合你的思维模型，或者至少到你认为它符合你的模型为止。你将会和一个脊椎按摩师一样——这种医师对现代医学当然是毫无所知的。&lt;/p&gt;
&lt;p&gt;那就像谚语所说的：“在手里拿着铁锤的人看来,每个问题都像钉子。”当然，脊椎按摩师也是这样治病的。但这绝对是一种灾难性的思考方式，也绝对是一种灾难性的处世方式。所以你必须拥有多元思维模型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;生活中，我们可以找到很多“拿着锤子找钉子”的人。有趣的是，有时候如果一个人在一个领域越擅长，他就越倾向于认为自己的思维模式适合解决世界上大部分的问题。&lt;/p&gt;
&lt;p&gt;有一个典型的例子是《长尾理论》的作者，《连线》杂志的总编辑 Chris Anderson。关于这一点，Tim Wu 有一篇精彩的评论，告诉了我们一个优秀的人因为单一思维模式所带来的局限。&lt;/p&gt;
&lt;p&gt;对应的，如果你可以同时掌握多种思维模式，你解决问题的能力会成倍地提升，因为你有更多获得问题答案的角度和方法。这也是真正优秀的人，如费曼、芒格，与一般人的区别：&lt;strong&gt;他们有更多的思维模式可以自由的使用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;巴菲特评价芒格：“他有这个世界上最聪明的30秒头脑。他一次就能把从A到Z全部想全。你还没有说完，他已经看到了一切的本质。”&lt;/p&gt;
&lt;h4 id=&quot;获得多学科思维模式&quot;&gt;&lt;a href=&quot;#%E8%8E%B7%E5%BE%97%E5%A4%9A%E5%AD%A6%E7%A7%91%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%BC%8F&quot; aria-label=&quot;获得多学科思维模式 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;获得多学科思维模式&lt;/h4&gt;
&lt;p&gt;那么，我们如何获得更多的思维模式呢？&lt;/p&gt;
&lt;p&gt;方法有两种。&lt;/p&gt;
&lt;p&gt;第一种，也是最直接的一种就是大量的有意识的练习。每个领域的专家，很多都是在这种训练中逐渐建立自己独特的思维模式的。在这方面有两本书可以参考，一本是格拉德威尔举世闻名的《异类》，另一本是”Talent is over rated”（中文译：《哪来的天才》），在这里不赘述。&lt;/p&gt;
&lt;p&gt;我们聊一下第二种：如何通过阅读和学习获得。&lt;/p&gt;
&lt;p&gt;我相信很多人平时都会做大量的阅读，读微信公众号的最近文章，媒体的报道等，但这些都很难让我们获得新的思维模式，因为大量的文章都是实时性的，是一种信息和谈资的获取。过了一定的时间，你掌握的信息就不再有价值，这种情况下，当然不会有智慧的积累，所以很难产生曲线E的效果。&lt;/p&gt;
&lt;p&gt;前面提到过，一个思维模式就是帮助我们更好的理解世界运转规律的想法。这些思维模式一定是非常固定的，很少改变，同时揭示了现实世界的一部分规律。所以第二种方法是通过学习重要学科，特别是基础学科的重要理论。
芒格指出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;…这么说吧，第一条规则是，你必须拥有多元思维模型。这些模型必须来自各个不同的学科——因为你们不可能在一个小小的院系里面发现人世间全部的智慧。所以让我们来简单地看看哪些模型和技巧构成了每个人必须拥有的基础知识，有了这样的基础知识之后，他们才能够精通某项专门的艺术，比如说选股票.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这一点上，John Reed, 在”Succeeding”一书进一步补充到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当你首先可以学习一个领域时，好像你要学习上百万件事情。
你其实不必如此。
你只需要识别出这个领域最核心的原则——一般只有3-12个。你觉得你要记住的上百万的事情，不过是这些核心原则的不同组合而已&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查理·芒格也提到:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你们也许会说：“天哪，这太难做到啦。”但是，幸运的是，这没有那么难——因为掌握八九十个模型就占了90%的权重，差不多能让你成为拥有普世智慧的人了。而在这八九十个模型里面，非常重要的只有几个&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查理·芒格的更详细阐述，请见1994年在南加州大学马歇尔商学院的经典演讲或《穷查理宝典》&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过学习和运用几个，最多几十个各个学科最基本的原理或模型，就有机会显著的提高自己的智慧，这是一件多么合算的事情&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;从这里出发&quot;&gt;&lt;a href=&quot;#%E4%BB%8E%E8%BF%99%E9%87%8C%E5%87%BA%E5%8F%91&quot; aria-label=&quot;从这里出发 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;从这里出发&lt;/h4&gt;
&lt;p&gt;读得越多，就越相信这种方法是系统地提高我们智慧的最佳方法之一。&lt;/p&gt;
&lt;p&gt;有一次，当被问到如何变得更聪明时，巴菲特举起来一叠纸，说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每天阅读这样大小的500页书。知识就是这样积累起来的，就像复利一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;芒格也有一段让人触动的话&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们大量的阅读。
在我所见过的所有有智慧的人里，没有任何一个人是不大量阅读的。
但这还远远不够：你需要有这种个性，可以抓到关键并且真正领会它们。大部分人不能抓到正确的想法，或者并不知道之后要怎么做&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这三个段落是芒格上面这句话的解释。但它们更像是骨架，而每个人自己智慧的血肉还需要自己来填充。这三个段落从来不是追寻智慧旅程的终点，我也希望在后面的文章中，不断分享更具体的思维模式，更多的方法和思考。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但我相信它们是一个好的起点。让我们开始主动地、系统地提高自己的智慧&lt;/strong&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[降低软件复杂性的一般原则和方法]]></title><description><![CDATA[一、前言 斯坦福教授、Tcl语言发明者John Ousterhout 的著作《A Philosophy of Software Design》1，自出版以来，好评如潮。按照IT…]]></description><link>https://lizhi1026.cc/2019/09-20/javascript-run-loop-ics</link><guid isPermaLink="false">https://lizhi1026.cc/2019/09-20/javascript-run-loop-ics</guid><pubDate>Fri, 20 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80&quot; aria-label=&quot;一、前言 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;一、前言&lt;/h3&gt;
&lt;p&gt;斯坦福教授、Tcl语言发明者John Ousterhout 的著作《A Philosophy of Software Design》[1]，自出版以来，好评如潮。按照IT图书出版的惯例，如果冠名为“实践”，书中内容关注的是某项技术的细节和技巧；冠名为“艺术”，内容可能是记录优秀作品的设计过程和经验；而冠名为“哲学”，则是一些通用的原则和方法论，这些原则方法论串起来，能够形成一个体系。正如“知行合一”、“世界是由原子构成的”、“我思故我在”，这些耳熟能详的句子能够一定程度上代表背后的人物和思想。用一句话概括《A Philosophy of Software Design》，软件设计的核心在于降低复杂性。&lt;/p&gt;
&lt;p&gt;本篇文章是围绕着“降低复杂性”这个主题展开的，很多重要的结论来源于John Ousterhout，笔者觉得很有共鸣，就做了一些相关话题的延伸、补充了一些实例。虽说是“一般原则”，也不意味着是绝对的真理，整理出来，只是为了引发大家对软件设计的思考。&lt;/p&gt;
&lt;h3 id=&quot;二、如何定义复杂性&quot;&gt;&lt;a href=&quot;#%E4%BA%8C%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%A4%8D%E6%9D%82%E6%80%A7&quot; aria-label=&quot;二、如何定义复杂性 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;二、如何定义复杂性&lt;/h3&gt;
&lt;p&gt;关于复杂性，尚无统一的定义，从不同的角度可以给出不同的答案。可以用数量来度量，比如芯片集成的电子器件越多越复杂（不一定对）；按层次性[2]度量，复杂度在于层次的递归性和不可分解性。在信息论中，使用熵来度量信息的不确定性。&lt;/p&gt;
&lt;p&gt;John Ousterhout选择从认知的负担和开发工作量的角度来定义软件的复杂性，并且给出了一个复杂度量公式：&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 400px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 30.75%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAAAkUlEQVQY05VRywrEIAzs/3+dHtqDIBRK8eCTggetdZYNuHS3lrIBkZmYcZIM+IlaK3qx7/sl1/CZH+4ehBCQcyY8jiPmeYZzjnDjewa6gt57CCFgjIHWGuu60nm7ZIyBcw6l1Kfm0WEphYqP4yBuWRZM00Ti27bRba19FrybYYwRUsqvVv9quf16ximlS663lBeof9b+4pSzggAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;calc&quot;
        title=&quot;calc&quot;
        src=&quot;/static/10d4947098126b3c93060aa4da01086a/c7805/calc.png&quot;
        srcset=&quot;/static/10d4947098126b3c93060aa4da01086a/135ae/calc.png 300w,
/static/10d4947098126b3c93060aa4da01086a/c7805/calc.png 400w&quot;
        sizes=&quot;(max-width: 400px) 100vw, 400px&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;子模块的复杂度Cp乘以该模块对应的开发时间权重值tp，累加后得到系统的整体复杂度C。系统整体的复杂度并不简单等于所有子模块复杂度的累加，还要考虑开发维护该模块所花费的时间在整体时间中的占比（对应权重值tp）。也就是说，即使某个模块非常复杂，如果很少使用或修改，也不会对系统的整体复杂度造成大的影响。
子模块的复杂度Cp是一个经验值，它关注几个现象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;修改扩散&lt;/strong&gt;，修改时有连锁反应&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;认知负担&lt;/strong&gt;，开发人员需要多长时间来理解功能模块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不可知&lt;/strong&gt;(Unknown Unknowns），开发人员在接到任务时，不知道从哪里入手。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;造成复杂的原因一般是代码依赖和晦涩（Obscurity）。其中，依赖是指某部分代码不能被独立地修改和理解，必定会牵涉到其他代码。代码晦涩，是指从代码中难以找到重要信息。&lt;/p&gt;
&lt;h3 id=&quot;三、解决复杂性的一般原则&quot;&gt;&lt;a href=&quot;#%E4%B8%89%E3%80%81%E8%A7%A3%E5%86%B3%E5%A4%8D%E6%9D%82%E6%80%A7%E7%9A%84%E4%B8%80%E8%88%AC%E5%8E%9F%E5%88%99&quot; aria-label=&quot;三、解决复杂性的一般原则 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;三、解决复杂性的一般原则&lt;/h3&gt;
&lt;p&gt;首先，互联网行业的软件系统，很难一开始就做出完美的设计，通过一个个功能模块衍生迭代，系统才会逐步成型。对于现存的系统，也很难通过一个大动作，一劳永逸地解决所有问题。系统设计是需要持续投入的工作，通过细节的积累，最终得到一个完善的系统。因此，好的设计是日拱一卒的结果，在日常工作中要重视设计和细节的改进。&lt;/p&gt;
&lt;p&gt;其次，专业化分工和代码复用促成了软件生产率的提升。比如硬件工程师、软件工程师（底层、应用、不同编程语言）可以在无需了解对方技术背景的情况下进行合作开发；同一领域服务可以支撑不同的上层应用逻辑等等。其背后的思想，无非是通过将系统分成若干个水平层、明确每一层的角色和分工，来降低单个层次的复杂性。同时，每个层次只要给相邻层提供一致的接口，可以用不同的方法实现，这就为软件重用提供了支持。分层是解决复杂性问题的重要原则。&lt;/p&gt;
&lt;p&gt;第三，与分层类似，分模块是从垂直方向来分解系统。分模块最常见的应用场景，是如今广泛流行的微服务。分模块降低了单模块的复杂性，但是也会引入新的复杂性，例如模块与模块的交互，后面的章节会讨论这个问题。这里，我们将第三个原则确定为分模块。&lt;/p&gt;
&lt;p&gt;最后，代码能够描述程序的工作流程和结果，却很难描述开发人员的思路，而注释和文档可以。此外，通过注释和文档，开发人员在不阅读实现代码的情况下，就可以理解程序的功能，注释间接促成了代码抽象。好的注释能够帮助解决软件复杂性问题，尤其是认知负担和不可知问题（Unknown Unknowns）。&lt;/p&gt;
&lt;h3 id=&quot;四、解决复杂性之日拱一卒&quot;&gt;&lt;a href=&quot;#%E5%9B%9B%E3%80%81%E8%A7%A3%E5%86%B3%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B9%8B%E6%97%A5%E6%8B%B1%E4%B8%80%E5%8D%92&quot; aria-label=&quot;四、解决复杂性之日拱一卒 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;四、解决复杂性之日拱一卒&lt;/h3&gt;
&lt;h4 id=&quot;41-拒绝战术编程&quot;&gt;&lt;a href=&quot;#41-%E6%8B%92%E7%BB%9D%E6%88%98%E6%9C%AF%E7%BC%96%E7%A8%8B&quot; aria-label=&quot;41 拒绝战术编程 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4.1 拒绝战术编程&lt;/h4&gt;
&lt;p&gt;战术编程致力于完成任务，新增加特性或者修改Bug时，能解决问题就好。这种工作方式，会逐渐增加系统的复杂性。如果系统复杂到难以维护时，再去重构会花费大量的时间，很可能会影响新功能的迭代。&lt;/p&gt;
&lt;p&gt;战略编程，是指重视设计并愿意投入时间，短时间内可能会降低工作效率，但是长期看，会增加系统的可维护性和迭代效率。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 337px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 75.96439169139467%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAABLklEQVQ4y51U2YqEQAzs//8mH/QLxDcZFUFQB8djPBCvMUsFItqrjLuBoCaxuqq6VQ3DQHmek+d51DQNVVV1mu/3m7IsoyRJKE1TKoqC6rrm+n5OBUFAcRxz81s8Hg8yDIMsyyIQWdeVxnE8zCjXdXnVvu+58Pl8ePAspbcsC6sBu3meDz0FEBlA6CD7GgKMoEYYSn1jiAKaOqB+jxCPMS/ZdR3XXq8XPytZdQ+og0EWXoDEaZr4GRIRsMtxHDJNk57P5zngnlXbtry7WF0PXS5LvmIIX8GoLMsDwJW/kr8ARSKMBzudzZ8B4RHuYfbZJn0LBoQ/YAOjwey/YAcPAQhmV+fxbiqReffzu8UQOxpF0fYTkOudlJ9CGIa8mWrvzV1Zcqht2ybf97djht4PoRGVECfbjM4AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;leaner&quot;
        title=&quot;leaner&quot;
        src=&quot;/static/c44f7b282f3302131f9653deebe03ddd/3e757/leaner.png&quot;
        srcset=&quot;/static/c44f7b282f3302131f9653deebe03ddd/135ae/leaner.png 300w,
/static/c44f7b282f3302131f9653deebe03ddd/3e757/leaner.png 337w&quot;
        sizes=&quot;(max-width: 337px) 100vw, 337px&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;设计系统时，很难在开始阶段就面面俱到。好的设计应该体现在一个个小的模块上，修改Bug时，也应该抱着设计新系统的心态，完工后让人感觉不到“修补”的痕迹。经过累积，最终形成一个完善的系统。从长期看，对于中大型的系统，将日常开发时间的10%-15%用于设计是值得的。有一种观点认为，创业公司需要追求业务迭代速度和节省成本，可以容忍糟糕的设计，这是用错误的方法去追求正确的目标。降低开发成本最有效的方式是雇佣优秀的工程师，而不是在设计上做妥协。&lt;/p&gt;
&lt;h4 id=&quot;42-设计两次&quot;&gt;&lt;a href=&quot;#42-%E8%AE%BE%E8%AE%A1%E4%B8%A4%E6%AC%A1&quot; aria-label=&quot;42 设计两次 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4.2 设计两次&lt;/h4&gt;
&lt;p&gt;为一个类、模块或者系统的设计提供两套或更多方案，有利于我们找到最佳设计。以我们日常的技术方案设计为例，技术方案本质上需要回答两个问题，其一，为什么该方案可行？其二，在已有资源限制下，为什么该方案是最优的？为了回答第一个问题，我们需要在技术方案里补充架构图、接口设计和时间人力估算。而要回答第二个问题，需要我们在关键点或争议处提供二到三种方案，并给出建议方案，这样才有说服力。&lt;/p&gt;
&lt;p&gt;通常情况下，我们会花费很多的时间准备第一个问题，而忽略第二个问题。其实，回答好第二个问题很重要，大型软件的设计已经复杂到没人能够一次就想到最佳方案，一个仅仅“可行”的方案，可能会给系统增加额外的复杂性。对聪明人来说，接受这点更困难，因为他们习惯于“一次搞定问题”。但是聪明人迟早也会碰到自己的瓶颈，在低水平问题上徘徊，不如花费更多时间思考，去解决真正有挑战性的问题。&lt;/p&gt;
&lt;h3 id=&quot;五、解决复杂性之分层&quot;&gt;&lt;a href=&quot;#%E4%BA%94%E3%80%81%E8%A7%A3%E5%86%B3%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B9%8B%E5%88%86%E5%B1%82&quot; aria-label=&quot;五、解决复杂性之分层 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;五、解决复杂性之分层&lt;/h3&gt;
&lt;h4 id=&quot;51-层次和抽象&quot;&gt;&lt;a href=&quot;#51-%E5%B1%82%E6%AC%A1%E5%92%8C%E6%8A%BD%E8%B1%A1&quot; aria-label=&quot;51 层次和抽象 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5.1 层次和抽象&lt;/h4&gt;
&lt;p&gt;软件系统由不同的层次组成，层次之间通过接口来交互。在严格分层的系统里，内部的层只对相邻的层次可见，这样就可以将一个复杂问题分解成增量步骤序列。由于每一层最多影响两层，也给维护带来了很大的便利。分层系统最有名的实例是TCP/IP网络模型。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 380px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 92.10526315789474%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsSAAALEgHS3X78AAACLklEQVQ4y2WU56oqUQyF5/2fx58iKlgQRBG7Hvux935suXyBNeh1Q9g1KysrmQl2u51h+/3elsulDQYD+/399Rnr9/s+93o9i0QiFovFbDweh+ey0Wjk54G9jdvtZo/Hw40Ax+PR7e/vz/ez2cyGw6FtNhu73+92OBzsdDr5fL1eHeMDkMN3g/l6vXYHjECwIBPuAOaegAA7IA+hO51OHYRLZqVBaj8/P84Om0wmIRD3GGxDQCKWSiWr1WofgM1m08G63a6nCdh8Pg8ZArpYLGy73TpYCPh/ygBeLhfrdDoO1m633ZEMYKMAFIk9jHkfAr5eL9eGWYDSBBYYelEcioYUMCVlmMKQlM/n8zdDseNSlWPNOXtAAQEMAmJGB3DPWUAEopIWjupJNKtWq9ZoNJwR92IHKKmjPT3L3Wq1cgvQIZvNWr1e/yg/Q7oRmcEd8jDQDn21x5dAXynDEPoIT3TO1IvsYc8eOWBLcaQ18gS0RyKR8PR4hC6A0Eaky1BBYMxMUN7iUy6X3Ycz5oALdJQTKdLIlUrFWq2WO7HGkTXtBBulqEzQzxmiAZf6hnHmBxCPxy2dTlsmk7FcLuc6J5NJy+fz/p5B6qlUygqFQngWoEE0GvVD+gmhi8WifymkTADOYAJj1nJGV/1tYOcpw0p/GWnIUGWfz2eoJ58igLQLEgCot2BgX78vqqjmxmgVNMLUj9qju94yO0PQZQzSVjSMPSA0Mizfi0QxlaHsH3N9TxBR5koVAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;model&quot;
        title=&quot;model&quot;
        src=&quot;/static/7dffcb23e8ed50776682d27e1f1246d4/b2ba1/model.png&quot;
        srcset=&quot;/static/7dffcb23e8ed50776682d27e1f1246d4/135ae/model.png 300w,
/static/7dffcb23e8ed50776682d27e1f1246d4/b2ba1/model.png 380w&quot;
        sizes=&quot;(max-width: 380px) 100vw, 380px&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在分层系统里，每一层应该具有不同的抽象。TCP/IP模型中，应用层的抽象是用户接口和交互；传输层的抽象是端口和应用之间的数据传输；网络层的抽象是基于IP的寻址和数据传输；链路层的抽象是适配和虚拟硬件设备。如果不同的层具有相同的抽象，可能存在层次边界不清晰的问题&lt;/p&gt;
&lt;h4 id=&quot;52-复杂性下沉&quot;&gt;&lt;a href=&quot;#52-%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8B%E6%B2%89&quot; aria-label=&quot;52 复杂性下沉 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5.2 复杂性下沉&lt;/h4&gt;
&lt;p&gt;不应该让用户直面系统的复杂性，即便有额外的工作量，开发人员也应当尽量让用户使用起来更简单。如果一定要在某个层次处理复杂性，这个层次越低越好。举个例子，Thrift接口调用时，数据传输失败需要引入自动重试机制，重试的策略显然在Thrift内部封装更合适，开放给用户（下游开发人员）会增加额外的使用负担。与之类似的是系统里随处可见的配置参数（通常写在XML文件里），在编程中应当尽量避免这种情况，用户（下游开发人员）一般很难决定哪个参数是最优的，如果一定要开放参数配置，最好给定一个默认值。&lt;/p&gt;
&lt;p&gt;复杂性下沉，并不是说把所有功能下移到一个层次，过犹不及。如果复杂性跟下层的功能相关，或者下移后，能大大下降其他层次或整体的复杂性，则下移。&lt;/p&gt;
&lt;h4 id=&quot;53-异常处理&quot;&gt;&lt;a href=&quot;#53-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86&quot; aria-label=&quot;53 异常处理 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5.3 异常处理&lt;/h4&gt;
&lt;p&gt;异常和错误处理是造成软件复杂的罪魁祸首之一。有些开发人员错误的认为处理和上报的错误越多越好，这会导致过度防御性的编程。如果开发人员捕获了异常并不知道如何处理，直接往上层扔，这就违背了封装原则。&lt;/p&gt;
&lt;p&gt;降低复杂度的一个原则就是尽可能减少需要处理异常的可能性。而最佳实践就是确保错误终结，例如删除一个并不存在的文件，与其上报文件不存在的异常，不如什么都不做。确保文件不存在就好了，上层逻辑不但不会被影响，还会因为不需要处理额外的异常而变得简单。&lt;/p&gt;
&lt;h3 id=&quot;六、解决复杂性之分模块&quot;&gt;&lt;a href=&quot;#%E5%85%AD%E3%80%81%E8%A7%A3%E5%86%B3%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B9%8B%E5%88%86%E6%A8%A1%E5%9D%97&quot; aria-label=&quot;六、解决复杂性之分模块 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;六、解决复杂性之分模块&lt;/h3&gt;
&lt;p&gt;分模块是解决复杂性的重要方法。理想情况下，模块之间应该是相互隔离的，开发人员面对具体的任务，只需要接触和了解整个系统的一小部分，而无需了解或改动其他模块。&lt;/p&gt;
&lt;h4 id=&quot;61-深模块和浅模块&quot;&gt;&lt;a href=&quot;#61-%E6%B7%B1%E6%A8%A1%E5%9D%97%E5%92%8C%E6%B5%85%E6%A8%A1%E5%9D%97&quot; aria-label=&quot;61 深模块和浅模块 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6.1 深模块和浅模块&lt;/h4&gt;
&lt;p&gt;深模块（Deep Module）指的是拥有强大功能和简单接口的模块。深模块是抽象的最佳实践，通过排除模块内部不重要的信息，让用户更容易理解和使用。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1081px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 58.55689176688252%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAABa0lEQVQoz3WTyQoCMRBE/f+vULzNQfAy4uAHePagF8UFFfdl3NeS19AhghaEmSSdqup0p/B+v+UDXC4Xjcdj9ft9G/P5XMPhUJPJxPaJe71eis8xB8ViUQX9wHq91nQ61Ww203K51G630+FwCKL/YIQ4Oh6POp/P2mw2Rna9XoPq7XbT8/kMh3DbarU0GAy0WCw0Go0sE1AqlVSo1WpKkkSVSkXlclmNRuNLFTLE/Isozvm/3+8mjqngkFQIZhNXuPXUWOcATk6nk8X4uv//TDkGhKxB4CS4eTweIQYRRlykQEiwq3L5q9XKCDwIOGlM6Eb+EvoGc085rirO43uNHX8RxkrAC+Dz7XarLMtUrVZVr9etaGmaimIybzabIdYI8zwPbYESc29cwDX0ej1rF9qDNul2u2q329Y6DC+QEXIf+/1enU7Hqknfxaki5oN1MoAQYUDqbii8FBZRpoU8/fg5xsAArugAR5zyB+aEkWbTthLdAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;deep&quot;
        title=&quot;deep&quot;
        src=&quot;/static/b8f277d35c1315a542f1d3b1ebeebfb7/2fd12/deep.png&quot;
        srcset=&quot;/static/b8f277d35c1315a542f1d3b1ebeebfb7/135ae/deep.png 300w,
/static/b8f277d35c1315a542f1d3b1ebeebfb7/34e8a/deep.png 600w,
/static/b8f277d35c1315a542f1d3b1ebeebfb7/2fd12/deep.png 1081w&quot;
        sizes=&quot;(max-width: 1081px) 100vw, 1081px&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Unix操作系统文件I/O是典型的深模块，以Open函数为例，接口接受文件名为参数，返回文件描述符。但是这个接口的背后，是几百行的实现代码，用来处理文件存储、权限控制、并发控制、存储介质等等，这些对用户是不可见的。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; path&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; flags&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; mode_t permissions&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与深模块相对的是浅模块（Shallow Module），功能简单，接口复杂。通常情况下，浅模块无助于解决复杂性。因为他们提供的收益（功能）被学习和使用成本抵消了。以Java I/O为例，从I/O中读取对象时，需要同时创建三个对象FileInputStream、BufferedInputStream、ObjectInputStream，其中前两个创建后不会被直接使用，这就给开发人员造成了额外的负担。默认情况下，开发人员无需感知到BufferedInputStream，缓冲功能有助于改善文件I/O性能，是个很有用的特性，可以合并到文件I/O对象里。假如我们想放弃缓冲功能，文件I/O也可以设计成提供对应的定制选项。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;FileInputStream fileStream &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; new &lt;span class=&quot;token function&quot;&gt;FileInputStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fileName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
BufferedInputStream bufferedStream &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; new &lt;span class=&quot;token function&quot;&gt;BufferedInputStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fileStream&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
ObjectInputStream objectStream &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; new &lt;span class=&quot;token function&quot;&gt;ObjectInputStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;bufferedStream&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于浅模块有一些争议，大多数情况是因为浅模块是不得不接受的既定事实，而不见得是因为合理性。当然也有例外，比如领域驱动设计里的防腐层，系统在与外部系统对接时，会单独建立一个服务或模块去适配，用来保证原有系统技术栈的统一和稳定性。&lt;/p&gt;
&lt;h4 id=&quot;62-通用和专用&quot;&gt;&lt;a href=&quot;#62-%E9%80%9A%E7%94%A8%E5%92%8C%E4%B8%93%E7%94%A8&quot; aria-label=&quot;62 通用和专用 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6.2 通用和专用&lt;/h4&gt;
&lt;p&gt;设计新模块时，应该设计成通用模块还是专用模块？一种观点认为通用模块满足多种场景，在未来遇到预期外的需求时，可以节省时间。另外一种观点则认为，未来的需求很难预测，没必要引入用不到的特性，专用模块可以快速满足当前的需求，等有后续需求时再重构成通用的模块也不迟。&lt;/p&gt;
&lt;p&gt;以上两种思路都有道理，实际操作的时候可以采用两种方式各自的优点，即在功能实现上满足当前的需求，便于快速实现；接口设计通用化，为未来留下余量。举个例子。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;backspace&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Cursor cursor&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Cursor cursor&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;deleteSelection&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Selection selection&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;//以上三个函数可以合并为一个更通用的函数&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Position start&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Position end&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设计通用性接口需要权衡，既要满足当前的需求，同时在通用性方面不要过度设计。一些可供参考的标准：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;满足当前需求最简单的接口是什么？在不减少功能的前提下，减少方法的数量，意味着接口的通用性提升了。&lt;/li&gt;
&lt;li&gt;接口使用的场景有多少？如果接口只有一个特定的场景，可以将多个这样的接口合并成通用接口。&lt;/li&gt;
&lt;li&gt;满足当前需求情况下，接口的易用性如何？如果接口很难使用，意味着我们可能过度设计了，需要拆分。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;63-信息隐藏&quot;&gt;&lt;a href=&quot;#63-%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F&quot; aria-label=&quot;63 信息隐藏 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6.3 信息隐藏&lt;/h4&gt;
&lt;p&gt;信息隐藏是指，程序的设计思路以及内部逻辑应当包含在模块内部，对其他模块不可见。如果一个模块隐藏了很多信息，说明这个模块在提供很多功能的同时又简化了接口，符合前面提到的深模块理念。软件设计领域有个技巧，定义一个“大”类有助于实现信息隐藏。这里的“大”类指的是，如果要实现某功能，将该功能相关的信息都封装进一个类里面。&lt;/p&gt;
&lt;p&gt;信息隐藏在降低复杂性方面主要有两个作用：一是简化模块接口，将模块功能以更简单、更抽象的方式表现出来，降低开发人员的认知负担；二是减少模块间的依赖，使得系统迭代更轻量。举个例子，如何从B+树中存取信息是一些数据库索引的核心功能，但是数据库开发人员将这些信息隐藏了起来，同时提供简单的对外交互接口，也就是SQL脚本，使得产品和运营同学也能很快地上手。并且，因为有足够的抽象，数据库可以在保持外部兼容的情况下，将索引切换到散列或其他数据结构。&lt;/p&gt;
&lt;p&gt;与信息隐藏相对的是信息暴露，表现为：设计决策体现在多个模块，造成不同模块间的依赖。举个例子，两个类能处理同类型的文件。这种情况下，可以合并这两个类，或者提炼出一个新类（参考《重构》[3]一书）。工程师应当尽量减少外部模块需要的信息量。&lt;/p&gt;
&lt;h4 id=&quot;64-拆分和合并&quot;&gt;&lt;a href=&quot;#64-%E6%8B%86%E5%88%86%E5%92%8C%E5%90%88%E5%B9%B6&quot; aria-label=&quot;64 拆分和合并 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6.4 拆分和合并&lt;/h4&gt;
&lt;p&gt;两个功能，应该放在一起还是分开？“不管黑猫白猫”，能降低复杂性就好。这里有一些可以借鉴的设计思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共享信息的模块应当合并，比如两个模块都依赖某个配置项。&lt;/li&gt;
&lt;li&gt;可以简化接口时合并，这样可以避免客户同时调用多个模块来完成某个功能。&lt;/li&gt;
&lt;li&gt;可以消除重复时合并，比如抽离重复的代码到一个单独的方法中。&lt;/li&gt;
&lt;li&gt;通用代码和专用代码分离，如果模块的部分功能可以通用，建议和专用部分分离。举个例子，在实际的系统设计中，我们会将专用模块放在上层，通用模块放在下层以供复用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;七、解决复杂性之注释&quot;&gt;&lt;a href=&quot;#%E4%B8%83%E3%80%81%E8%A7%A3%E5%86%B3%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B9%8B%E6%B3%A8%E9%87%8A&quot; aria-label=&quot;七、解决复杂性之注释 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;七、解决复杂性之注释&lt;/h3&gt;
&lt;p&gt;注释可以记录开发人员的设计思路和程序功能，降低开发人员的认知负担和解决不可知（Unkown Unkowns）问题，让代码更容易维护。通常情况下，在程序的整个生命周期里，编码只占了少部分，大量时间花在了后续的维护上。有经验的工程师懂得这个道理，通常也会产出更高质量的注释和文档。&lt;/p&gt;
&lt;p&gt;注释也可以作为系统设计的工具，如果只需要简单的注释就可以描述模块的设计思路和功能，说明这个模块的设计是良好的。另一方面，如果模块很难注释，说明模块没有好的抽象。&lt;/p&gt;
&lt;h4 id=&quot;71-注释的误区&quot;&gt;&lt;a href=&quot;#71-%E6%B3%A8%E9%87%8A%E7%9A%84%E8%AF%AF%E5%8C%BA&quot; aria-label=&quot;71 注释的误区 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;7.1 注释的误区&lt;/h4&gt;
&lt;p&gt;关于注释，很多开发者存在一些认识上的误区，也是造成大家不愿意写注释的原因。比如“好代码是自注释的”、“没有时间”、“现有的注释都没有用，为什么还要浪费时间”等等。这些观点是站不住脚的。“好代码是自注释的”只在某些场景下是合理的，比如为变量和方法选择合适的名称，可以不用单独注释。但是更多的情况，代码很难体现开发人员的设计思路。此外，如果用户只能通过读代码来理解模块的使用，说明代码里没有抽象。好的注释可以极大地提升系统的可维护性，获取长期的效率，不存在“没有时间”一说。注释也是一种可以习得的技能，一旦习得，就可以在后续的工作中应用，这就解决了“注释没有用”的问题。&lt;/p&gt;
&lt;h4 id=&quot;72-使用注释提升系统可维护性&quot;&gt;&lt;a href=&quot;#72-%E4%BD%BF%E7%94%A8%E6%B3%A8%E9%87%8A%E6%8F%90%E5%8D%87%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7&quot; aria-label=&quot;72 使用注释提升系统可维护性 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;7.2 使用注释提升系统可维护性&lt;/h4&gt;
&lt;p&gt;注释应当能提供代码之外额外的信息，重视What和Why，而不是代码是如何实现的（How），最好不要简单地使用代码中出现过的单词。&lt;/p&gt;
&lt;p&gt;根据抽象程度，注释可以分为低层注释和高层注释，低层次的注释用来增加精确度，补充完善程序的信息，比如变量的单位、控制条件的边界、值是否允许为空、是否需要释放资源等。高层次注释抛弃细节，只从整体上帮助读者理解代码的功能和结构。这种类型的注释更好维护，如果代码修改不影响整体的功能，注释就无需更新。在实际工作中，需要兼顾细节和抽象。低层注释拆散与对应的实现代码放在一起，高层注释一般用于描述接口。&lt;/p&gt;
&lt;p&gt;注释先行，注释应该作为设计过程的一部分，写注释最好的时机是在开发的开始环节，这不仅会产生更好的文档，也会帮助产生好的设计，同时减少写文档带来的痛苦。开发人员推迟写注释的理由通常是：代码还在修改中，提前写注释到时候还得再改一遍。这样的话就会衍生两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，推迟注释通常意味着根本就没有注释。一旦决定推迟，很容易引发连锁反应，等到代码稳定后，也不会有注释这回事。这时候再想添加注释，就得专门抽出时间，客观条件可能不会允许这么做。&lt;/li&gt;
&lt;li&gt;其次，就算我们足够自律抽出专门时间去写注释，注释的质量也不会很好。我们潜意识中觉得代码已经写完了，急于开展下一个项目，只是象征性地添加一些注释，无法准确复现当时的设计思路。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;避免重复的注释。如果有重复注释，开发人员很难找到所有的注释去更新。解决方法是，可以找到醒目的地方存放注释文档，然后在代码处注明去查阅对应文档的地址。如果程序已经在外部文档中注释过了，不要在程序内部再注释了，添加注释的引用就可以了。
注释属于代码，而不是提交记录。一种错误的做法是将功能注释放在提交记录里，而不是放在对应代码文件里。因为开发人员通常不会去代码提交记录里去查看程序的功能描述，很不方便。&lt;/p&gt;
&lt;h4 id=&quot;73-使用注释改善系统设计&quot;&gt;&lt;a href=&quot;#73-%E4%BD%BF%E7%94%A8%E6%B3%A8%E9%87%8A%E6%94%B9%E5%96%84%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1&quot; aria-label=&quot;73 使用注释改善系统设计 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;7.3 使用注释改善系统设计&lt;/h4&gt;
&lt;p&gt;良好的设计基础是提供好的抽象。在开始编码前编写注释，可以帮助我们提炼模块的核心要素：模块或对象中最重要的功能和属性。这个过程促进我们去思考，而不是简单地堆砌代码。另一方面，注释也能够帮助我们检查自己的模块设计是否合理，正如前文中提到，深模块提供简单的接口和强大的功能，如果接口注释冗长复杂，通常意味着接口也很复杂；注释简单，意味着接口也很简单。在设计的早期注意和解决这些问题，会为我们带来长期的收益。&lt;/p&gt;
&lt;h3 id=&quot;八、后记&quot;&gt;&lt;a href=&quot;#%E5%85%AB%E3%80%81%E5%90%8E%E8%AE%B0&quot; aria-label=&quot;八、后记 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;八、后记&lt;/h3&gt;
&lt;p&gt;John Ousterhout累计写过25万行代码，是3个操作系统的重要贡献者，这些原则可以视为作者编程经验的总结。有经验的工程师看到这些观点会有共鸣，一些著作如《代码大全》、《领域驱动设计》也会有类似的观点。所以本文中提到的原则和方法具有一定实操和指导价值。对于很难有定论的问题，也可以在实践中去探索。&lt;/p&gt;
&lt;p&gt;关于原则和方法论，既不必刻意拔高，也不要嗤之以鼻。指导实践的不是更多的实践，而是实践后的总结和思考。应用原则和方法论实质是借鉴已有的经验，可以减少我们自行摸索的时间。探索新的方法可以帮助我们适应新的场景，但是新方法本身需要经过时间检验。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[JavaScript 执行机制]]></title><description><![CDATA[1.关于javascript javascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的"多线程"都是用单线程模拟出来的，一切javascript多线程都是纸老虎！…]]></description><link>https://lizhi1026.cc/2017/11-20/javascript-run-loop-ics</link><guid isPermaLink="false">https://lizhi1026.cc/2017/11-20/javascript-run-loop-ics</guid><pubDate>Mon, 20 Nov 2017 00:00:00 GMT</pubDate><content:encoded>&lt;h3 id=&quot;1关于javascript&quot;&gt;&lt;a href=&quot;#1%E5%85%B3%E4%BA%8Ejavascript&quot; aria-label=&quot;1关于javascript permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1.关于javascript&lt;/h3&gt;
&lt;p&gt;javascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的&quot;多线程&quot;都是用单线程模拟出来的，一切javascript多线程都是纸老虎！&lt;/p&gt;
&lt;h3 id=&quot;2javascript事件循环&quot;&gt;&lt;a href=&quot;#2javascript%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF&quot; aria-label=&quot;2javascript事件循环 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2.javascript事件循环&lt;/h3&gt;
&lt;p&gt;既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步任务&lt;/li&gt;
&lt;li&gt;异步任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明：&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1200px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 83.65384615384615%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsSAAALEgHS3X78AAACOUlEQVQ4y3VT23LTQAzt/w88wC/AF8BMH2hTpgO02CVJaS5OmjQOduw4tmPvxXvxbRfFGYITwo4e1tI5Wh1JvqhbRyudyayP+n36aESmGZtd1O1lfZesdK2rugJMVVUH/MUJmQhiINPMHm7Xt2B36b3BTBsvz5Ph3ra6VmVZK60zzhFjWuuyqlWlDoCyrA73o5fh5HkuuSCOG1x3/A8f07ElMAZnURR7wJmywaWUYoxtkwQnyfLy0nvzNnj12n73fjOfMyHCzQZSAOZ/ZE0IwYRAqVC2pBmPorq5w6GECi5A1PmGASKXkmV0R653ucDV+CvwME5BkG48Rw0DcLAlwxXtzjbfx6uRx/yIqCbMMuGOkDskg7tf817oDmjkYcDvnwcyJFZeiHo2MqdA9ns2cTcIXgeFGRWLx8TuI8vwZz+iRRcFTvqXvC9A7YZcF7kUnENMtWpTWpV1EW8jTNFOUCt2pFlKQWnTsPbmALkq/LWXouQ48kdzmNAnOzZGy/unxWCZBDForhrN3BmnzghZpvvyGDpDHPknmlXtx7g7j42xZ1he30brLd3PSPDcHWFnQAbfnOlDsPyJw1WLDF0BmGqmWRaFYAykF0JKLjnjsDYiZ7LgKU5gyU7L5lLgDBNOqcgiFM8WM8d3EpKGSYQIFkJyLjiDZPmZ3X7Bi5v085V/fR10PvlXnU3nJtp9fmFf53gOi7KbmNLNFv6z22EWWmhiJZNJY8/oeZJOra01JdOABqrSrR/ulPwbswbF/Hmh1bMAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;EventQueue&quot;
        title=&quot;EventQueue&quot;
        src=&quot;/static/e761e7e868e9268921dadd66a3f4091d/6ff5e/EventQueue.png&quot;
        srcset=&quot;/static/e761e7e868e9268921dadd66a3f4091d/135ae/EventQueue.png 300w,
/static/e761e7e868e9268921dadd66a3f4091d/34e8a/EventQueue.png 600w,
/static/e761e7e868e9268921dadd66a3f4091d/6ff5e/EventQueue.png 1200w,
/static/e761e7e868e9268921dadd66a3f4091d/005f0/EventQueue.png 1456w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;导图要表达的内容用文字来表述的话：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步和异步任务分别进入不同的执行&quot;场所&quot;，同步的进入主线程，异步的进入Event Table并注册函数&lt;/li&gt;
&lt;li&gt;当指定的事情完成时，Event Table会将这个函数移入Event Queue&lt;/li&gt;
&lt;li&gt;主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行&lt;/li&gt;
&lt;li&gt;上述过程会不断重复，也就是常说的Event Loop(事件循环)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数&lt;/p&gt;
&lt;p&gt;说了这么多文字，不如直接一段代码更直白:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; data &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
$&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;ajax&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    url&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;www&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;javascript&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;com&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    data&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token function-variable function&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;发送成功!&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;代码执行结束&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面是一段简易的&lt;code class=&quot;language-text&quot;&gt;ajax&lt;/code&gt;请求代码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ajax进入Event Table，注册回调函数&lt;code class=&quot;language-text&quot;&gt;success&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行&lt;code class=&quot;language-text&quot;&gt;console.log(&amp;#39;代码执行结束&amp;#39;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ajax事件完成，回调函数&lt;code class=&quot;language-text&quot;&gt;success&lt;/code&gt;进入Event Queue&lt;/li&gt;
&lt;li&gt;主线程从Event Queue读取回调函数&lt;code class=&quot;language-text&quot;&gt;success&lt;/code&gt;并执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：setTimeout.&lt;/p&gt;
&lt;h3 id=&quot;3又爱又恨的settimeout&quot;&gt;&lt;a href=&quot;#3%E5%8F%88%E7%88%B1%E5%8F%88%E6%81%A8%E7%9A%84settimeout&quot; aria-label=&quot;3又爱又恨的settimeout permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3.又爱又恨的setTimeout&lt;/h3&gt;
&lt;p&gt;大名鼎鼎的&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;延时3秒&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;渐渐的&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？&lt;/p&gt;
&lt;p&gt;先看一个例子：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;执行console&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据前面我们的结论，&lt;code class=&quot;language-text&quot;&gt;setTimeou&lt;/code&gt;t是异步的，应该先执行&lt;code class=&quot;language-text&quot;&gt;console.log&lt;/code&gt;这个同步任务，所以我们的结论是：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;//执行console
//task()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;去验证一下，结果正确！
然后我们修改一下前面的代码：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;10000000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？&lt;/p&gt;
&lt;p&gt;这时候我们需要重新理解&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;的定义。我们先说上述代码是怎么执行的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;task()&lt;/code&gt;进入Event Table并注册,计时开始&lt;/li&gt;
&lt;li&gt;执行&lt;code class=&quot;language-text&quot;&gt;sleep&lt;/code&gt;函数，很慢，非常慢，计时仍在继续&lt;/li&gt;
&lt;li&gt;3秒到了，计时事件&lt;code class=&quot;language-text&quot;&gt;timeout&lt;/code&gt;完成，&lt;code class=&quot;language-text&quot;&gt;task()&lt;/code&gt;进入Event Queue，但是&lt;code class=&quot;language-text&quot;&gt;sleep&lt;/code&gt;也太慢了吧，还没执行完，只好等着&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;sleep&lt;/code&gt;终于执行完了，&lt;code class=&quot;language-text&quot;&gt;task()&lt;/code&gt;终于从Event Queue进入了主线程执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述的流程走完，我们知道&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;这个函数，是经过指定时间后，把要执行的任务(本例中为&lt;code class=&quot;language-text&quot;&gt;task()&lt;/code&gt;)加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。&lt;/p&gt;
&lt;p&gt;我们还经常遇到&lt;code class=&quot;language-text&quot;&gt;setTimeout(fn,0)&lt;/code&gt;这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？&lt;/p&gt;
&lt;p&gt;答案是不会的，&lt;code class=&quot;language-text&quot;&gt;setTimeout(fn,0)&lt;/code&gt;的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;//代码1&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;先执行这里&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;执行啦&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;//代码2
console.log(&amp;#39;先执行这里&amp;#39;);
setTimeout(() =&amp;gt; {
    console.log(&amp;#39;执行啦&amp;#39;)
},3000);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码1的输出结果是：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;//先执行这里
//执行啦&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码2的输出结果是：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;//先执行这里
// ... 3s later
// 执行啦&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。&lt;/p&gt;
&lt;h3 id=&quot;4又恨又爱的setinterval&quot;&gt;&lt;a href=&quot;#4%E5%8F%88%E6%81%A8%E5%8F%88%E7%88%B1%E7%9A%84setinterval&quot; aria-label=&quot;4又恨又爱的setinterval permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4.又恨又爱的setInterval&lt;/h3&gt;
&lt;p&gt;上面说完了&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;，当然不能错过它的孪生兄弟&lt;code class=&quot;language-text&quot;&gt;setInterval&lt;/code&gt;。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，&lt;code class=&quot;language-text&quot;&gt;setInterval&lt;/code&gt;会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。&lt;/p&gt;
&lt;p&gt;唯一需要注意的一点是，对于&lt;code class=&quot;language-text&quot;&gt;setInterval(fn,ms)&lt;/code&gt;来说，我们已经知道不是每过&lt;code class=&quot;language-text&quot;&gt;ms&lt;/code&gt;秒会执行一次&lt;code class=&quot;language-text&quot;&gt;fn&lt;/code&gt;，&lt;strong&gt;而是每过&lt;code class=&quot;language-text&quot;&gt;ms&lt;/code&gt;秒，会有&lt;code class=&quot;language-text&quot;&gt;fn&lt;/code&gt;进入Event Queue。一旦&lt;code class=&quot;language-text&quot;&gt;setInterval&lt;/code&gt; 的回调函数fn执行时间超过了延迟时间&lt;code class=&quot;language-text&quot;&gt;ms&lt;/code&gt;&lt;/strong&gt;，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。&lt;/p&gt;
&lt;h3 id=&quot;5promise与processnexttickcallback&quot;&gt;&lt;a href=&quot;#5promise%E4%B8%8Eprocessnexttickcallback&quot; aria-label=&quot;5promise与processnexttickcallback permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5.Promise与process.nextTick(callback)&lt;/h3&gt;
&lt;p&gt;传统的定时器我们已经研究过了，接着我们探究&lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt;与&lt;code class=&quot;language-text&quot;&gt;process.nextTick(callback)&lt;/code&gt;的表现。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt;的定义和功能本文不再赘述，不了解的读者可以学习一下阮一峰老师的&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/promise&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Promise&lt;/a&gt;。而&lt;code class=&quot;language-text&quot;&gt;process.nextTick(callback)&lt;/code&gt;类似node.js版的&quot;setTimeout&quot;，在事件循环的下一次循环中调用 callback 回调函数。&lt;/p&gt;
&lt;p&gt;我们进入正题，除了广义的同步任务和异步任务，我们对任务有更精细的定义:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;macro-task(宏任务)：包括整体代码script，setTimeout，setInterval&lt;/li&gt;
&lt;li&gt;micro-task(微任务)：Promise，process.nextTick&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同类型的任务会进入对应的Event Queue，比如&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;和&lt;code class=&quot;language-text&quot;&gt;setInterval&lt;/code&gt;会进入相同的Event Queue。&lt;/p&gt;
&lt;p&gt;事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用文章最开始的一段代码说明：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;setTimeout&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;promise&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;then&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;console&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;这段代码作为宏任务，进入主线程。&lt;/li&gt;
&lt;li&gt;先遇到&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述)&lt;/li&gt;
&lt;li&gt;接下来遇到了&lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt;，&lt;code class=&quot;language-text&quot;&gt;new Promise&lt;/code&gt;立即执行，&lt;code class=&quot;language-text&quot;&gt;then&lt;/code&gt;函数分发到微任务Event Queue。遇到&lt;code class=&quot;language-text&quot;&gt;console.log()&lt;/code&gt;，立即执行。&lt;/li&gt;
&lt;li&gt;好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了&lt;code class=&quot;language-text&quot;&gt;then&lt;/code&gt;在微任务Event Queue里面，执行。&lt;/li&gt;
&lt;li&gt;ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;对应的回调函数，立即执行。&lt;/li&gt;
&lt;li&gt;结束.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事件循环，宏任务，微任务的关系如图所示：
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1200px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 83.78746594005449%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsSAAALEgHS3X78AAABuUlEQVQ4y41TaU+DQBD1//8jTaz6RY1XYoxoa6rSFkqhsMzucuwB9cFG1NpGJ03zdnfeHG+Gg7Zt67o2xjS/zTRaNUZ30Frr7gYAOwBZCKG1Ht50b1VZL9nbgj8u8uecZ0Ybd/89+A8yMOecKC8KuY7T8epyIkfj/NRfTKUo4EZEZVnCzeXfJgPjAQAnUbEgma55qLXa9AY3KSXA7szAXf9tY40VJZtFk4TCWlWICGmKomCMKaWcRjvIwABaWZ/uPXb0zE5IpsbYNE3BDMMwyzLw4bOXbLRd0ft7dj9nniiobVpXNpJvl42SfpTdG5yi5aqqlfPGPxJC0S/BcJXnue/7OAMjMMgAUHZ+exsej2ZnZ9Hrq8SDlFAbgm2r7TLjAS252HCNPC85v1heXa+DoP60vUtSVVUcx8gxlE3ooq/INdWPcM+SDGX3o2pas0kTpkrTGHDs7/XdrXaXU2YBf5qEN7PsIaI3jP1fZCdYJsIXeTIWoyc69OkOk2vav8hQHtsLPqN0kU782Iv4NOHBd52+yF2FRBigI0NwqC06w2RKnkurIcDG7usZIg+LgaP7BnrQ/Xqp7M7MH24k1/S6qr7pAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;process&quot;
        title=&quot;process&quot;
        src=&quot;/static/c8221a1ed40d5f993b71c0e25412ff97/6ff5e/process.png&quot;
        srcset=&quot;/static/c8221a1ed40d5f993b71c0e25412ff97/135ae/process.png 300w,
/static/c8221a1ed40d5f993b71c0e25412ff97/34e8a/process.png 600w,
/static/c8221a1ed40d5f993b71c0e25412ff97/6ff5e/process.png 1200w,
/static/c8221a1ed40d5f993b71c0e25412ff97/f3171/process.png 1468w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;1&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;2&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    process&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;nextTick&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;3&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;4&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token function&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;5&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
process&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;nextTick&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;6&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;7&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;8&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;9&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    process&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;nextTick&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;10&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;11&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token function&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;12&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一轮事件循环流程分析如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整体script作为第一个宏任务进入主线程，遇到&lt;code class=&quot;language-text&quot;&gt;console.log&lt;/code&gt;，输出1。&lt;/li&gt;
&lt;li&gt;遇到&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;，其回调函数被分发到宏任务Event Queue中。我们暂且记为&lt;code class=&quot;language-text&quot;&gt;setTimeout1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;遇到&lt;code class=&quot;language-text&quot;&gt;process.nextTick()&lt;/code&gt;，其回调函数被分发到微任务Event Queue中。我们记为&lt;code class=&quot;language-text&quot;&gt;process1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;遇到&lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt;，&lt;code class=&quot;language-text&quot;&gt;new Promise&lt;/code&gt;直接执行，输出7。&lt;code class=&quot;language-text&quot;&gt;then&lt;/code&gt;被分发到微任务Event Queue中。我们记为&lt;code class=&quot;language-text&quot;&gt;then1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;又遇到了&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;，其回调函数被分发到宏任务Event Queue中，我们记为&lt;code class=&quot;language-text&quot;&gt;setTimeout2&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;宏任务Event Queue&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;微任务Event Queue&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;setTimeout1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;process1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;setTimeout2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;then1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7&lt;/li&gt;
&lt;li&gt;我们发现了&lt;code class=&quot;language-text&quot;&gt;process1&lt;/code&gt;和&lt;code class=&quot;language-text&quot;&gt;then1&lt;/code&gt;两个微任务&lt;/li&gt;
&lt;li&gt;执行&lt;code class=&quot;language-text&quot;&gt;process1&lt;/code&gt;,输出6。&lt;/li&gt;
&lt;li&gt;执行&lt;code class=&quot;language-text&quot;&gt;then1&lt;/code&gt;，输出8。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从&lt;code class=&quot;language-text&quot;&gt;setTimeout1&lt;/code&gt;宏任务开始：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先输出2。接下来遇到了&lt;code class=&quot;language-text&quot;&gt;process.nextTick()&lt;/code&gt;，同样将其分发到微任务Event Queue中，记为&lt;code class=&quot;language-text&quot;&gt;process2&lt;/code&gt;。&lt;code class=&quot;language-text&quot;&gt;new Promise&lt;/code&gt;立即执行输出4，&lt;code class=&quot;language-text&quot;&gt;then&lt;/code&gt;也分发到微任务Event Queue中，记为&lt;code class=&quot;language-text&quot;&gt;then2&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;宏任务Event Queue&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;微任务Event Queue&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;setTimeout2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;process2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;then2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。&lt;/li&gt;
&lt;li&gt;输出3。&lt;/li&gt;
&lt;li&gt;输出5。&lt;/li&gt;
&lt;li&gt;第二轮事件循环结束，第二轮输出2，4，3，5。&lt;/li&gt;
&lt;li&gt;第三轮事件循环开始，此时只剩setTimeout2了，执行。&lt;/li&gt;
&lt;li&gt;直接输出9。&lt;/li&gt;
&lt;li&gt;将process.nextTick()分发到微任务Event Queue中。记为process3。&lt;/li&gt;
&lt;li&gt;直接执行new Promise，输出11。&lt;/li&gt;
&lt;li&gt;将then分发到微任务Event Queue中，记为then3。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;宏任务Event Queue&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;微任务Event Queue&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;process3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;then3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。&lt;/li&gt;
&lt;li&gt;输出10。&lt;/li&gt;
&lt;li&gt;输出12。&lt;/li&gt;
&lt;li&gt;第三轮事件循环结束，第三轮输出9，11，10，12。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。
(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)&lt;/p&gt;
&lt;h3 id=&quot;6写在最后&quot;&gt;&lt;a href=&quot;#6%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E&quot; aria-label=&quot;6写在最后 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6.写在最后&lt;/h3&gt;
&lt;h4 id=&quot;1js的异步&quot;&gt;&lt;a href=&quot;#1js%E7%9A%84%E5%BC%82%E6%AD%A5&quot; aria-label=&quot;1js的异步 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;(1)js的异步&lt;/h4&gt;
&lt;p&gt;我们从最开头就说javascript是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。&lt;/p&gt;
&lt;h4 id=&quot;2事件循环event-loop&quot;&gt;&lt;a href=&quot;#2%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFevent-loop&quot; aria-label=&quot;2事件循环event loop permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;(2)事件循环Event Loop&lt;/h4&gt;
&lt;p&gt;事件循环是js实现异步的一种方法，也是js的执行机制。&lt;/p&gt;
&lt;h4 id=&quot;3javascript的执行和运行&quot;&gt;&lt;a href=&quot;#3javascript%E7%9A%84%E6%89%A7%E8%A1%8C%E5%92%8C%E8%BF%90%E8%A1%8C&quot; aria-label=&quot;3javascript的执行和运行 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;(3)javascript的执行和运行&lt;/h4&gt;
&lt;p&gt;执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。&lt;/p&gt;
&lt;h4 id=&quot;4setimmediate&quot;&gt;&lt;a href=&quot;#4setimmediate&quot; aria-label=&quot;4setimmediate permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;(4)setImmediate&lt;/h4&gt;
&lt;p&gt;微任务和宏任务还有很多种类，比如&lt;code class=&quot;language-text&quot;&gt;setImmediate&lt;/code&gt;等等，执行都是有共同点的，有兴趣的同学可以自行了解。&lt;/p&gt;
&lt;h4 id=&quot;5最后的最后&quot;&gt;&lt;a href=&quot;#5%E6%9C%80%E5%90%8E%E7%9A%84%E6%9C%80%E5%90%8E&quot; aria-label=&quot;5最后的最后 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;(5)最后的最后&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;javascript是一门单线程语言&lt;/li&gt;
&lt;li&gt;Event Loop是javascript的执行机制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;牢牢把握两个基本点，以认真学习javascript为中心，早日实现成为前端高手的伟大梦想！&lt;/p&gt;</content:encoded></item><item><title><![CDATA[iOS编译器]]></title><description><![CDATA[编译器做些什么？ 本文主要探讨一下编译器主要做些什么，以及如何有效的利用编译器。 简单的说，编译器有两个职责：把 Objective-C 代码转化成低级代码，以及对代码做分析，确保代码中没有任何明显的错误。 现在，Xcode 的默认编译器是 clang…]]></description><link>https://lizhi1026.cc/2016/06-04/ios-complie-ics</link><guid isPermaLink="false">https://lizhi1026.cc/2016/06-04/ios-complie-ics</guid><pubDate>Sat, 04 Jun 2016 00:00:00 GMT</pubDate><content:encoded>&lt;h2 id=&quot;编译器做些什么？&quot;&gt;&lt;a href=&quot;#%E7%BC%96%E8%AF%91%E5%99%A8%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F&quot; aria-label=&quot;编译器做些什么？ permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;编译器做些什么？&lt;/h2&gt;
&lt;p&gt;本文主要探讨一下编译器主要做些什么，以及如何有效的利用编译器。&lt;/p&gt;
&lt;p&gt;简单的说，编译器有两个职责：把 Objective-C 代码转化成低级代码，以及对代码做分析，确保代码中没有任何明显的错误。&lt;/p&gt;
&lt;p&gt;现在，Xcode 的默认编译器是 clang。本文中我们提到的编译器都表示 clang。clang 的功能是首先对 Objective-C 代码做分析检查，然后将其转换为低级的类汇编代码：LLVM Intermediate Representation(LLVM 中间表达码)。接着 LLVM 会执行相关指令将 LLVM IR 编译成目标平台上的本地字节码，这个过程的完成方式可以是即时编译 (Just-in-time)，或在编译的时候完成。&lt;/p&gt;
&lt;p&gt;LLVM 指令的一个好处就是可以在支持 LLVM 的任意平台上生成和运行 LLVM 指令。例如，你写的一个 iOS app, 它可以自动的运行在两个完全不同的架构(Inter 和 ARM)上，LLVM 会根据不同的平台将 IR 码转换为对应的本地字节码。&lt;/p&gt;
&lt;p&gt;LLVM 的优点主要得益于它的三层式架构 -- 第一层支持多种语言作为输入(例如 C, ObjectiveC, C++ 和 Haskell)，第二层是一个共享式的优化器(对 LLVM IR 做优化处理)，第三层是许多不同的目标平台(例如 Intel, ARM 和 PowerPC)。在这三层式的架构中，如果你想要添加一门语言到 LLVM 中，那么可以把重要精力集中到第一层上，如果想要增加另外一个目标平台，那么你没必要过多的考虑输入语言。在书 &lt;em&gt;The Architecture of Open Source Applications&lt;/em&gt; 中 LLVM 的创建者 (Chris Lattner) 写了一章很棒的内容：关于 &lt;a href=&quot;http://www.aosabook.org/en/llvm.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;LLVM 架构&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在编译一个源文件时，编译器的处理过程分为几个阶段。要想查看编译 &lt;em&gt;hello.m&lt;/em&gt; 源文件需要几个不同的阶段，我们可以让通过 clang 命令观察：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% clang -ccc-print-phases hello.m

0: input, &amp;quot;hello.m&amp;quot;, objective-c
1: preprocessor, {0}, objective-c-cpp-output
2: compiler, {1}, assembler
3: assembler, {2}, object
4: linker, {3}, image
5: bind-arch, &amp;quot;x86_64&amp;quot;, {4}, image&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本文我们将重点关注第一阶段和第二阶段。在文章 &lt;a href=&quot;http://objccn.io/issue-6-3/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Mach-O Executables&lt;/a&gt; 中，Daniel 会对第三阶段和第四阶段进行阐述。&lt;/p&gt;
&lt;h3 id=&quot;预处理&quot;&gt;&lt;a href=&quot;#%E9%A2%84%E5%A4%84%E7%90%86&quot; aria-label=&quot;预处理 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;预处理&lt;/h3&gt;
&lt;p&gt;每当编源译文件的时候，编译器首先做的是一些预处理工作。比如预处理器会处理源文件中的宏定义，将代码中的宏用其对应定义的具体内容进行替换。&lt;/p&gt;
&lt;p&gt;例如，如果在源文件中出现下述代码：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;预处理器对这行代码的处理是用 Foundation.h 文件中的内容去替换这行代码，如果 Foundation.h 中也使用了类似的宏引入，则会按照同样的处理方式用各个宏对应的真正代码进行逐级替代。&lt;/p&gt;
&lt;p&gt;这也就是为什么人们主张头文件最好尽量少的去引入其他的类或库，因为引入的东西越多，编译器需要做的处理就越多。例如，在头文件中用：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;@class MyClass;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代替：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#import &amp;quot;MyClass.h&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这么写是告诉编译器 MyClass 是一个类，并且在 .m 实现文件中可以通过 import &lt;code class=&quot;language-text&quot;&gt;MyClass.h&lt;/code&gt; 的方式来使用它。&lt;/p&gt;
&lt;p&gt;假设我们写了一个简单的 C 程序 &lt;code class=&quot;language-text&quot;&gt;hello.c&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
  printf(&amp;quot;hello world\n&amp;quot;);
  return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后给上面的代码执行以下预处理命令，看看是什么效果：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;clang -E hello.c | less&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来看看处理后的代码，一共是 401 行。如果将如下一行代码添加到上面代码的顶部：：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再执行一下上面的预处理命令，处理后的文件代码行数暴增至 89,839 行。这个数字比某些操作系统的总代码行数还要多。&lt;/p&gt;
&lt;p&gt;幸好，目前的情况已经改善许多了：引入了&lt;a href=&quot;http://clang.llvm.org/docs/Modules.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;模块 - modules&lt;/a&gt;功能，这使预处理变得更加的高级。&lt;/p&gt;
&lt;h4 id=&quot;自定义宏&quot;&gt;&lt;a href=&quot;#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%8F&quot; aria-label=&quot;自定义宏 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;自定义宏&lt;/h4&gt;
&lt;p&gt;我们来看看另外一种情形定义或者使用自定义宏，比如定义了如下宏：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#define MY_CONSTANT 4&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么，凡是在此行宏定义作用域内，输入了 &lt;code class=&quot;language-text&quot;&gt;MY_CONSTANT&lt;/code&gt;，在预处理过程中 &lt;code class=&quot;language-text&quot;&gt;MY_CONSTANT&lt;/code&gt; 都会被替换成 &lt;code class=&quot;language-text&quot;&gt;4&lt;/code&gt;。我们定义的宏也是可以携带参数的， 比如：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#define MY_MACRO(x) x&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;鉴于本文的内容所限，就不对强大的预处理做更多、更全面的展开讨论了。但是还是要强调一点，建议大家不要在需要预处理的代码中加入内联代码逻辑。&lt;/p&gt;
&lt;p&gt;例如，下面这段代码，这样用没什么问题：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#define MAX(a,b) a &amp;gt; b ? a : b

int main() {
  printf(&amp;quot;largest: %d\n&amp;quot;, MAX(10,100));
  return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是如果换成这么写：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#define MAX(a,b) a &amp;gt; b ? a : b

int main() {
  int i = 200;
  printf(&amp;quot;largest: %d\n&amp;quot;, MAX(i++,100));
  printf(&amp;quot;i: %d\n&amp;quot;, i);
  return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用 &lt;code class=&quot;language-text&quot;&gt;clang max.c&lt;/code&gt; 编译一下，结果是：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;largest: 201
i: 202&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用 &lt;code class=&quot;language-text&quot;&gt;clang -E max.c&lt;/code&gt; 进行宏展开的预处理结果是如下所示：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;int main() {
  int i = 200;
  printf(&amp;quot;largest: %d\n&amp;quot;, i++ &amp;gt; 100 ? i++ : 100);
  printf(&amp;quot;i: %d\n&amp;quot;, i);
  return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本例是典型的宏使用不当，而且通常这类问题非常隐蔽且难以 debug 。针对本例这类情况，最好使用 &lt;code class=&quot;language-text&quot;&gt;static inline&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
static const int MyConstant = 200;

static inline int max(int l, int r) {
   return l &amp;gt; r ? l : r;
}

int main() {
  int i = MyConstant;
  printf(&amp;quot;largest: %d\n&amp;quot;, max(i++,100));
  printf(&amp;quot;i: %d\n&amp;quot;, i);
  return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样改过之后，就可以输出正常的结果 (&lt;code class=&quot;language-text&quot;&gt;i:201&lt;/code&gt;)。因为这里定义的代码是内联的 (inlined)，所以它的效率和宏变量差不多，但是可靠性比宏定义要好许多。再者，还可以设置断点、类型检查以及避免异常行为。&lt;/p&gt;
&lt;p&gt;基本上，宏的最佳使用场景是日志输出，可以使用 &lt;code class=&quot;language-text&quot;&gt;__FILE__&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;__LINE__&lt;/code&gt; 和 assert 宏。&lt;/p&gt;
&lt;h3 id=&quot;词法解析标记&quot;&gt;&lt;a href=&quot;#%E8%AF%8D%E6%B3%95%E8%A7%A3%E6%9E%90%E6%A0%87%E8%AE%B0&quot; aria-label=&quot;词法解析标记 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;词法解析标记&lt;/h3&gt;
&lt;p&gt;预处理完成以后，每一个 &lt;code class=&quot;language-text&quot;&gt;.m&lt;/code&gt; 源文件里都有一堆的声明和定义。这些代码文本都会从 string 转化成特殊的标记流。&lt;/p&gt;
&lt;p&gt;例如，下面是一段简单的 Objective-C hello word 程序：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;int main() {
  NSLog(@&amp;quot;hello, %@&amp;quot;, @&amp;quot;world&amp;quot;);
  return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;利用 clang 命令 &lt;code class=&quot;language-text&quot;&gt;clang -Xclang -dump-tokens hello.m&lt;/code&gt; 来将上面代码的标记流导出：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;int &amp;#39;int&amp;#39;        [StartOfLine]  Loc=&amp;lt;hello.m:4:1&amp;gt;
identifier &amp;#39;main&amp;#39;        [LeadingSpace] Loc=&amp;lt;hello.m:4:5&amp;gt;
l_paren &amp;#39;(&amp;#39;             Loc=&amp;lt;hello.m:4:9&amp;gt;
r_paren &amp;#39;)&amp;#39;             Loc=&amp;lt;hello.m:4:10&amp;gt;
l_brace &amp;#39;{&amp;#39;      [LeadingSpace] Loc=&amp;lt;hello.m:4:12&amp;gt;
identifier &amp;#39;NSLog&amp;#39;       [StartOfLine] [LeadingSpace]   Loc=&amp;lt;hello.m:5:3&amp;gt;
l_paren &amp;#39;(&amp;#39;             Loc=&amp;lt;hello.m:5:8&amp;gt;
at &amp;#39;@&amp;#39;          Loc=&amp;lt;hello.m:5:9&amp;gt;
string_literal &amp;#39;&amp;quot;hello, %@&amp;quot;&amp;#39;            Loc=&amp;lt;hello.m:5:10&amp;gt;
comma &amp;#39;,&amp;#39;               Loc=&amp;lt;hello.m:5:21&amp;gt;
at &amp;#39;@&amp;#39;   [LeadingSpace] Loc=&amp;lt;hello.m:5:23&amp;gt;
string_literal &amp;#39;&amp;quot;world&amp;quot;&amp;#39;                Loc=&amp;lt;hello.m:5:24&amp;gt;
r_paren &amp;#39;)&amp;#39;             Loc=&amp;lt;hello.m:5:31&amp;gt;
semi &amp;#39;;&amp;#39;                Loc=&amp;lt;hello.m:5:32&amp;gt;
return &amp;#39;return&amp;#39;  [StartOfLine] [LeadingSpace]   Loc=&amp;lt;hello.m:6:3&amp;gt;
numeric_constant &amp;#39;0&amp;#39;     [LeadingSpace] Loc=&amp;lt;hello.m:6:10&amp;gt;
semi &amp;#39;;&amp;#39;                Loc=&amp;lt;hello.m:6:11&amp;gt;
r_brace &amp;#39;}&amp;#39;      [StartOfLine]  Loc=&amp;lt;hello.m:7:1&amp;gt;
eof &amp;#39;&amp;#39;          Loc=&amp;lt;hello.m:7:2&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;仔细观察可以发现，每一个标记都包含了对应的源码内容和其在源码中的位置。注意这里的位置是宏展开之前的位置，这样一来，如果编译过程中遇到什么问题，clang 能够在源码中指出出错的具体位置。&lt;/p&gt;
&lt;h3 id=&quot;解析&quot;&gt;&lt;a href=&quot;#%E8%A7%A3%E6%9E%90&quot; aria-label=&quot;解析 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;解析&lt;/h3&gt;
&lt;p&gt;接下来要说的东西比较有意思：之前生成的标记流将会被解析成一棵抽象语法树 (abstract syntax tree -- AST)。由于 Objective-C 是一门复杂的语言，因此解析的过程不简单。解析过后，源程序变成了一棵抽象语法树：一棵代表源程序的树。假设我们有一个程序 &lt;code class=&quot;language-text&quot;&gt;hello.m&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;

@interface World
- (void)hello;
@end

@implementation World
- (void)hello {
  NSLog(@&amp;quot;hello, world&amp;quot;);
}
@end

int main() {
   World* world = [World new];
   [world hello];
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们执行 clang 命令 &lt;code class=&quot;language-text&quot;&gt;clang -Xclang -ast-dump -fsyntax-only hello.m&lt;/code&gt; 之后，命令行中输出的结果如下所示：：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;@interface World- (void) hello;
@end
@implementation World
- (void) hello (CompoundStmt 0x10372ded0 &amp;lt;hello.m:8:15, line:10:1&amp;gt;
  (CallExpr 0x10372dea0 &amp;lt;line:9:3, col:24&amp;gt; &amp;#39;void&amp;#39;
    (ImplicitCastExpr 0x10372de88 &amp;lt;col:3&amp;gt; &amp;#39;void (*)(NSString *, ...)&amp;#39; &amp;lt;FunctionToPointerDecay&amp;gt;
      (DeclRefExpr 0x10372ddd8 &amp;lt;col:3&amp;gt; &amp;#39;void (NSString *, ...)&amp;#39; Function 0x1023510d0 &amp;#39;NSLog&amp;#39; &amp;#39;void (NSString *, ...)&amp;#39;))
    (ObjCStringLiteral 0x10372de38 &amp;lt;col:9, col:10&amp;gt; &amp;#39;NSString *&amp;#39;
      (StringLiteral 0x10372de00 &amp;lt;col:10&amp;gt; &amp;#39;char [13]&amp;#39; lvalue &amp;quot;hello, world&amp;quot;))))


@end
int main() (CompoundStmt 0x10372e118 &amp;lt;hello.m:13:12, line:16:1&amp;gt;
  (DeclStmt 0x10372e090 &amp;lt;line:14:4, col:30&amp;gt;
    0x10372dfe0 &amp;quot;World *world =
      (ImplicitCastExpr 0x10372e078 &amp;lt;col:19, col:29&amp;gt; &amp;#39;World *&amp;#39; &amp;lt;BitCast&amp;gt;
        (ObjCMessageExpr 0x10372e048 &amp;lt;col:19, col:29&amp;gt; &amp;#39;id&amp;#39;:&amp;#39;id&amp;#39; selector=new class=&amp;#39;World&amp;#39;))&amp;quot;)
  (ObjCMessageExpr 0x10372e0e8 &amp;lt;line:15:4, col:16&amp;gt; &amp;#39;void&amp;#39; selector=hello
    (ImplicitCastExpr 0x10372e0d0 &amp;lt;col:5&amp;gt; &amp;#39;World *&amp;#39; &amp;lt;LValueToRValue&amp;gt;
      (DeclRefExpr 0x10372e0a8 &amp;lt;col:5&amp;gt; &amp;#39;World *&amp;#39; lvalue Var 0x10372dfe0 &amp;#39;world&amp;#39; &amp;#39;World *&amp;#39;))))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在抽象语法树中的每个节点都标注了其对应源码中的位置，同样的，如果产生了什么问题，clang 可以定位到问题所在处的源码位置。&lt;/p&gt;
&lt;h5 id=&quot;延伸阅读&quot;&gt;&lt;a href=&quot;#%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB&quot; aria-label=&quot;延伸阅读 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;延伸阅读&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://clang.llvm.org/docs/IntroductionToTheClangAST.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;clang AST 介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;静态分析&quot;&gt;&lt;a href=&quot;#%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90&quot; aria-label=&quot;静态分析 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;静态分析&lt;/h3&gt;
&lt;p&gt;一旦编译器把源码生成了抽象语法树，编译器可以对这棵树做分析处理，以找出代码中的错误，比如类型检查：即检查程序中是否有类型错误。例如：如果代码中给某个对象发送了一个消息，编译器会检查这个对象是否实现了这个消息（函数、方法）。此外，clang 对整个程序还做了其它更高级的一些分析，以确保程序没有错误。&lt;/p&gt;
&lt;h4 id=&quot;类型检查&quot;&gt;&lt;a href=&quot;#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5&quot; aria-label=&quot;类型检查 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;类型检查&lt;/h4&gt;
&lt;p&gt;每当开发人员编写代码的时候，clang 都会帮忙检查错误。其中最常见的就是检查程序是否发送正确的消息给正确的对象，是否在正确的值上调用了正确的函数。如果你给一个单纯的 &lt;code class=&quot;language-text&quot;&gt;NSObject*&lt;/code&gt; 对象发送了一个 &lt;code class=&quot;language-text&quot;&gt;hello&lt;/code&gt; 消息，那么 clang 就会报错。同样，如果你创建了 &lt;code class=&quot;language-text&quot;&gt;NSObject&lt;/code&gt; 的一个子类 &lt;code class=&quot;language-text&quot;&gt;Test&lt;/code&gt;, 如下所示：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;@interface Test : NSObject
@end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后试图给这个子类中某个属性设置一个与其自身类型不相符的对象，编译器会给出一个可能使用不正确的警告。&lt;/p&gt;
&lt;p&gt;一般会把类型分为两类：动态的和静态的。动态的在运行时做检查，静态的在编译时做检查。以往，编写代码时可以向任意对象发送任何消息，在运行时，才会检查对象是否能够响应这些消息。由于只是在运行时做此类检查，所以叫做动态类型。&lt;/p&gt;
&lt;p&gt;至于静态类型，是在编译时做检查。当在代码中使用 ARC 时，编译器在编译期间，会做许多的类型检查：因为编译器需要知道哪个对象该如何使用。例如，如果 myObject 没有 hello 方法，那么就不能写如下这行代码了：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;[myObject hello]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;其他分析&quot;&gt;&lt;a href=&quot;#%E5%85%B6%E4%BB%96%E5%88%86%E6%9E%90&quot; aria-label=&quot;其他分析 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;其他分析&lt;/h4&gt;
&lt;p&gt;clang 在静态分析阶段，除了类型检查外，还会做许多其它一些分析。如果你把 clang 的代码仓库 clone 到本地，然后进入目录 &lt;code class=&quot;language-text&quot;&gt;lib/StaticAnalyzer/Checkers&lt;/code&gt;，你会看到所有静态检查内容。比如 &lt;code class=&quot;language-text&quot;&gt;ObjCUnusedIVarsChecker.cpp&lt;/code&gt; 是用来检查是否有定义了，但是从未使用过的变量。而 &lt;code class=&quot;language-text&quot;&gt;ObjCSelfInitChecker.cpp&lt;/code&gt; 则是检查在 你的初始化方法中中调用 &lt;code class=&quot;language-text&quot;&gt;self&lt;/code&gt; 之前，是否已经调用 &lt;code class=&quot;language-text&quot;&gt;[self initWith...]&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;[super init]&lt;/code&gt; 了。编译器还进行了一些其它的检查，例如在 &lt;code class=&quot;language-text&quot;&gt;lib/Sema/SemaExprObjC.cpp&lt;/code&gt; 的 2,534 行，有这样一句：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Diag(SelLoc, diag::warn_arc_perform_selector_leaks);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个会生成严重错误的警告 “performSelector may cause a leak because its selector is unknown” 。&lt;/p&gt;
&lt;h2 id=&quot;代码生成&quot;&gt;&lt;a href=&quot;#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90&quot; aria-label=&quot;代码生成 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;代码生成&lt;/h2&gt;
&lt;p&gt;clang 完成代码的标记，解析和分析后，接着就会生成 LLVM 代码。下面继续看看&lt;code class=&quot;language-text&quot;&gt;hello.c&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
  printf(&amp;quot;hello world\n&amp;quot;);
  return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要把这段代码编译成 LLVM 字节码（绝大多数情况下是二进制码格式），我们可以执行下面的命令：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;clang -O3 -emit-LLVM hello.c -c -o hello.bc&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着用另一个命令来查看刚刚生成的二进制文件：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;llvm-dis &amp;lt; hello.bc | less&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;; ModuleID = &amp;#39;&amp;lt;stdin&amp;gt;&amp;#39;
target datalayout = &amp;quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128&amp;quot;
target triple = &amp;quot;x86_64-apple-macosx10.8.0&amp;quot;

@str = private unnamed_addr constant [12 x i8] c&amp;quot;hello world\00&amp;quot;

; Function Attrs: nounwind ssp uwtable
define i32 @main() #0 {
  %puts = tail call i32 @puts(i8* getelementptr inbounds ([12 x i8]* @str, i64 0, i64 0))
  ret i32 0
}

; Function Attrs: nounwind
declare i32 @puts(i8* nocapture) #1

attributes #0 = { nounwind ssp uwtable }
attributes #1 = { nounwind }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的代码中，可以看到 &lt;code class=&quot;language-text&quot;&gt;main&lt;/code&gt; 函数只有两行代码：一行输出string，另一行返回 &lt;code class=&quot;language-text&quot;&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;再换一个程序，拿 &lt;code class=&quot;language-text&quot;&gt;five.m&lt;/code&gt; 为例，对其做相同的编译，然后执行 &lt;code class=&quot;language-text&quot;&gt;LLVM-dis &amp;lt; five.bc | less&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#import &amp;lt;Foundation/Foundation.h&amp;gt;

int main() {
  NSLog(@&amp;quot;%@&amp;quot;, [@5 description]);
  return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;抛开其他的不说，单看 &lt;code class=&quot;language-text&quot;&gt;main&lt;/code&gt; 函数：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;define i32 @main() #0 {
  %1 = load %struct._class_t** @&amp;quot;\01L_OBJC_CLASSLIST_REFERENCES_$_&amp;quot;, align 8
  %2 = load i8** @&amp;quot;\01L_OBJC_SELECTOR_REFERENCES_&amp;quot;, align 8, !invariant.load !4
  %3 = bitcast %struct._class_t* %1 to i8*
  %4 = tail call %0* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to %0* (i8*, i8*, i32)*)(i8* %3, i8* %2, i32 5)
  %5 = load i8** @&amp;quot;\01L_OBJC_SELECTOR_REFERENCES_2&amp;quot;, align 8, !invariant.load !4
  %6 = bitcast %0* %4 to i8*
  %7 = tail call %1* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to %1* (i8*, i8*)*)(i8* %6, i8* %5)
  tail call void (%1*, ...)* @NSLog(%1* bitcast (%struct.NSConstantString* @_unnamed_cfstring_ to %1*), %1* %7)
  ret i32 0
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码中最重要的是第 4 行，它创建了一个 &lt;code class=&quot;language-text&quot;&gt;NSNumber&lt;/code&gt; 对象。第 7 行，给这个 number 对象发送了一个  &lt;code class=&quot;language-text&quot;&gt;description&lt;/code&gt; 消息。第 8 行，将 &lt;code class=&quot;language-text&quot;&gt;description&lt;/code&gt; 消息返回的内容打印出来。&lt;/p&gt;
&lt;h3 id=&quot;优化&quot;&gt;&lt;a href=&quot;#%E4%BC%98%E5%8C%96&quot; aria-label=&quot;优化 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;优化&lt;/h3&gt;
&lt;p&gt;要想了解 LLVM 的优化内容，以及 clang 能做哪些优化，我们先看一个略微复杂的 C 程序：这个函数主要是递归计算 &lt;code class=&quot;language-text&quot;&gt;阶乘&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int factorial(int x) {
   if (x &amp;gt; 1) return x * factorial(x-1);
   else return 1;
}

int main() {
  printf(&amp;quot;factorial 10: %d\n&amp;quot;, factorial(10));
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先看看不做优化的编译情况，执行下面命令：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;clang -O0 -emit-llvm factorial.c  -c -o factorial.bc &amp;amp;&amp;amp; llvm-dis &amp;lt; factorial.bc&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重点看一下针对 &lt;code class=&quot;language-text&quot;&gt;阶乘&lt;/code&gt; 部分生成的代码：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;define i32 @factorial(i32 %x) #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  store i32 %x, i32* %2, align 4
  %3 = load i32* %2, align 4
  %4 = icmp sgt i32 %3, 1
  br i1 %4, label %5, label %11

; &amp;lt;label&amp;gt;:5                                       ; preds = %0
  %6 = load i32* %2, align 4
  %7 = load i32* %2, align 4
  %8 = sub nsw i32 %7, 1
  %9 = call i32 @factorial(i32 %8)
  %10 = mul nsw i32 %6, %9
  store i32 %10, i32* %1
  br label %12

; &amp;lt;label&amp;gt;:11                                      ; preds = %0
  store i32 1, i32* %1
  br label %12

; &amp;lt;label&amp;gt;:12                                      ; preds = %11, %5
  %13 = load i32* %1
  ret i32 %13
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看一下 &lt;code class=&quot;language-text&quot;&gt;%9&lt;/code&gt; 标注的那一行，这行代码正是递归调用阶乘函数本身，实际上这样调用是非常低效的，因为每次递归调用都要重新压栈。接下来可以看一下优化后的效果，可以通过这样的方式开启优化 -- 将 &lt;code class=&quot;language-text&quot;&gt;-03&lt;/code&gt; 标志传给 clang：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;clang -O3 -emit-llvm factorial.c  -c -o factorial.bc &amp;amp;&amp;amp; llvm-dis &amp;lt; factorial.bc&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在 &lt;code class=&quot;language-text&quot;&gt;阶乘&lt;/code&gt; 计算相关代码编译后生成的代码如下：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;define i32 @factorial(i32 %x) #0 {
  %1 = icmp sgt i32 %x, 1
  br i1 %1, label %tailrecurse, label %tailrecurse._crit_edge

tailrecurse:                                      ; preds = %tailrecurse, %0
  %x.tr2 = phi i32 [ %2, %tailrecurse ], [ %x, %0 ]
  %accumulator.tr1 = phi i32 [ %3, %tailrecurse ], [ 1, %0 ]
  %2 = add nsw i32 %x.tr2, -1
  %3 = mul nsw i32 %x.tr2, %accumulator.tr1
  %4 = icmp sgt i32 %2, 1
  br i1 %4, label %tailrecurse, label %tailrecurse._crit_edge

tailrecurse._crit_edge:                           ; preds = %tailrecurse, %0
  %accumulator.tr.lcssa = phi i32 [ 1, %0 ], [ %3, %tailrecurse ]
  ret i32 %accumulator.tr.lcssa
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即便我们的函数并没有按照&lt;a href=&quot;http://en.wikipedia.org/wiki/Tail_call&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;尾递归&lt;/a&gt;的方式编写，clang 仍然能对其做优化处理，让该函数编译的结果中只包含一个循环。当然 clang 能对代码进行的优化还有很多方面。可以看以下这个比较不错的 gcc 的优化例子&lt;a href=&quot;http://ridiculousfish.com/blog/posts/will-it-optimize.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;ridiculousfish.com&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.llvm.org/search/label/optimization&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;LLVM blog: posts tagged &apos;optimization&apos;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.llvm.org/2013/05/llvm-33-vectorization-improvements.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;LLVM blog: vectorization improvements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.llvm.org/2011/09/greedy-register-allocation-in-llvm-30.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;LLVM blog: greedy register allocation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://polly.llvm.org/index.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;The Polly project&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;如何在实际中应用这些特性&quot;&gt;&lt;a href=&quot;#%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AE%9E%E9%99%85%E4%B8%AD%E5%BA%94%E7%94%A8%E8%BF%99%E4%BA%9B%E7%89%B9%E6%80%A7&quot; aria-label=&quot;如何在实际中应用这些特性 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;如何在实际中应用这些特性&lt;/h2&gt;
&lt;p&gt;刚刚我们探讨了编译的全过程，从标记到解析，从抽象语法树到分析检查，再到汇编。读者不禁要问，为什么要关注这些？&lt;/p&gt;
&lt;h3 id=&quot;使用-libclan-g或-clang-插件&quot;&gt;&lt;a href=&quot;#%E4%BD%BF%E7%94%A8-libclan-g%E6%88%96-clang-%E6%8F%92%E4%BB%B6&quot; aria-label=&quot;使用 libclan g或 clang 插件 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;使用 libclan g或 clang 插件&lt;/h3&gt;
&lt;p&gt;之所以 clang 很酷：是因为它是一个开源的项目、并且它是一个非常好的工程：几乎可以说全身是宝。使用者可以创建自己的 clang 版本，针对自己的需求对其进行改造。比如说，可以改变 clang 生成代码的方式，增加更强的类型检查，或者按照自己的定义进行代码的检查分析等等。要想达成以上的目标，有很多种方法，其中最简单的就是使用一个名为 &lt;a href=&quot;http://clang.llvm.org/doxygen/group__CINDEX.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;libclang&lt;/a&gt; 的C类库。libclang 提供的 API 非常简单，可以对 C 和 clang 做桥接，并可以用它对所有的源码做分析处理。不过，根据我的经验，如果使用者的需求更高，那么 libclang 就不怎么行了。针对这种情况，推荐使用 &lt;a href=&quot;https://github.com/macmade/ClangKit&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Clangkit&lt;/a&gt;，它是基于 clang 提供的功能，用 Objective-C 进行封装的一个库。&lt;/p&gt;
&lt;p&gt;最后，clang 还提供了一个直接使用 LibTooling 的 C++ 类库。这里要做的事儿比较多，而且涉及到 C++，但是它能够发挥 clang 的强大功能。用它你可以对源码做任意类型的分析，甚至重写程序。如果你想要给 clang 添加一些自定义的分析、创建自己的重构器 (refactorer)、或者需要基于现有代码做出大量修改，甚至想要基于工程生成相关图形或者文档，那么 LibTooling 是很好的选择。&lt;/p&gt;
&lt;h3 id=&quot;自定义分析器&quot;&gt;&lt;a href=&quot;#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E6%9E%90%E5%99%A8&quot; aria-label=&quot;自定义分析器 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;自定义分析器&lt;/h3&gt;
&lt;p&gt;开发者可以按照 &lt;a href=&quot;http://clang.LLVM.org/docs/LibASTMatchersTutorial.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Tutorial for building tools using LibTooling&lt;/a&gt; 中的说明去构造 LLVM ，clang 以及 clan g的附加工具。需要注意的是，编译代码是需要花费一些时间的，即时机器已经很快了，但是在编译期间，我还是可以吃顿饭的。&lt;/p&gt;
&lt;p&gt;接下来，进入到 LLVM 目录，然后执行命令&lt;code class=&quot;language-text&quot;&gt;cd ~/llvm/tools/clang/tools/&lt;/code&gt;。在这个目录中，可以创建自己独立的 clang 工具。例如，我们创建一个小工具，用来检查某个库是否正确使用。首先将 &lt;a href=&quot;https://github.com/objcio/issue6-compiler-tool&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;样例工程&lt;/a&gt; 克隆到本地，然后输入 &lt;code class=&quot;language-text&quot;&gt;make&lt;/code&gt;。这样就会生成一个名为 &lt;code class=&quot;language-text&quot;&gt;example&lt;/code&gt; 的二进制文件。&lt;/p&gt;
&lt;p&gt;我们的使用场景是：假如有一个 &lt;code class=&quot;language-text&quot;&gt;Observer&lt;/code&gt; 类, 代码如下所示：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;@interface Observer
+ (instancetype)observerWithTarget:(id)target action:(SEL)selector;
@end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，我们想要检查一下每当这个类被调用的时候，在 &lt;code class=&quot;language-text&quot;&gt;target&lt;/code&gt; 对象中是否都有对应的 &lt;code class=&quot;language-text&quot;&gt;action&lt;/code&gt; 方法存在。可以写个 C++ 函数来做这件事（注意，这是我第一次写 C++ 程序，可能不那么严谨）：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;virtual bool VisitObjCMessageExpr(ObjCMessageExpr *E) {
  if (E-&amp;gt;getReceiverKind() == ObjCMessageExpr::Class) {
    QualType ReceiverType = E-&amp;gt;getClassReceiver();
    Selector Sel = E-&amp;gt;getSelector();
    string TypeName = ReceiverType.getAsString();
    string SelName = Sel.getAsString();
    if (TypeName == &amp;quot;Observer&amp;quot; &amp;amp;&amp;amp; SelName == &amp;quot;observerWithTarget:action:&amp;quot;) {
      Expr *Receiver = E-&amp;gt;getArg(0)-&amp;gt;IgnoreParenCasts();
      ObjCSelectorExpr* SelExpr = cast&amp;lt;ObjCSelectorExpr&amp;gt;(E-&amp;gt;getArg(1)-&amp;gt;IgnoreParenCasts());
      Selector Sel = SelExpr-&amp;gt;getSelector();
      if (const ObjCObjectPointerType *OT = Receiver-&amp;gt;getType()-&amp;gt;getAs&amp;lt;ObjCObjectPointerType&amp;gt;()) {
        ObjCInterfaceDecl *decl = OT-&amp;gt;getInterfaceDecl();
        if (! decl-&amp;gt;lookupInstanceMethod(Sel)) {
          errs() &amp;lt;&amp;lt; &amp;quot;Warning: class &amp;quot; &amp;lt;&amp;lt; TypeName &amp;lt;&amp;lt; &amp;quot; does not implement selector &amp;quot; &amp;lt;&amp;lt; Sel.getAsString() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
          SourceLocation Loc = E-&amp;gt;getExprLoc();
          PresumedLoc PLoc = astContext-&amp;gt;getSourceManager().getPresumedLoc(Loc);
          errs() &amp;lt;&amp;lt; &amp;quot;in &amp;quot; &amp;lt;&amp;lt; PLoc.getFilename() &amp;lt;&amp;lt; &amp;quot; &amp;lt;&amp;quot; &amp;lt;&amp;lt; PLoc.getLine() &amp;lt;&amp;lt; &amp;quot;:&amp;quot; &amp;lt;&amp;lt; PLoc.getColumn() &amp;lt;&amp;lt; &amp;quot;&amp;gt;\n&amp;quot;;
        }
      }
    }
  }
  return true;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的这个方法首先查找消息表达式， 以 &lt;code class=&quot;language-text&quot;&gt;Observer&lt;/code&gt; 作为接收者， &lt;code class=&quot;language-text&quot;&gt;observerWithTarget:action:&lt;/code&gt; 作为 selector，然后检查 target 中是否存在相应的方法。虽然这个例子有点儿刻意，但如果你想要利用 AST 对自己的代码库做某些检查，按照上面的例子来就可以了。&lt;/p&gt;
&lt;h3 id=&quot;clang的其他特性&quot;&gt;&lt;a href=&quot;#clang%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7&quot; aria-label=&quot;clang的其他特性 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;clang的其他特性&lt;/h3&gt;
&lt;p&gt;clang还有许多其他的用途。比如，可以写编译器插件（例如，类似上面的检查器例子）并且动态的加载到编译器中。虽然我没有亲自实验过，但是我觉得在 Xcode 中应该是可行的。再比如，也可以通过编写 clang 插件来自定义代码样式（具体可以参见 &lt;a href=&quot;http://objccn.io/issue-6-1/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;编译过程&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;另外，如果想对现有的代码做大规模的重构， 而 Xcode 或 AppCode 本身集成的重构工具无法达你的要求，你完全可以用 clang 自己写个重构工具。听起来有点儿可怕，读读下面的文档和教程，你会发现其实没那么难。&lt;/p&gt;
&lt;p&gt;最后，如果是真的有这种需求，你完全可以引导 Xcdoe 使用你自己编译的 clang 。再一次，如果你去尝试，其实这些事儿真的没想象中那么复杂，反而会发现许多个中乐趣。&lt;/p&gt;</content:encoded></item></channel></rss>