<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[westwood]]></title><description><![CDATA[westwood's personal website]]></description><link>https://lizhi1026.cc</link><generator>GatsbyJS</generator><lastBuildDate>Fri, 28 Feb 2020 03:23:29 GMT</lastBuildDate><item><title><![CDATA[如何系统地提高自己的智慧]]></title><description><![CDATA[…]]></description><link>https://lizhi1026.cc/2020/01-19/wisdom-update-ics</link><guid isPermaLink="false">https://lizhi1026.cc/2020/01-19/wisdom-update-ics</guid><pubDate>Sun, 19 Jan 2020 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;人一切的迷茫都来自：信息不足×思考不足。无论是寻找真爱之人，还是寻找毕生事业。信息量不足就没有选择的依据，思考不足就没有选择的原则，最后只能无从选择。&lt;/p&gt;
&lt;p&gt;千万不要以为当下的困境是最重要的，更重要的是目前的困境揭示了什么，其实是在提醒你：知道的太少、思考的太少、不知道自己到底要什么。&lt;/p&gt;
&lt;p&gt;即便你磕磕绊绊度过这次困境，核心问题不解决，下次纠结的困境自然会找上你。90％的人都在蹉跎中过一生，迷茫、纠结、无知、无助、哀怨伴随一生，都因为不正视问题的根源&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在的你，比三年前更有智慧吗？&lt;/p&gt;
&lt;p&gt;我问过很多朋友这个问题，得到最多的答案是没有。有些朋友甚至感叹一句：现在还不如读大学的时候呢，那时候比现在聪明。我相信相当一部分朋友是谦虚。毕竟随着工作时间越来越长，经验越来越多。年龄越来越大，阅历也随之增加。除非你在做机械的工作，或过着机械的生活，人的智慧怎么能不提高呢？&lt;/p&gt;
&lt;p&gt;但有趣的是，大部分人智慧的提高也仅限于此。如下图中的曲线A，这种提高受限于时间，以年为单位，缓慢而被动。此外，很明显这种提高是边际递减的，很多人在中年时，智慧慢慢达到一种较为稳定的状态。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 600px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 56.166666666666664%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB35QB/8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQABBQJf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAFxAAAwEAAAAAAAAAAAAAAAAAABEgcf/aAAgBAQABPyExz//aAAwDAQACAAMAAAAQQ8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAEAAQQDAAAAAAAAAAAAAAABABARITFxgZH/2gAIAQEAAT8Q2IsCzh2WiZlufYan/9k=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;11&quot;
        title=&quot;11&quot;
        src=&quot;/static/31b17c22753603f44451217020e85c9f/82472/11.jpg&quot;
        srcset=&quot;/static/31b17c22753603f44451217020e85c9f/afcd2/11.jpg 300w,
/static/31b17c22753603f44451217020e85c9f/82472/11.jpg 600w&quot;
        sizes=&quot;(max-width: 600px) 100vw, 600px&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我认为这是造成很多人职业天花板的一个主要原因之一。从某种意义上来说，这有点像是耗尽了自己的潜力和积累。&lt;/p&gt;
&lt;p&gt;那我们有没有可能摆脱这种曲线呢？&lt;/p&gt;
&lt;p&gt;如果我们可以找到一种方法，主动的系统性提高自己的智慧，那么曲线A就会转变成曲线E。主动系统的智慧提高可能开始时不起眼，但却是在积累势能，从本质上它是指数式的，随着长期的坚持，我们的智慧也越来越远离普通人的平均水平。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;这种主动系统性地智慧提升，很多时候并不来源于平时的工作&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大概有几个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;除去少数经历特别或运气好的人，一般在开始工作的数年里，我们都是很难决定自己做什么事、以及去什么岗位的。这就使得学习东西的范围相对狭窄&lt;/li&gt;
&lt;li&gt;有很多职位有一半以上的工作是重复性的，这就限制了学习东西的速度。&lt;/li&gt;
&lt;li&gt;有很多职位只需要高中毕业的教育水平，就可以无障碍的完成工作。这会让人无法体会到提升智慧的必要性，享受智慧提升带来的快感&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，不排除有人的工作每天都充满挑战，或如大学教授一样，需要不断提高自己的智慧。但对一般人来说，我认为是否能在平时工作之外，找到一种方法，主动的系统性提高自己的智慧，部分决定了他/她可以走多远。&lt;/p&gt;
&lt;p&gt;那么如何系统的提高自己的智慧呢？&lt;/p&gt;
&lt;p&gt;读一本书，和一个更有智慧的朋友交谈，都是对智慧的一种提高。但这里的关键词是系统地。有时候会有些惊讶，很多人对于生活工作中的小事精明谨慎，对于像提高自己智慧这种问题却出人意科的忽视和盲目。&lt;/p&gt;
&lt;p&gt;所以才会有“读了很多书，但是都忘掉了，读书的意义在哪里？”这种问题，才会有罗辑思维下面这种类型的产品出现。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 600px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 56.166666666666664%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIEBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHcRp4rFD//xAAaEAACAgMAAAAAAAAAAAAAAAABAhFCAxIx/9oACAEBAAEFArPtI5bM5VkMr//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABURAQEAAAAAAAAAAAAAAAAAAAAB/9oACAECAQE/AUf/xAAYEAEBAQEBAAAAAAAAAAAAAAABABECEP/aAAgBAQAGPwKMT3nGL//EABgQAAMBAQAAAAAAAAAAAAAAAAABETEh/9oACAEBAAE/Ie0JQop2lzdHoVck9HNPT//aAAwDAQACAAMAAAAQTD//xAAXEQEBAQEAAAAAAAAAAAAAAAABEQAh/9oACAEDAQE/EDrMkZv/xAAXEQEBAQEAAAAAAAAAAAAAAAABEQAh/9oACAECAQE/EHhcqXf/xAAbEAEBAQEAAwEAAAAAAAAAAAABEQAhMUGBYf/aAAgBAQABPxBrqyHMkmkALX5iKR9k8bn9poZCxBvTI3Udfu//2Q==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;22&quot;
        title=&quot;22&quot;
        src=&quot;/static/b4ea265276e64197ea2b64dcc11cd50d/82472/22.jpg&quot;
        srcset=&quot;/static/b4ea265276e64197ea2b64dcc11cd50d/afcd2/22.jpg 300w,
/static/b4ea265276e64197ea2b64dcc11cd50d/82472/22.jpg 600w&quot;
        sizes=&quot;(max-width: 600px) 100vw, 600px&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果像做其他事一样，对智慧提升过程有更深入的思考，和系统的方法，会大大加快我们成长的速度和收获，最终迎来指数曲线的拐点。&lt;/p&gt;
&lt;p&gt;在这方面，我们是幸运的。有很多非常有智慧的人分享了他们的经验和心得，比如巴菲特和他的合伙人芒格，诺贝尔物理学奖得主，著名的理论物理学家理查德·费曼，图灵奖和诺贝尔经济学奖得主赫伯特·西蒙等……&lt;/p&gt;
&lt;p&gt;这是我想通过接下来的一些文章，和分享大家的内容。我没有聪明到把这一切自己弄清楚，但幸运的是我们可以站在巨人的肩膀上。&lt;/p&gt;
&lt;p&gt;2013年的一次访谈中，主持人问巴菲特和芒格，为什么他们可以远超同龄人和竞争对手。芒格说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为对于那些本来比我们聪明的人，我们学到了变得比他们更聪明的方法&lt;/p&gt;
&lt;p&gt;智慧是一种运用知识、经验、理解、常识和洞见进行思考和行动的能力&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我过去的公司里，我们常说一句话：“做任何事的时候，一定要记得从消费者的角度思考问题。”但如果我们仔细思考这句话，就会发现这是不可能的。如果我是一个洗发水品牌的管理者，全国13亿人，几乎可以假定所有人都是我们的消费者，我们如何从13亿人的角度思考问题？即便这个品牌是一个面向18-25岁男性的洗发水品牌，这个群体，也有超过6000万人口。&lt;/p&gt;
&lt;p&gt;所以，另一句话我们也常用：当你做一个品牌的时候，你要闭上眼想一想，你周围的人里谁是这个品牌最准确的目标消费者？他/她有什么样的消费习惯和偏好？当我们说“考虑消费者”的时候，有两种可能，一种是我们考虑很多关于消费者的概念，类似“他是一个对生活品质有要求的年轻男性”，“他喜欢挑战”等。还有一种是我们去想某一个特定的符合标准的人。&lt;/p&gt;
&lt;p&gt;这其实是一个有趣的启示。如果你想考虑6000万人，你必须要学会忘记99.99%的人。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;在建立了抽象的概念、标签、分类以后，你才能真正开始思考。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正如下图所画的，右侧是我们眼前的真实世界，左侧是我们脑中的世界。真实世界有海量的事实、数据、信息等等，纷繁复杂的，且无时不在变化。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 600px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 50.5%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAgABBf/EABUBAQEAAAAAAAAAAAAAAAAAAAEA/9oADAMBAAIQAxAAAAHtNYAlN//EABsQAQABBQEAAAAAAAAAAAAAAAIhAAERIjEy/9oACAEBAAEFAs7qCJNX4fP/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAgEBPwEn/8QAGBAAAgMAAAAAAAAAAAAAAAAAAAERICH/2gAIAQEABj8Cjao//8QAGxAAAwACAwAAAAAAAAAAAAAAAAERECExgaH/2gAIAQEAAT8hW2g1GyKb7xyHgP/aAAwDAQACAAMAAAAQfP8A/8QAFxEBAQEBAAAAAAAAAAAAAAAAAQAhMf/aAAgBAwEBPxB5Bl//xAAWEQEBAQAAAAAAAAAAAAAAAAAAARH/2gAIAQIBAT8QjFf/xAAcEAEBAQACAwEAAAAAAAAAAAABEQAxQSFRYcH/2gAIAQEAAT8Q5yfGQ/cdJA65zAF17edC2F94iaUjiECZ/9k=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;333&quot;
        title=&quot;333&quot;
        src=&quot;/static/70e939a5161fca517a785f266d34794a/82472/333.jpg&quot;
        srcset=&quot;/static/70e939a5161fca517a785f266d34794a/afcd2/333.jpg 300w,
/static/70e939a5161fca517a785f266d34794a/82472/333.jpg 600w&quot;
        sizes=&quot;(max-width: 600px) 100vw, 600px&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如何理解这个复杂的现实世界呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们建立对这个现实世界的简化模型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这些模型可以是一种分类&lt;/strong&gt;，比如彩虹包含一切可见光，是连续光谱，是无穷尽的颜色集合，我们把这一难理解的物理事实安置到一个尺寸相对比较合适、更容易管理的框架中：彩虹是七色的，红、橙、黄、绿、蓝、靛、紫。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这些模型也可以是关于事实的一个模糊的概念&lt;/strong&gt;，每个人都可以自信地说自己知道谷歌的标志是什么样子，那是由红黄蓝三原色组成的6个字母。不过你能准确无误地告诉我哪个颜色被使用了两次吗？你的模型只在某一程度上帮助你理解事物（在这里，它帮助你把谷歌的标志和其他公司的区分开来），却并不完美的反映现实。&lt;/p&gt;
&lt;p&gt;你可以把大脑想象成一个巨大的冰箱，有隔层，也有抽屉。这是一个可以整理现实的混沌，并把一切变得井井有条的方法。我们都按照自己的意愿整理冰箱，把同类东西放在一起。若是没有把实际发生的事情做一个分类和排序，没有人可以应对如此纷繁复杂的人生。&lt;/p&gt;
&lt;p&gt;这就像是我们玩的象棋游戏，现实世界就像是一个真实的战场，而我们在自己脑中建立了棋盘战场和楚河汉界。&lt;/p&gt;
&lt;h4 id=&quot;演绎和归纳&quot;&gt;&lt;a href=&quot;#%E6%BC%94%E7%BB%8E%E5%92%8C%E5%BD%92%E7%BA%B3&quot; aria-label=&quot;演绎和归纳 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;演绎和归纳&lt;/h4&gt;
&lt;p&gt;在清楚了这个游戏的背影设定后，我们考虑的下一个问题自然是：这个游戏的规则是什么？&lt;/p&gt;
&lt;p&gt;回到上面的图，思考的时候，我们有两种行为。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一种是我们从自己脑海移向真实的世界，另一种是从真实的世界移向脑海。前者叫演绎，后者叫归纳。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演绎就像是数学公式的证明，一步一步推导，完全依赖于逻辑。A&gt;B，B&gt;C，所以A&gt;C。如文章开始时的那个例子，当一个品牌对于目标消费者有了清楚的概念和分类，那么针对不同的消费者可以投放什么样的广告，怎样投放就是一种演绎。演绎源于我们的脑海，作用于现实世界产生影响。&lt;/p&gt;
&lt;p&gt;归纳则恰恰现反。归纳源于现实世界的各种信息和事实。它是我们将一切串联、总结到脑海中，形成新的思维模型的过程。如果演绎是根据财务报表，分析企业亏损的来源和解决方案的话，那么归纳就是第一个发明财务报表这一思维模型的过程。&lt;/p&gt;
&lt;p&gt;所以，沿着这样的思路，我们可以给思考下一个定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;思考大概就是使用和建立思维模型的过程&lt;/li&gt;
&lt;li&gt;智慧的第一步是学会质疑，质疑会把我们引向问题，问题会把我们引向真理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;思维模型帮助我们简化世界，更加快速的思考，但同时也是禁锢我们的牢笼。&lt;/p&gt;
&lt;p&gt;且不说一个狭隘片面的思维模型让晋惠帝闹了“百姓无粟米充饥，何不食肉糜？”的笑话，即使是最显而易见、最广为人知的思维模型与现实事实仍然是两回事。&lt;/p&gt;
&lt;p&gt;财务报表应该是商业世界里使用最广泛的思维模型之一了。&lt;/p&gt;
&lt;p&gt;但对于从15世纪改造至今的这个思维模型，我们依然可以提出很多的疑问：比如财务报表的净利润计算中，将应收账款计入营业收入，但这笔钱在现实中真的会收到吗？将折旧计入费用中，这一笔钱又真的支出了吗？&lt;/p&gt;
&lt;p&gt;这些处理方法是这个模型的假设之一，当然有其合理性。这是我们对现实的简化，&lt;strong&gt;但却不能过于执着于思维模型，而忽略了真实的世界。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;揣摩自己思维模型的本质，询问它存在的原因，努力理解它背后的假设和限制，这是我们通往智慧的第一步。&lt;/p&gt;
&lt;p&gt;我相信，变得更有智慧的故事是一首自由的史诗：为了智慧，你必须先越狱，但在越狱之前，你必须首先意识到你是一个囚徒。&lt;/p&gt;
&lt;p&gt;-&lt;/p&gt;
&lt;p&gt;如何系统地提高自己的智慧呢？&lt;/p&gt;
&lt;p&gt;一个直接的答案是阅读、学习，或找优秀的朋友交流。毫无疑问，这些都是很好的智慧来源，但问题是少有人反思我们学到的东西到底如何实用到我们的生活中。&lt;/p&gt;
&lt;p&gt;你可能今天读了一本叫《从0到1》的畅销书，明天学习了一门MOOC上的经济学课程，后天和某大牛朋友促膝长谈两小时。你感觉收获了很多，生活很充实，但你的智慧在以最大的速度形成指数式的积累吗？学习从本质上来讲，一定是复利的。但为什么很少有人能享受到复利的巨大收益呢？&lt;/p&gt;
&lt;h4 id=&quot;从分散的概念到思维模式&quot;&gt;&lt;a href=&quot;#%E4%BB%8E%E5%88%86%E6%95%A3%E7%9A%84%E6%A6%82%E5%BF%B5%E5%88%B0%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%BC%8F&quot; aria-label=&quot;从分散的概念到思维模式 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;从分散的概念到思维模式&lt;/h4&gt;
&lt;p&gt;思维模型是我们对真实世界的简化，可能是一个概念，一个分类等。&lt;/p&gt;
&lt;p&gt;INSEAD教授，前BCG欧洲合伙人 Luc De Brabandere 在”What Managers Can Learn from Philosophy”课程指出，当我们思考时，其实是对这些思维模型进行处理的过程。他对“思考”的定义是：&lt;strong&gt;思考就是使用和建立思维模型的过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但问题在于我们建立了很多的思维模型或独立的概念，但却无法将它们串联成一个有机的系统。正如查理·芒格所说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;基本的、普世的智慧是什么？嗯，第一条规则是，如果你们只是记得一些孤立的事物，试图把它们硬凑起来，那么你们无法真正地理解任何东西。如果这些事物不在一个理论框架中相互联系，你们就无法把它们派上用场。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;你们必须在头脑中拥有一些思维模式。你们必须依靠这些模式组成的框架来安排你的经验，包括间接的和直接的。你们也许已经注意到，有些学生试图死记硬背，以此来应付考试。他们在学校中是失败者，在生活中也是失败者。你必须把经验悬挂在头脑中的一个由许多思维模式组成的框架上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这就是芒格著名的“格栅理论”。Peter Beverlin在”Seeking Wisdom”一书中有一个关于“思维模式”的进一步解释:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个思维模式就是帮助我们更好的理解世界运转规律的想法。一个思维模式往往阐释了结果，并且回答了像“Why”和”How”这类问题。&lt;/p&gt;
&lt;p&gt;比如“社会认同”（心理学的一种理论）这一模式告诉我们当人们不确定时，他们经常自动选择模仿其他人做的事情，而不会想真正正确的事是什么。这样的理论解释了人们为什么做（Why），同时预测了在特定情景下人们又会如何做一件事（How）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再举个例子&lt;/p&gt;
&lt;p&gt;你可能知道，在化学领域，有一种自催化（Autocatalysis）的现象。当一个化学反应的产物能够对这个反应的速率有进一步催化作用时，反应的速率以极快的速度提高，这种反应被称为自催化反应。在这种思维模式中，你只需要做A，但会得到A+B+C的效果。&lt;/p&gt;
&lt;p&gt;作为一种典型的思维模式，这种自催化现象你可以在很多地方遇到。一个很明显的例子是亚马逊。关于亚马逊战略的总结&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;贝佐斯与其助理团队描绘了公司步入良性循环的前景，他们相信这会成为公司发展的强大动力。公司的未来蓝图是这样的：以更低的价格来吸引更多的顾客。更多的顾客意味着更高的销量，而且也会把付给亚马逊佣金的第三方销售商更多地吸引到网站来。这也会使亚马逊从固定成本中赚取更多的利润，如物流中心和运行网站的服务器。更高的效率会使价格进一步降低。他们推断，任何一个飞轮只要运行顺畅，就会加速整个的循环过程。
—— 《一网打尽》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这其实是一种非常典型的自催化模式。&lt;/p&gt;
&lt;p&gt;另一个应用自催化模式的例子是迪士尼。我一直私以为迪士尼是全球最好的商业模式之一。&lt;/p&gt;
&lt;p&gt;迪士尼最重要的是做好一件事：电影制作。电影会产生巨额的收入，一个电影传播越广，这个电影的IP就越经典。迪士尼乐园、电影衍生品IP授权等其他的业务都会因此获益。更重要的是，这个模式是互相催化的。消费者越喜欢迪士尼乐园、购买电影的衍生品，也会进一步购买迪士尼出产的电影。&lt;/p&gt;
&lt;p&gt;此外，你还可以发现和建立自己的自催化模式，来加速达到你的目标。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;建立思维模式是非常重要的。因为思维模式的丰富度和质量，决定了我们是否可以从更全面的角度思考问题，给出深入的解析&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;另一个有趣的例子来自著名的理论物理学家，诺贝尔物理学奖得主费曼。他在普林斯顿读博士期间，经常溜去数学系，为那些天才的数学系博士生解决他们解决不了的问题。他在《别闹了，费曼先生》一书中，透露了他的秘密&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;…我在麻省理工或普林斯顿的朋友被某些积分难住，原因却是他们从学校学来的标准方法不管用。如果那是围道积分或级数展开，他们都懂得怎么把答案找出；现在他们却碰壁了。这时我便使出“积分符号内取微分”的方法——这是因为我有一个与众不同的工具箱。当其他人用光了他们的工具，还没法找到解答时，便把问题交给我了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“积分符号内取微分”的方法就是费曼不一样的“思维模式”的一种。费曼因为拥有不一样的“工具箱”，所以可以解出天才的数学系博士生都无法解决的问题。&lt;/p&gt;
&lt;p&gt;我们很多人每天工作、阅读和学习，形成了很多概念、记住了很多散布各领域的事实和结论，但却没有主动的寻找和总结类似的思维模式形成自己与众不同的工具箱，这无疑是提高智慧过程中缺失的重要一环。&lt;/p&gt;
&lt;p&gt;从某种意义上说，提高智慧的过程，就是不断通过阅读和学习发现掌握新的思维模式，充实我们工具箱的过程。&lt;/p&gt;
&lt;h4 id=&quot;你需要同时使用多种思维模式&quot;&gt;&lt;a href=&quot;#%E4%BD%A0%E9%9C%80%E8%A6%81%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%A7%8D%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%BC%8F&quot; aria-label=&quot;你需要同时使用多种思维模式 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;你需要同时使用多种思维模式&lt;/h4&gt;
&lt;p&gt;诺贝尔经济学奖得主，卡内基梅隆大学计算机科学和心理学教授 Herbert Simon 是首次提出思维模式这一思想的人。他在自传”Models of My Life”中写到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;非常有经验的决策者和新手一个很大的不同不是那些无形的“直觉”，如果我们能够进入非常有经验的决策者的脑海，会发现 1) 他们很清楚所有可能的行动，2) 在行动之前，他们有一个要思考问题的核查清单，3) 他们脑子里有一个机制在相关的决策环境出现时，可以唤醒所有相关的清单事项&lt;/p&gt;
&lt;p&gt;不同的思维模式，或思考问题的角度构成了Herbert Simon所说的”核查清单”。很明显，只掌握一种思维模式是远远不够的，但这恰恰是很多人的现状。芒格尖锐的指出&lt;/p&gt;
&lt;p&gt;你必须拥有多元思维模型——因为如果你只能使用一两个，研究人性的心理学表明，你将会扭曲现实，直到它符合你的思维模型，或者至少到你认为它符合你的模型为止。你将会和一个脊椎按摩师一样——这种医师对现代医学当然是毫无所知的。&lt;/p&gt;
&lt;p&gt;那就像谚语所说的：“在手里拿着铁锤的人看来,每个问题都像钉子。”当然，脊椎按摩师也是这样治病的。但这绝对是一种灾难性的思考方式，也绝对是一种灾难性的处世方式。所以你必须拥有多元思维模型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;生活中，我们可以找到很多“拿着锤子找钉子”的人。有趣的是，有时候如果一个人在一个领域越擅长，他就越倾向于认为自己的思维模式适合解决世界上大部分的问题。&lt;/p&gt;
&lt;p&gt;有一个典型的例子是《长尾理论》的作者，《连线》杂志的总编辑 Chris Anderson。关于这一点，Tim Wu 有一篇精彩的评论，告诉了我们一个优秀的人因为单一思维模式所带来的局限。&lt;/p&gt;
&lt;p&gt;对应的，如果你可以同时掌握多种思维模式，你解决问题的能力会成倍地提升，因为你有更多获得问题答案的角度和方法。这也是真正优秀的人，如费曼、芒格，与一般人的区别：&lt;strong&gt;他们有更多的思维模式可以自由的使用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;巴菲特评价芒格：“他有这个世界上最聪明的30秒头脑。他一次就能把从A到Z全部想全。你还没有说完，他已经看到了一切的本质。”&lt;/p&gt;
&lt;h4 id=&quot;获得多学科思维模式&quot;&gt;&lt;a href=&quot;#%E8%8E%B7%E5%BE%97%E5%A4%9A%E5%AD%A6%E7%A7%91%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%BC%8F&quot; aria-label=&quot;获得多学科思维模式 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;获得多学科思维模式&lt;/h4&gt;
&lt;p&gt;那么，我们如何获得更多的思维模式呢？&lt;/p&gt;
&lt;p&gt;方法有两种。&lt;/p&gt;
&lt;p&gt;第一种，也是最直接的一种就是大量的有意识的练习。每个领域的专家，很多都是在这种训练中逐渐建立自己独特的思维模式的。在这方面有两本书可以参考，一本是格拉德威尔举世闻名的《异类》，另一本是”Talent is over rated”（中文译：《哪来的天才》），在这里不赘述。&lt;/p&gt;
&lt;p&gt;我们聊一下第二种：如何通过阅读和学习获得。&lt;/p&gt;
&lt;p&gt;我相信很多人平时都会做大量的阅读，读微信公众号的最近文章，媒体的报道等，但这些都很难让我们获得新的思维模式，因为大量的文章都是实时性的，是一种信息和谈资的获取。过了一定的时间，你掌握的信息就不再有价值，这种情况下，当然不会有智慧的积累，所以很难产生曲线E的效果。&lt;/p&gt;
&lt;p&gt;前面提到过，一个思维模式就是帮助我们更好的理解世界运转规律的想法。这些思维模式一定是非常固定的，很少改变，同时揭示了现实世界的一部分规律。所以第二种方法是通过学习重要学科，特别是基础学科的重要理论。
芒格指出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;…这么说吧，第一条规则是，你必须拥有多元思维模型。这些模型必须来自各个不同的学科——因为你们不可能在一个小小的院系里面发现人世间全部的智慧。所以让我们来简单地看看哪些模型和技巧构成了每个人必须拥有的基础知识，有了这样的基础知识之后，他们才能够精通某项专门的艺术，比如说选股票.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这一点上，John Reed, 在”Succeeding”一书进一步补充到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当你首先可以学习一个领域时，好像你要学习上百万件事情。
你其实不必如此。
你只需要识别出这个领域最核心的原则——一般只有3-12个。你觉得你要记住的上百万的事情，不过是这些核心原则的不同组合而已&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查理·芒格也提到:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你们也许会说：“天哪，这太难做到啦。”但是，幸运的是，这没有那么难——因为掌握八九十个模型就占了90%的权重，差不多能让你成为拥有普世智慧的人了。而在这八九十个模型里面，非常重要的只有几个&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查理·芒格的更详细阐述，请见1994年在南加州大学马歇尔商学院的经典演讲或《穷查理宝典》&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过学习和运用几个，最多几十个各个学科最基本的原理或模型，就有机会显著的提高自己的智慧，这是一件多么合算的事情&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;从这里出发&quot;&gt;&lt;a href=&quot;#%E4%BB%8E%E8%BF%99%E9%87%8C%E5%87%BA%E5%8F%91&quot; aria-label=&quot;从这里出发 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;从这里出发&lt;/h4&gt;
&lt;p&gt;读得越多，就越相信这种方法是系统地提高我们智慧的最佳方法之一。&lt;/p&gt;
&lt;p&gt;有一次，当被问到如何变得更聪明时，巴菲特举起来一叠纸，说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每天阅读这样大小的500页书。知识就是这样积累起来的，就像复利一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;芒格也有一段让人触动的话&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们大量的阅读。
在我所见过的所有有智慧的人里，没有任何一个人是不大量阅读的。
但这还远远不够：你需要有这种个性，可以抓到关键并且真正领会它们。大部分人不能抓到正确的想法，或者并不知道之后要怎么做&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这三个段落是芒格上面这句话的解释。但它们更像是骨架，而每个人自己智慧的血肉还需要自己来填充。这三个段落从来不是追寻智慧旅程的终点，我也希望在后面的文章中，不断分享更具体的思维模式，更多的方法和思考。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但我相信它们是一个好的起点。让我们开始主动地、系统地提高自己的智慧&lt;/strong&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[降低软件复杂性的一般原则和方法]]></title><description><![CDATA[一、前言 斯坦福教授、Tcl语言发明者John Ousterhout 的著作《A Philosophy of Software Design》1，自出版以来，好评如潮。按照IT…]]></description><link>https://lizhi1026.cc/2019/09-20/javascript-run-loop-ics</link><guid isPermaLink="false">https://lizhi1026.cc/2019/09-20/javascript-run-loop-ics</guid><pubDate>Fri, 20 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80&quot; aria-label=&quot;一、前言 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;一、前言&lt;/h3&gt;
&lt;p&gt;斯坦福教授、Tcl语言发明者John Ousterhout 的著作《A Philosophy of Software Design》[1]，自出版以来，好评如潮。按照IT图书出版的惯例，如果冠名为“实践”，书中内容关注的是某项技术的细节和技巧；冠名为“艺术”，内容可能是记录优秀作品的设计过程和经验；而冠名为“哲学”，则是一些通用的原则和方法论，这些原则方法论串起来，能够形成一个体系。正如“知行合一”、“世界是由原子构成的”、“我思故我在”，这些耳熟能详的句子能够一定程度上代表背后的人物和思想。用一句话概括《A Philosophy of Software Design》，软件设计的核心在于降低复杂性。&lt;/p&gt;
&lt;p&gt;本篇文章是围绕着“降低复杂性”这个主题展开的，很多重要的结论来源于John Ousterhout，笔者觉得很有共鸣，就做了一些相关话题的延伸、补充了一些实例。虽说是“一般原则”，也不意味着是绝对的真理，整理出来，只是为了引发大家对软件设计的思考。&lt;/p&gt;
&lt;h3 id=&quot;二、如何定义复杂性&quot;&gt;&lt;a href=&quot;#%E4%BA%8C%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%A4%8D%E6%9D%82%E6%80%A7&quot; aria-label=&quot;二、如何定义复杂性 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;二、如何定义复杂性&lt;/h3&gt;
&lt;p&gt;关于复杂性，尚无统一的定义，从不同的角度可以给出不同的答案。可以用数量来度量，比如芯片集成的电子器件越多越复杂（不一定对）；按层次性[2]度量，复杂度在于层次的递归性和不可分解性。在信息论中，使用熵来度量信息的不确定性。&lt;/p&gt;
&lt;p&gt;John Ousterhout选择从认知的负担和开发工作量的角度来定义软件的复杂性，并且给出了一个复杂度量公式：&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 400px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 30.75%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAAAkUlEQVQY05VRywrEIAzs/3+dHtqDIBRK8eCTggetdZYNuHS3lrIBkZmYcZIM+IlaK3qx7/sl1/CZH+4ehBCQcyY8jiPmeYZzjnDjewa6gt57CCFgjIHWGuu60nm7ZIyBcw6l1Kfm0WEphYqP4yBuWRZM00Ti27bRba19FrybYYwRUsqvVv9quf16ximlS663lBeof9b+4pSzggAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;calc&quot;
        title=&quot;calc&quot;
        src=&quot;/static/10d4947098126b3c93060aa4da01086a/c7805/calc.png&quot;
        srcset=&quot;/static/10d4947098126b3c93060aa4da01086a/135ae/calc.png 300w,
/static/10d4947098126b3c93060aa4da01086a/c7805/calc.png 400w&quot;
        sizes=&quot;(max-width: 400px) 100vw, 400px&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;子模块的复杂度Cp乘以该模块对应的开发时间权重值tp，累加后得到系统的整体复杂度C。系统整体的复杂度并不简单等于所有子模块复杂度的累加，还要考虑开发维护该模块所花费的时间在整体时间中的占比（对应权重值tp）。也就是说，即使某个模块非常复杂，如果很少使用或修改，也不会对系统的整体复杂度造成大的影响。
子模块的复杂度Cp是一个经验值，它关注几个现象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;修改扩散&lt;/strong&gt;，修改时有连锁反应&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;认知负担&lt;/strong&gt;，开发人员需要多长时间来理解功能模块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不可知&lt;/strong&gt;(Unknown Unknowns），开发人员在接到任务时，不知道从哪里入手。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;造成复杂的原因一般是代码依赖和晦涩（Obscurity）。其中，依赖是指某部分代码不能被独立地修改和理解，必定会牵涉到其他代码。代码晦涩，是指从代码中难以找到重要信息。&lt;/p&gt;
&lt;h3 id=&quot;三、解决复杂性的一般原则&quot;&gt;&lt;a href=&quot;#%E4%B8%89%E3%80%81%E8%A7%A3%E5%86%B3%E5%A4%8D%E6%9D%82%E6%80%A7%E7%9A%84%E4%B8%80%E8%88%AC%E5%8E%9F%E5%88%99&quot; aria-label=&quot;三、解决复杂性的一般原则 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;三、解决复杂性的一般原则&lt;/h3&gt;
&lt;p&gt;首先，互联网行业的软件系统，很难一开始就做出完美的设计，通过一个个功能模块衍生迭代，系统才会逐步成型。对于现存的系统，也很难通过一个大动作，一劳永逸地解决所有问题。系统设计是需要持续投入的工作，通过细节的积累，最终得到一个完善的系统。因此，好的设计是日拱一卒的结果，在日常工作中要重视设计和细节的改进。&lt;/p&gt;
&lt;p&gt;其次，专业化分工和代码复用促成了软件生产率的提升。比如硬件工程师、软件工程师（底层、应用、不同编程语言）可以在无需了解对方技术背景的情况下进行合作开发；同一领域服务可以支撑不同的上层应用逻辑等等。其背后的思想，无非是通过将系统分成若干个水平层、明确每一层的角色和分工，来降低单个层次的复杂性。同时，每个层次只要给相邻层提供一致的接口，可以用不同的方法实现，这就为软件重用提供了支持。分层是解决复杂性问题的重要原则。&lt;/p&gt;
&lt;p&gt;第三，与分层类似，分模块是从垂直方向来分解系统。分模块最常见的应用场景，是如今广泛流行的微服务。分模块降低了单模块的复杂性，但是也会引入新的复杂性，例如模块与模块的交互，后面的章节会讨论这个问题。这里，我们将第三个原则确定为分模块。&lt;/p&gt;
&lt;p&gt;最后，代码能够描述程序的工作流程和结果，却很难描述开发人员的思路，而注释和文档可以。此外，通过注释和文档，开发人员在不阅读实现代码的情况下，就可以理解程序的功能，注释间接促成了代码抽象。好的注释能够帮助解决软件复杂性问题，尤其是认知负担和不可知问题（Unknown Unknowns）。&lt;/p&gt;
&lt;h3 id=&quot;四、解决复杂性之日拱一卒&quot;&gt;&lt;a href=&quot;#%E5%9B%9B%E3%80%81%E8%A7%A3%E5%86%B3%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B9%8B%E6%97%A5%E6%8B%B1%E4%B8%80%E5%8D%92&quot; aria-label=&quot;四、解决复杂性之日拱一卒 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;四、解决复杂性之日拱一卒&lt;/h3&gt;
&lt;h4 id=&quot;41-拒绝战术编程&quot;&gt;&lt;a href=&quot;#41-%E6%8B%92%E7%BB%9D%E6%88%98%E6%9C%AF%E7%BC%96%E7%A8%8B&quot; aria-label=&quot;41 拒绝战术编程 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4.1 拒绝战术编程&lt;/h4&gt;
&lt;p&gt;战术编程致力于完成任务，新增加特性或者修改Bug时，能解决问题就好。这种工作方式，会逐渐增加系统的复杂性。如果系统复杂到难以维护时，再去重构会花费大量的时间，很可能会影响新功能的迭代。&lt;/p&gt;
&lt;p&gt;战略编程，是指重视设计并愿意投入时间，短时间内可能会降低工作效率，但是长期看，会增加系统的可维护性和迭代效率。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 337px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 75.96439169139467%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAABLklEQVQ4y51U2YqEQAzs//8mH/QLxDcZFUFQB8djPBCvMUsFItqrjLuBoCaxuqq6VQ3DQHmek+d51DQNVVV1mu/3m7IsoyRJKE1TKoqC6rrm+n5OBUFAcRxz81s8Hg8yDIMsyyIQWdeVxnE8zCjXdXnVvu+58Pl8ePAspbcsC6sBu3meDz0FEBlA6CD7GgKMoEYYSn1jiAKaOqB+jxCPMS/ZdR3XXq8XPytZdQ+og0EWXoDEaZr4GRIRsMtxHDJNk57P5zngnlXbtry7WF0PXS5LvmIIX8GoLMsDwJW/kr8ARSKMBzudzZ8B4RHuYfbZJn0LBoQ/YAOjwey/YAcPAQhmV+fxbiqReffzu8UQOxpF0fYTkOudlJ9CGIa8mWrvzV1Zcqht2ybf97djht4PoRGVECfbjM4AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;leaner&quot;
        title=&quot;leaner&quot;
        src=&quot;/static/c44f7b282f3302131f9653deebe03ddd/3e757/leaner.png&quot;
        srcset=&quot;/static/c44f7b282f3302131f9653deebe03ddd/135ae/leaner.png 300w,
/static/c44f7b282f3302131f9653deebe03ddd/3e757/leaner.png 337w&quot;
        sizes=&quot;(max-width: 337px) 100vw, 337px&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;设计系统时，很难在开始阶段就面面俱到。好的设计应该体现在一个个小的模块上，修改Bug时，也应该抱着设计新系统的心态，完工后让人感觉不到“修补”的痕迹。经过累积，最终形成一个完善的系统。从长期看，对于中大型的系统，将日常开发时间的10%-15%用于设计是值得的。有一种观点认为，创业公司需要追求业务迭代速度和节省成本，可以容忍糟糕的设计，这是用错误的方法去追求正确的目标。降低开发成本最有效的方式是雇佣优秀的工程师，而不是在设计上做妥协。&lt;/p&gt;
&lt;h4 id=&quot;42-设计两次&quot;&gt;&lt;a href=&quot;#42-%E8%AE%BE%E8%AE%A1%E4%B8%A4%E6%AC%A1&quot; aria-label=&quot;42 设计两次 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4.2 设计两次&lt;/h4&gt;
&lt;p&gt;为一个类、模块或者系统的设计提供两套或更多方案，有利于我们找到最佳设计。以我们日常的技术方案设计为例，技术方案本质上需要回答两个问题，其一，为什么该方案可行？其二，在已有资源限制下，为什么该方案是最优的？为了回答第一个问题，我们需要在技术方案里补充架构图、接口设计和时间人力估算。而要回答第二个问题，需要我们在关键点或争议处提供二到三种方案，并给出建议方案，这样才有说服力。&lt;/p&gt;
&lt;p&gt;通常情况下，我们会花费很多的时间准备第一个问题，而忽略第二个问题。其实，回答好第二个问题很重要，大型软件的设计已经复杂到没人能够一次就想到最佳方案，一个仅仅“可行”的方案，可能会给系统增加额外的复杂性。对聪明人来说，接受这点更困难，因为他们习惯于“一次搞定问题”。但是聪明人迟早也会碰到自己的瓶颈，在低水平问题上徘徊，不如花费更多时间思考，去解决真正有挑战性的问题。&lt;/p&gt;
&lt;h3 id=&quot;五、解决复杂性之分层&quot;&gt;&lt;a href=&quot;#%E4%BA%94%E3%80%81%E8%A7%A3%E5%86%B3%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B9%8B%E5%88%86%E5%B1%82&quot; aria-label=&quot;五、解决复杂性之分层 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;五、解决复杂性之分层&lt;/h3&gt;
&lt;h4 id=&quot;51-层次和抽象&quot;&gt;&lt;a href=&quot;#51-%E5%B1%82%E6%AC%A1%E5%92%8C%E6%8A%BD%E8%B1%A1&quot; aria-label=&quot;51 层次和抽象 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5.1 层次和抽象&lt;/h4&gt;
&lt;p&gt;软件系统由不同的层次组成，层次之间通过接口来交互。在严格分层的系统里，内部的层只对相邻的层次可见，这样就可以将一个复杂问题分解成增量步骤序列。由于每一层最多影响两层，也给维护带来了很大的便利。分层系统最有名的实例是TCP/IP网络模型。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 380px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 92.10526315789474%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsSAAALEgHS3X78AAACLklEQVQ4y2WU56oqUQyF5/2fx58iKlgQRBG7Hvux935suXyBNeh1Q9g1KysrmQl2u51h+/3elsulDQYD+/399Rnr9/s+93o9i0QiFovFbDweh+ey0Wjk54G9jdvtZo/Hw40Ax+PR7e/vz/ez2cyGw6FtNhu73+92OBzsdDr5fL1eHeMDkMN3g/l6vXYHjECwIBPuAOaegAA7IA+hO51OHYRLZqVBaj8/P84Om0wmIRD3GGxDQCKWSiWr1WofgM1m08G63a6nCdh8Pg8ZArpYLGy73TpYCPh/ygBeLhfrdDoO1m633ZEMYKMAFIk9jHkfAr5eL9eGWYDSBBYYelEcioYUMCVlmMKQlM/n8zdDseNSlWPNOXtAAQEMAmJGB3DPWUAEopIWjupJNKtWq9ZoNJwR92IHKKmjPT3L3Wq1cgvQIZvNWr1e/yg/Q7oRmcEd8jDQDn21x5dAXynDEPoIT3TO1IvsYc8eOWBLcaQ18gS0RyKR8PR4hC6A0Eaky1BBYMxMUN7iUy6X3Ycz5oALdJQTKdLIlUrFWq2WO7HGkTXtBBulqEzQzxmiAZf6hnHmBxCPxy2dTlsmk7FcLuc6J5NJy+fz/p5B6qlUygqFQngWoEE0GvVD+gmhi8WifymkTADOYAJj1nJGV/1tYOcpw0p/GWnIUGWfz2eoJ58igLQLEgCot2BgX78vqqjmxmgVNMLUj9qju94yO0PQZQzSVjSMPSA0Mizfi0QxlaHsH3N9TxBR5koVAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;model&quot;
        title=&quot;model&quot;
        src=&quot;/static/7dffcb23e8ed50776682d27e1f1246d4/b2ba1/model.png&quot;
        srcset=&quot;/static/7dffcb23e8ed50776682d27e1f1246d4/135ae/model.png 300w,
/static/7dffcb23e8ed50776682d27e1f1246d4/b2ba1/model.png 380w&quot;
        sizes=&quot;(max-width: 380px) 100vw, 380px&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在分层系统里，每一层应该具有不同的抽象。TCP/IP模型中，应用层的抽象是用户接口和交互；传输层的抽象是端口和应用之间的数据传输；网络层的抽象是基于IP的寻址和数据传输；链路层的抽象是适配和虚拟硬件设备。如果不同的层具有相同的抽象，可能存在层次边界不清晰的问题&lt;/p&gt;
&lt;h4 id=&quot;52-复杂性下沉&quot;&gt;&lt;a href=&quot;#52-%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8B%E6%B2%89&quot; aria-label=&quot;52 复杂性下沉 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5.2 复杂性下沉&lt;/h4&gt;
&lt;p&gt;不应该让用户直面系统的复杂性，即便有额外的工作量，开发人员也应当尽量让用户使用起来更简单。如果一定要在某个层次处理复杂性，这个层次越低越好。举个例子，Thrift接口调用时，数据传输失败需要引入自动重试机制，重试的策略显然在Thrift内部封装更合适，开放给用户（下游开发人员）会增加额外的使用负担。与之类似的是系统里随处可见的配置参数（通常写在XML文件里），在编程中应当尽量避免这种情况，用户（下游开发人员）一般很难决定哪个参数是最优的，如果一定要开放参数配置，最好给定一个默认值。&lt;/p&gt;
&lt;p&gt;复杂性下沉，并不是说把所有功能下移到一个层次，过犹不及。如果复杂性跟下层的功能相关，或者下移后，能大大下降其他层次或整体的复杂性，则下移。&lt;/p&gt;
&lt;h4 id=&quot;53-异常处理&quot;&gt;&lt;a href=&quot;#53-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86&quot; aria-label=&quot;53 异常处理 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5.3 异常处理&lt;/h4&gt;
&lt;p&gt;异常和错误处理是造成软件复杂的罪魁祸首之一。有些开发人员错误的认为处理和上报的错误越多越好，这会导致过度防御性的编程。如果开发人员捕获了异常并不知道如何处理，直接往上层扔，这就违背了封装原则。&lt;/p&gt;
&lt;p&gt;降低复杂度的一个原则就是尽可能减少需要处理异常的可能性。而最佳实践就是确保错误终结，例如删除一个并不存在的文件，与其上报文件不存在的异常，不如什么都不做。确保文件不存在就好了，上层逻辑不但不会被影响，还会因为不需要处理额外的异常而变得简单。&lt;/p&gt;
&lt;h3 id=&quot;六、解决复杂性之分模块&quot;&gt;&lt;a href=&quot;#%E5%85%AD%E3%80%81%E8%A7%A3%E5%86%B3%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B9%8B%E5%88%86%E6%A8%A1%E5%9D%97&quot; aria-label=&quot;六、解决复杂性之分模块 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;六、解决复杂性之分模块&lt;/h3&gt;
&lt;p&gt;分模块是解决复杂性的重要方法。理想情况下，模块之间应该是相互隔离的，开发人员面对具体的任务，只需要接触和了解整个系统的一小部分，而无需了解或改动其他模块。&lt;/p&gt;
&lt;h4 id=&quot;61-深模块和浅模块&quot;&gt;&lt;a href=&quot;#61-%E6%B7%B1%E6%A8%A1%E5%9D%97%E5%92%8C%E6%B5%85%E6%A8%A1%E5%9D%97&quot; aria-label=&quot;61 深模块和浅模块 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6.1 深模块和浅模块&lt;/h4&gt;
&lt;p&gt;深模块（Deep Module）指的是拥有强大功能和简单接口的模块。深模块是抽象的最佳实践，通过排除模块内部不重要的信息，让用户更容易理解和使用。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1081px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 58.55689176688252%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAABa0lEQVQoz3WTyQoCMRBE/f+vULzNQfAy4uAHePagF8UFFfdl3NeS19AhghaEmSSdqup0p/B+v+UDXC4Xjcdj9ft9G/P5XMPhUJPJxPaJe71eis8xB8ViUQX9wHq91nQ61Ww203K51G630+FwCKL/YIQ4Oh6POp/P2mw2Rna9XoPq7XbT8/kMh3DbarU0GAy0WCw0Go0sE1AqlVSo1WpKkkSVSkXlclmNRuNLFTLE/Isozvm/3+8mjqngkFQIZhNXuPXUWOcATk6nk8X4uv//TDkGhKxB4CS4eTweIQYRRlykQEiwq3L5q9XKCDwIOGlM6Eb+EvoGc085rirO43uNHX8RxkrAC+Dz7XarLMtUrVZVr9etaGmaimIybzabIdYI8zwPbYESc29cwDX0ej1rF9qDNul2u2q329Y6DC+QEXIf+/1enU7Hqknfxaki5oN1MoAQYUDqbii8FBZRpoU8/fg5xsAArugAR5zyB+aEkWbTthLdAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;deep&quot;
        title=&quot;deep&quot;
        src=&quot;/static/b8f277d35c1315a542f1d3b1ebeebfb7/2fd12/deep.png&quot;
        srcset=&quot;/static/b8f277d35c1315a542f1d3b1ebeebfb7/135ae/deep.png 300w,
/static/b8f277d35c1315a542f1d3b1ebeebfb7/34e8a/deep.png 600w,
/static/b8f277d35c1315a542f1d3b1ebeebfb7/2fd12/deep.png 1081w&quot;
        sizes=&quot;(max-width: 1081px) 100vw, 1081px&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Unix操作系统文件I/O是典型的深模块，以Open函数为例，接口接受文件名为参数，返回文件描述符。但是这个接口的背后，是几百行的实现代码，用来处理文件存储、权限控制、并发控制、存储介质等等，这些对用户是不可见的。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; path&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; flags&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; mode_t permissions&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与深模块相对的是浅模块（Shallow Module），功能简单，接口复杂。通常情况下，浅模块无助于解决复杂性。因为他们提供的收益（功能）被学习和使用成本抵消了。以Java I/O为例，从I/O中读取对象时，需要同时创建三个对象FileInputStream、BufferedInputStream、ObjectInputStream，其中前两个创建后不会被直接使用，这就给开发人员造成了额外的负担。默认情况下，开发人员无需感知到BufferedInputStream，缓冲功能有助于改善文件I/O性能，是个很有用的特性，可以合并到文件I/O对象里。假如我们想放弃缓冲功能，文件I/O也可以设计成提供对应的定制选项。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;FileInputStream fileStream &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; new &lt;span class=&quot;token function&quot;&gt;FileInputStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fileName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
BufferedInputStream bufferedStream &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; new &lt;span class=&quot;token function&quot;&gt;BufferedInputStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fileStream&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
ObjectInputStream objectStream &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; new &lt;span class=&quot;token function&quot;&gt;ObjectInputStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;bufferedStream&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于浅模块有一些争议，大多数情况是因为浅模块是不得不接受的既定事实，而不见得是因为合理性。当然也有例外，比如领域驱动设计里的防腐层，系统在与外部系统对接时，会单独建立一个服务或模块去适配，用来保证原有系统技术栈的统一和稳定性。&lt;/p&gt;
&lt;h4 id=&quot;62-通用和专用&quot;&gt;&lt;a href=&quot;#62-%E9%80%9A%E7%94%A8%E5%92%8C%E4%B8%93%E7%94%A8&quot; aria-label=&quot;62 通用和专用 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6.2 通用和专用&lt;/h4&gt;
&lt;p&gt;设计新模块时，应该设计成通用模块还是专用模块？一种观点认为通用模块满足多种场景，在未来遇到预期外的需求时，可以节省时间。另外一种观点则认为，未来的需求很难预测，没必要引入用不到的特性，专用模块可以快速满足当前的需求，等有后续需求时再重构成通用的模块也不迟。&lt;/p&gt;
&lt;p&gt;以上两种思路都有道理，实际操作的时候可以采用两种方式各自的优点，即在功能实现上满足当前的需求，便于快速实现；接口设计通用化，为未来留下余量。举个例子。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;backspace&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Cursor cursor&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Cursor cursor&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;deleteSelection&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Selection selection&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;//以上三个函数可以合并为一个更通用的函数&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Position start&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Position end&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设计通用性接口需要权衡，既要满足当前的需求，同时在通用性方面不要过度设计。一些可供参考的标准：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;满足当前需求最简单的接口是什么？在不减少功能的前提下，减少方法的数量，意味着接口的通用性提升了。&lt;/li&gt;
&lt;li&gt;接口使用的场景有多少？如果接口只有一个特定的场景，可以将多个这样的接口合并成通用接口。&lt;/li&gt;
&lt;li&gt;满足当前需求情况下，接口的易用性如何？如果接口很难使用，意味着我们可能过度设计了，需要拆分。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;63-信息隐藏&quot;&gt;&lt;a href=&quot;#63-%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F&quot; aria-label=&quot;63 信息隐藏 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6.3 信息隐藏&lt;/h4&gt;
&lt;p&gt;信息隐藏是指，程序的设计思路以及内部逻辑应当包含在模块内部，对其他模块不可见。如果一个模块隐藏了很多信息，说明这个模块在提供很多功能的同时又简化了接口，符合前面提到的深模块理念。软件设计领域有个技巧，定义一个“大”类有助于实现信息隐藏。这里的“大”类指的是，如果要实现某功能，将该功能相关的信息都封装进一个类里面。&lt;/p&gt;
&lt;p&gt;信息隐藏在降低复杂性方面主要有两个作用：一是简化模块接口，将模块功能以更简单、更抽象的方式表现出来，降低开发人员的认知负担；二是减少模块间的依赖，使得系统迭代更轻量。举个例子，如何从B+树中存取信息是一些数据库索引的核心功能，但是数据库开发人员将这些信息隐藏了起来，同时提供简单的对外交互接口，也就是SQL脚本，使得产品和运营同学也能很快地上手。并且，因为有足够的抽象，数据库可以在保持外部兼容的情况下，将索引切换到散列或其他数据结构。&lt;/p&gt;
&lt;p&gt;与信息隐藏相对的是信息暴露，表现为：设计决策体现在多个模块，造成不同模块间的依赖。举个例子，两个类能处理同类型的文件。这种情况下，可以合并这两个类，或者提炼出一个新类（参考《重构》[3]一书）。工程师应当尽量减少外部模块需要的信息量。&lt;/p&gt;
&lt;h4 id=&quot;64-拆分和合并&quot;&gt;&lt;a href=&quot;#64-%E6%8B%86%E5%88%86%E5%92%8C%E5%90%88%E5%B9%B6&quot; aria-label=&quot;64 拆分和合并 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6.4 拆分和合并&lt;/h4&gt;
&lt;p&gt;两个功能，应该放在一起还是分开？“不管黑猫白猫”，能降低复杂性就好。这里有一些可以借鉴的设计思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共享信息的模块应当合并，比如两个模块都依赖某个配置项。&lt;/li&gt;
&lt;li&gt;可以简化接口时合并，这样可以避免客户同时调用多个模块来完成某个功能。&lt;/li&gt;
&lt;li&gt;可以消除重复时合并，比如抽离重复的代码到一个单独的方法中。&lt;/li&gt;
&lt;li&gt;通用代码和专用代码分离，如果模块的部分功能可以通用，建议和专用部分分离。举个例子，在实际的系统设计中，我们会将专用模块放在上层，通用模块放在下层以供复用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;七、解决复杂性之注释&quot;&gt;&lt;a href=&quot;#%E4%B8%83%E3%80%81%E8%A7%A3%E5%86%B3%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B9%8B%E6%B3%A8%E9%87%8A&quot; aria-label=&quot;七、解决复杂性之注释 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;七、解决复杂性之注释&lt;/h3&gt;
&lt;p&gt;注释可以记录开发人员的设计思路和程序功能，降低开发人员的认知负担和解决不可知（Unkown Unkowns）问题，让代码更容易维护。通常情况下，在程序的整个生命周期里，编码只占了少部分，大量时间花在了后续的维护上。有经验的工程师懂得这个道理，通常也会产出更高质量的注释和文档。&lt;/p&gt;
&lt;p&gt;注释也可以作为系统设计的工具，如果只需要简单的注释就可以描述模块的设计思路和功能，说明这个模块的设计是良好的。另一方面，如果模块很难注释，说明模块没有好的抽象。&lt;/p&gt;
&lt;h4 id=&quot;71-注释的误区&quot;&gt;&lt;a href=&quot;#71-%E6%B3%A8%E9%87%8A%E7%9A%84%E8%AF%AF%E5%8C%BA&quot; aria-label=&quot;71 注释的误区 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;7.1 注释的误区&lt;/h4&gt;
&lt;p&gt;关于注释，很多开发者存在一些认识上的误区，也是造成大家不愿意写注释的原因。比如“好代码是自注释的”、“没有时间”、“现有的注释都没有用，为什么还要浪费时间”等等。这些观点是站不住脚的。“好代码是自注释的”只在某些场景下是合理的，比如为变量和方法选择合适的名称，可以不用单独注释。但是更多的情况，代码很难体现开发人员的设计思路。此外，如果用户只能通过读代码来理解模块的使用，说明代码里没有抽象。好的注释可以极大地提升系统的可维护性，获取长期的效率，不存在“没有时间”一说。注释也是一种可以习得的技能，一旦习得，就可以在后续的工作中应用，这就解决了“注释没有用”的问题。&lt;/p&gt;
&lt;h4 id=&quot;72-使用注释提升系统可维护性&quot;&gt;&lt;a href=&quot;#72-%E4%BD%BF%E7%94%A8%E6%B3%A8%E9%87%8A%E6%8F%90%E5%8D%87%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7&quot; aria-label=&quot;72 使用注释提升系统可维护性 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;7.2 使用注释提升系统可维护性&lt;/h4&gt;
&lt;p&gt;注释应当能提供代码之外额外的信息，重视What和Why，而不是代码是如何实现的（How），最好不要简单地使用代码中出现过的单词。&lt;/p&gt;
&lt;p&gt;根据抽象程度，注释可以分为低层注释和高层注释，低层次的注释用来增加精确度，补充完善程序的信息，比如变量的单位、控制条件的边界、值是否允许为空、是否需要释放资源等。高层次注释抛弃细节，只从整体上帮助读者理解代码的功能和结构。这种类型的注释更好维护，如果代码修改不影响整体的功能，注释就无需更新。在实际工作中，需要兼顾细节和抽象。低层注释拆散与对应的实现代码放在一起，高层注释一般用于描述接口。&lt;/p&gt;
&lt;p&gt;注释先行，注释应该作为设计过程的一部分，写注释最好的时机是在开发的开始环节，这不仅会产生更好的文档，也会帮助产生好的设计，同时减少写文档带来的痛苦。开发人员推迟写注释的理由通常是：代码还在修改中，提前写注释到时候还得再改一遍。这样的话就会衍生两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，推迟注释通常意味着根本就没有注释。一旦决定推迟，很容易引发连锁反应，等到代码稳定后，也不会有注释这回事。这时候再想添加注释，就得专门抽出时间，客观条件可能不会允许这么做。&lt;/li&gt;
&lt;li&gt;其次，就算我们足够自律抽出专门时间去写注释，注释的质量也不会很好。我们潜意识中觉得代码已经写完了，急于开展下一个项目，只是象征性地添加一些注释，无法准确复现当时的设计思路。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;避免重复的注释。如果有重复注释，开发人员很难找到所有的注释去更新。解决方法是，可以找到醒目的地方存放注释文档，然后在代码处注明去查阅对应文档的地址。如果程序已经在外部文档中注释过了，不要在程序内部再注释了，添加注释的引用就可以了。
注释属于代码，而不是提交记录。一种错误的做法是将功能注释放在提交记录里，而不是放在对应代码文件里。因为开发人员通常不会去代码提交记录里去查看程序的功能描述，很不方便。&lt;/p&gt;
&lt;h4 id=&quot;73-使用注释改善系统设计&quot;&gt;&lt;a href=&quot;#73-%E4%BD%BF%E7%94%A8%E6%B3%A8%E9%87%8A%E6%94%B9%E5%96%84%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1&quot; aria-label=&quot;73 使用注释改善系统设计 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;7.3 使用注释改善系统设计&lt;/h4&gt;
&lt;p&gt;良好的设计基础是提供好的抽象。在开始编码前编写注释，可以帮助我们提炼模块的核心要素：模块或对象中最重要的功能和属性。这个过程促进我们去思考，而不是简单地堆砌代码。另一方面，注释也能够帮助我们检查自己的模块设计是否合理，正如前文中提到，深模块提供简单的接口和强大的功能，如果接口注释冗长复杂，通常意味着接口也很复杂；注释简单，意味着接口也很简单。在设计的早期注意和解决这些问题，会为我们带来长期的收益。&lt;/p&gt;
&lt;h3 id=&quot;八、后记&quot;&gt;&lt;a href=&quot;#%E5%85%AB%E3%80%81%E5%90%8E%E8%AE%B0&quot; aria-label=&quot;八、后记 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;八、后记&lt;/h3&gt;
&lt;p&gt;John Ousterhout累计写过25万行代码，是3个操作系统的重要贡献者，这些原则可以视为作者编程经验的总结。有经验的工程师看到这些观点会有共鸣，一些著作如《代码大全》、《领域驱动设计》也会有类似的观点。所以本文中提到的原则和方法具有一定实操和指导价值。对于很难有定论的问题，也可以在实践中去探索。&lt;/p&gt;
&lt;p&gt;关于原则和方法论，既不必刻意拔高，也不要嗤之以鼻。指导实践的不是更多的实践，而是实践后的总结和思考。应用原则和方法论实质是借鉴已有的经验，可以减少我们自行摸索的时间。探索新的方法可以帮助我们适应新的场景，但是新方法本身需要经过时间检验。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[从源码解读Category实现原理]]></title><description><![CDATA[什么是category？ category是 Objective-C 2.0 之后添加的语言特性，主要作用是为已经存在的类添加方法。除此之外，Apple 还推荐了category…]]></description><link>https://lizhi1026.cc/2018/03-06/Category</link><guid isPermaLink="false">https://lizhi1026.cc/2018/03-06/Category</guid><pubDate>Tue, 06 Mar 2018 00:00:00 GMT</pubDate><content:encoded>&lt;h3 id=&quot;什么是category？&quot;&gt;&lt;a href=&quot;#%E4%BB%80%E4%B9%88%E6%98%AFcategory%EF%BC%9F&quot; aria-label=&quot;什么是category？ permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;什么是category？&lt;/h3&gt;
&lt;p&gt;category是 Objective-C 2.0 之后添加的语言特性，主要作用是为已经存在的类添加方法。除此之外，Apple 还推荐了category 的另外两个使用场景。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以减少单个文件的体积&lt;/li&gt;
&lt;li&gt;可以把不同的功能组织到不同的 category 里&lt;/li&gt;
&lt;li&gt;可以由多个开发者共同完成一个类&lt;/li&gt;
&lt;li&gt;可以按需加载想要的 category 等等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;声明私有方法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不过除了apple推荐的使用场景，还衍生出了 category 的其他几个使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模拟多继承&lt;/li&gt;
&lt;li&gt;把framework的私有方法公开&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;category特点&quot;&gt;&lt;a href=&quot;#category%E7%89%B9%E7%82%B9&quot; aria-label=&quot;category特点 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;category特点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;category 只能给某个已有的类扩充方法，不能扩充成员变量&lt;/li&gt;
&lt;li&gt;category 中也可以添加属性，只不过 &lt;code class=&quot;language-text&quot;&gt;@property&lt;/code&gt; 只会生成 &lt;code class=&quot;language-text&quot;&gt;setter&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;getter&lt;/code&gt; 的声明，不会生成 &lt;code class=&quot;language-text&quot;&gt;setter&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;getter&lt;/code&gt; 的实现以及成员变量&lt;/li&gt;
&lt;li&gt;如果 category 中的方法和类中原有方法同名，category 中的方法会覆盖掉类中原有的方法&lt;/li&gt;
&lt;li&gt;如果多个 category 中存在同名的方法，运行时到底调用哪个方法由编译器决定，后面参与编译的方法会覆盖前面同名的方法，所以最后一个参与编译的方法会被调用&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这里说的是覆盖而不是替换，是因为后编译的方法被放在了方法列表的前面而已，runtime机制先找到前面的方法来执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;category--vs--extension&quot;&gt;&lt;a href=&quot;#category--vs--extension&quot; aria-label=&quot;category  vs  extension permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;code class=&quot;language-text&quot;&gt;Category&lt;/code&gt;  VS  &lt;code class=&quot;language-text&quot;&gt;Extension&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;category 常常拿来与 extension 做比较，extension 一样可以添加属性和方法，extension 看起来很像一个匿名的 category。但实际上两者几乎完全是两个东西&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;extension 运行在编译期，它就是类的一部分，拓展的方法，属性和变量一起形成一个完整的类。category 是运行期决议的，此时对象的内存布局已经确定，无法再添加实例变量&lt;/li&gt;
&lt;li&gt;extension 一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加 extension&lt;/li&gt;
&lt;li&gt;extension 和 category 都可以添加属性，但是 category 的属性不能生成成员变量和 getter、setter 方法的实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;category原理&quot;&gt;&lt;a href=&quot;#category%E5%8E%9F%E7%90%86&quot; aria-label=&quot;category原理 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;category原理&lt;/h3&gt;
&lt;p&gt;讲了一堆category的作用和特点，我们来看一下category的定义&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;typedef struct category_t *Category;

struct category_t {
    const char *name;	//category名称
    classref_t cls; 	//要拓展的类
    struct method_list_t *instanceMethods; //给类添加的实例方法的列表
    struct method_list_t *classMethods;  //给类添加的类方法的列表
    struct protocol_list_t *protocols;  //给类添加的协议的列表
    struct property_list_t *instanceProperties;  //给类添加的属性的列表
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际上 &lt;code class=&quot;language-text&quot;&gt;Category&lt;/code&gt; 是一个 &lt;code class=&quot;language-text&quot;&gt;category_t&lt;/code&gt; 的结构体，里面维护着类的信息和category的名称，以及类方法列表，实例方法列表，协议的列表和属性的列表&lt;/p&gt;
&lt;p&gt;那么Category是怎么加载的呢？&lt;/p&gt;
&lt;p&gt;我们知道，Objective-C 的运行是依赖 OC 的 runtime 的， 而 OC 的 runtime 和其他系统库一样，是OS X和iOS通过&lt;a href=&quot;https://opensource.apple.com/tarballs/objc4/objc4-723.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;dyld&lt;/a&gt;动态加载的&lt;/p&gt;
&lt;p&gt;我们从OC运行时，入口方法出发&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;void _objc_init(void)
{
    static bool initialized = false;
    if (initialized) return;
    initialized = true;
    
    // fixme defer initialization until an objc-using image is found?
    environ_init();
    tls_init();
    static_init();
    lock_init();
    exception_init();

    _dyld_objc_notify_register(&amp;amp;map_images, load_images, unmap_image);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到真正完成绑定 category 的函数&lt;code class=&quot;language-text&quot;&gt;attachCategories&lt;/code&gt;中间的函数调用栈是&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;void _objc_init(void);
└── void map_images(...);
    └── void map_images_nolock(...);
        └── void _read_images(...);
            └── void _read_images(...);
                └── static void remethodizeClass(Class cls);
                    └──attachCategories(Class cls, category_list *cats, bool flush_caches);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们来看一下 &lt;code class=&quot;language-text&quot;&gt;attachCategories&lt;/code&gt; 源码的简易版：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;static void 
attachCategories(Class cls, category_list *cats, bool flush_caches)
{
    if (!cats) return;
    
    bool isMeta = cls-&amp;gt;isMetaClass();

    method_list_t **mlists = (method_list_t **)
        malloc(cats-&amp;gt;count * sizeof(*mlists));

    int mcount = 0;
    int i = cats-&amp;gt;count;
    bool fromBundle = NO;
    while (i--) {
        auto&amp;amp; entry = cats-&amp;gt;list[i];

        method_list_t *mlist = entry.cat-&amp;gt;methodsForMeta(isMeta);
        if (mlist) {
            mlists[mcount++] = mlist;
            fromBundle |= entry.hi-&amp;gt;isBundle();
        }
    }

    auto rw = cls-&amp;gt;data();

    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);
    rw-&amp;gt;methods.attachLists(mlists, mcount);
    free(mlists);
    if (flush_caches  &amp;amp;&amp;amp;  mcount &amp;gt; 0) flushCaches(cls);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面的代码可以看出，增加方法的操作实际是分配一个大的实例方法列表
&lt;code class=&quot;language-text&quot;&gt;method_list_t **mlists = (method_list_t **)
        malloc(cats-&amp;gt;count * sizeof(*mlists));&lt;/code&gt; 再通过 for 循环将category中的方法列表填入这个大的列表，最后交给 &lt;code class=&quot;language-text&quot;&gt;rw-&amp;gt;methods.attachLists(mlists, mcount);&lt;/code&gt;将方法列表增加到类的方法列表上去。其他的属性添加与此类似&lt;/p&gt;
&lt;p&gt;我们再看一段 &lt;code class=&quot;language-text&quot;&gt;attachLists&lt;/code&gt;的源码&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;void attachLists(List* const * addedLists, uint32_t addedCount) {
 if (hasArray()) {
        
        //旧的方法列表的长度
        uint32_t oldCount = array()-&amp;gt;count;
        
        //新的方法列表的长度
        uint32_t newCount = oldCount + addedCount;
        
        setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));
        array()-&amp;gt;count = newCount;
        
        //从addedCount的偏移量添加旧的方法列表
        memmove(array()-&amp;gt;lists + addedCount, array()-&amp;gt;lists, 
                oldCount * sizeof(array()-&amp;gt;lists[0]));
        //从开始添加新方法列表
        memcpy(array()-&amp;gt;lists, addedLists, 
               addedCount * sizeof(array()-&amp;gt;lists[0]));
        }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;从上面的代码也验证了我们上面所说的，同名的方法是覆盖而不是替换，category的方法被放到了新方法列表的前面&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;category和关联对象&quot;&gt;&lt;a href=&quot;#category%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1&quot; aria-label=&quot;category和关联对象 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;category和关联对象&lt;/h3&gt;
&lt;p&gt;如上所述，category 的属性不能生成成员变量和 &lt;code class=&quot;language-text&quot;&gt;getter&lt;/code&gt;、&lt;code class=&quot;language-text&quot;&gt;setter&lt;/code&gt; 方法的实现，我们要自己实现 &lt;code class=&quot;language-text&quot;&gt;getter&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;setter&lt;/code&gt; 方法，需借助关联对象来实现&lt;/p&gt;
&lt;p&gt;关联对象来实现提供三个接口 &lt;code class=&quot;language-text&quot;&gt;objc_setAssociatedObject&lt;/code&gt;,&lt;code class=&quot;language-text&quot;&gt;objc_getAssociatedObject&lt;/code&gt;,&lt;code class=&quot;language-text&quot;&gt;objc_removeAssociatedObjects&lt;/code&gt;,他们分别调用的是&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;id objc_getAssociatedObject(id object, const void *key) {
    return _object_get_associative_reference(object, (void *)key);
}

void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) {
    _object_set_associative_reference(object, (void *)key, value, policy);
}

void objc_removeAssociatedObjects(id object) 
{
    if (object &amp;amp;&amp;amp; object-&amp;gt;hasAssociatedObjects()) {
        _object_remove_assocations(object);
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;他们调用的接口都位于 &lt;code class=&quot;language-text&quot;&gt;objc-references.mm&lt;/code&gt;文件中,&lt;/p&gt;
&lt;h5 id=&quot;objectgetassociativereference&quot;&gt;&lt;a href=&quot;#objectgetassociativereference&quot; aria-label=&quot;objectgetassociativereference permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;em&gt;object&lt;/em&gt;get&lt;em&gt;associative&lt;/em&gt;reference&lt;/h5&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;id _object_get_associative_reference(id object, void *key) {
    id value = nil;
    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;
    {
        AssociationsManager manager;
        AssociationsHashMap &amp;amp;associations(manager.associations());
        disguised_ptr_t disguised_object = DISGUISE(object);
        AssociationsHashMap::iterator i = associations.find(disguised_object);
        if (i != associations.end()) {
            ObjectAssociationMap *refs = i-&amp;gt;second;
            ObjectAssociationMap::iterator j = refs-&amp;gt;find(key);
            if (j != refs-&amp;gt;end()) {
                ObjcAssociation &amp;amp;entry = j-&amp;gt;second;
                value = entry.value();
                policy = entry.policy();
                if (policy &amp;amp; OBJC_ASSOCIATION_GETTER_RETAIN) {
                    objc_retain(value);
                }
            }
        }
    }
    if (value &amp;amp;&amp;amp; (policy &amp;amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) {
        objc_autorelease(value);
    }
    return value;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码引用的类型有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AssociationsManager&lt;/li&gt;
&lt;li&gt;AssociationsHashMap&lt;/li&gt;
&lt;li&gt;ObjcAssociationMap&lt;/li&gt;
&lt;li&gt;ObjcAssociation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;AssociationsManager源码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;spinlock_t AssociationsManagerLock;

class AssociationsManager {
    static AssociationsHashMap *_map;
public:
    // 初始化时候
    AssociationsManager()   { AssociationsManagerLock.lock(); }
    // 析构的时候
    ~AssociationsManager()  { AssociationsManagerLock.unlock(); }
    
    // associations 方法用于取得一个全局的 AssociationsHashMap 单例
    AssociationsHashMap &amp;amp;associations() {
        if (_map == NULL)
            _map = new AssociationsHashMap();
        return *_map;
    }
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;AssociationsManager 初始化一个 &lt;code class=&quot;language-text&quot;&gt;AssociationsHashMap&lt;/code&gt; 的单例，用自旋锁 &lt;code class=&quot;language-text&quot;&gt;AssociationsManagerLock&lt;/code&gt; 保证线程安全&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AssociationsHashMap源码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;class AssociationsHashMap : public unordered_map&amp;lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&amp;gt; {
    public:
        void *operator new(size_t n) { return ::malloc(n); }
        void operator delete(void *ptr) { ::free(ptr); }
    };
    &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;AssociationsHashMap&lt;/code&gt; 是一个map类型，用于保存对象的对象的 &lt;code class=&quot;language-text&quot;&gt;disguised_ptr_t&lt;/code&gt; 到 &lt;code class=&quot;language-text&quot;&gt;ObjectAssociationMap&lt;/code&gt; 的映射&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ObjectAssociationMap源码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;class ObjectAssociationMap : public std::map&amp;lt;void *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&amp;gt; {
    public:
        void *operator new(size_t n) { return ::malloc(n); }
        void operator delete(void *ptr) { ::free(ptr); }
    };&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;ObjectAssociationMap&lt;/code&gt; 则保存了从 key 到关联对象  &lt;code class=&quot;language-text&quot;&gt;ObjcAssociation&lt;/code&gt;      的映射，这个数据结构保存了当前对象对应的所有关联对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ObjcAssociation源码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;class ObjcAssociation {
        uintptr_t _policy;
        id _value;
    public:
        ObjcAssociation(uintptr_t policy, id value) : _policy(policy), _value(value) {}
        ObjcAssociation() : _policy(0), _value(nil) {}

        uintptr_t policy() const { return _policy; }
        id value() const { return _value; }
        
        bool hasValue() { return _value != nil; }
    };&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;ObjcAssociation&lt;/code&gt;  就是真正的关联对象的类，上面的所有数据结构只是为了更好的存储它。&lt;/p&gt;
&lt;p&gt;最关键的 &lt;code class=&quot;language-text&quot;&gt;ObjcAssociation&lt;/code&gt; 包含了 &lt;code class=&quot;language-text&quot;&gt;policy&lt;/code&gt; 以及 &lt;code class=&quot;language-text&quot;&gt;value&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;用一张图解释他们的关系就是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/3/6/161f8d91dcd23a17?w=3272&amp;#x26;h=513&amp;#x26;f=png&amp;#x26;s=164674&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上图我们不难看出 &lt;code class=&quot;language-text&quot;&gt;_object_get_associative_reference&lt;/code&gt; 获取关联对象的步骤是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;AssociationsHashMap &amp;amp;associations(manager.associations())&lt;/code&gt; 获取 &lt;code class=&quot;language-text&quot;&gt;AssociationsHashMap&lt;/code&gt; 的单例对象 &lt;code class=&quot;language-text&quot;&gt;associations&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;disguised_ptr_t disguised_object = DISGUISE(object)&lt;/code&gt; 获取对象的地址&lt;/li&gt;
&lt;li&gt;通过对象的地址在 &lt;code class=&quot;language-text&quot;&gt;associations&lt;/code&gt; 中获取 &lt;code class=&quot;language-text&quot;&gt;AssociationsHashMap&lt;/code&gt;迭代器&lt;/li&gt;
&lt;li&gt;通过 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt;获取到 &lt;code class=&quot;language-text&quot;&gt;ObjectAssociationMap&lt;/code&gt;的迭代器&lt;/li&gt;
&lt;li&gt;最后得出关联对象类 &lt;code class=&quot;language-text&quot;&gt;ObjcAssociation&lt;/code&gt; 的实例 &lt;code class=&quot;language-text&quot;&gt;entry&lt;/code&gt;，再获取到 &lt;code class=&quot;language-text&quot;&gt;value&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;policy&lt;/code&gt; 的值&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&quot;objectsetassociativereference&quot;&gt;&lt;a href=&quot;#objectsetassociativereference&quot; aria-label=&quot;objectsetassociativereference permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;em&gt;object&lt;/em&gt;set&lt;em&gt;associative&lt;/em&gt;reference&lt;/h5&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {
    // retain the new value (if any) outside the lock.
    uintptr_t old_policy = 0; // NOTE:  old_policy is always assigned to when old_value is non-nil.
    id new_value = value ? acquireValue(value, policy) : nil, old_value = nil; // 调用 acquireValue 对 value 进行 retain 或者 copy
    {

        // &amp;amp; 取地址 *是指针，就是地址的内容
        AssociationsManager manager;  // 初始化一个 AssociationsManager 类型的变量 manager
        AssociationsHashMap &amp;amp;associations(manager.associations());   // 取得一个全局的 AssociationsHashMap 单例
        if (new_value) {

            // 如果new_value不为空，开始遍历associations指向的map，查找object对象是否存在保存联合存储数据的ObjectAssociationMap对象

            // 查找map中是否包含某个关键字条目，用 find() 方法，传入的参数是要查找的key（被关联对象的内存地址），在这里需要提到的是begin()和end()两个成员，分别代表map对象中第一个条目和最后一个条目，这两个数据的类型是iterator.
            // 定义一个条目变量 i (实际是指针)
            AssociationsHashMap::iterator i = associations.find(object);  // AssociationsHashMap 是一个无序的哈希表，维护了从对象地址到 ObjectAssociationMap 的映射；


            // iterator是 C++ 中的迭代器 ， 这句话是定义一个 AssociationsHashMap::iterator 类型的变量 i，初始化为 associations.find(object) ， associations是AssociationsHashMap类型对象。

            // 通过map对象的方法获取的iterator数据类型 是一个std::pair对象
            // 根据对象地址获取起对应的 ObjectAssociationMap对象
            if (i != associations.end()) {
                // 存在

                // object对象在associations指向的map中存在一个ObjectAssociationMap对象refs

                // ObjectAssociationMap 是一个 C++ 中的 map ，维护了从 key（就是外界传入的key） 到 ObjcAssociation 的映射，即关联记录
                ObjectAssociationMap *refs = i-&amp;gt;second;              //  指针 调用方法 需要用 -&amp;gt;   i 是 AssociationsHashMap    i-&amp;gt;second 表示ObjectAssociationMap  i-&amp;gt;first 表示对象的地址
                ObjectAssociationMap::iterator j = refs-&amp;gt;find(key);  //  根据传入的关联对象的key（一个地址）获取其对应的关联对象  ObjectAssociationMap


                // 关联对象是否存在
                if (j != refs-&amp;gt;end()) {
                    // 使用过该key保存value，用新的value和policy替换掉原来的值
                    // 如果存在 持有旧的关联对象
                    ObjcAssociation &amp;amp;old_entry = j-&amp;gt;second;  
                    old_policy = old_entry.policy;
                    old_value = old_entry.value;

                    // 存入新的关联对象
                    old_entry.policy = policy;
                    old_entry.value = new_value;
                } else {
                    // 没用使用过该key保存value，将value和policy保存到key映射的map中
                    // 如果不存在 直接存入新的关联对象
                    (*refs)[key] = ObjcAssociation(policy, new_value);   // 对map 插入元素
                }
            }
            else {

                // 不存在
                // 没有object就创建
                // create the new association (first time).
                ObjectAssociationMap *refs = new ObjectAssociationMap;
                associations[object] = refs;
                (*refs)[key] = ObjcAssociation(policy, new_value);
                _class_setInstancesHaveAssociatedObjects(_object_getClass(object));
            }
        } else {
            // setting the association to nil breaks the association.
            AssociationsHashMap::iterator i = associations.find(object);
            if (i !=  associations.end()) {
                ObjectAssociationMap *refs = i-&amp;gt;second;
                ObjectAssociationMap::iterator j = refs-&amp;gt;find(key);
                if (j != refs-&amp;gt;end()) {
                    ObjcAssociation &amp;amp;old_entry = j-&amp;gt;second;
                    old_policy = old_entry.policy;
                    old_value = (id) old_entry.value;

                    // 从 map中删除该项
                    refs-&amp;gt;erase(j);
                }
            }
        }
    }

    // 旧的关联对象是否存在，如果存在，释放旧的关联对象。
    // release the old value (outside of the lock).
    if (old_value) releaseValue(old_value, old_policy);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;_object_set_associative_reference&lt;/code&gt;设置关联对象的流程参照图片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/3/6/161f93d77f7144de?w=700&amp;#x26;h=816&amp;#x26;f=jpeg&amp;#x26;s=61761&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;关联策略&quot;&gt;&lt;a href=&quot;#%E5%85%B3%E8%81%94%E7%AD%96%E7%95%A5&quot; aria-label=&quot;关联策略 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;关联策略&lt;/h5&gt;
&lt;p&gt;在给一个对象添加关联对象时有五种关联策略可供选择：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;关联策略&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;等价属性&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;OBJC&lt;em&gt;ASSOCIATION&lt;/em&gt;ASSIGN&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;@property (assign) or @property (unsafe_unretained)&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;弱引用关联对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;OBJC&lt;em&gt;ASSOCIATION&lt;/em&gt;RETAIN_NONATOMIC&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;@property (strong, nonatomic)&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;强引用关联对象，且为非原子操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;OBJC&lt;em&gt;ASSOCIATION&lt;/em&gt;COPY_NONATOMIC&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;@property (copy, nonatomic)&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;复制关联对象，且为非原子操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;OBJC&lt;em&gt;ASSOCIATION&lt;/em&gt;RETAIN&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;@property (strong, atomic)&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;强引用关联对象，且为原子操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;OBJC&lt;em&gt;ASSOCIATION&lt;/em&gt;COPY&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;@property (copy, atomic)&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;复制关联对象，且为原子操作&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&quot;objectremove_assocations&quot;&gt;&lt;a href=&quot;#objectremove_assocations&quot; aria-label=&quot;objectremove_assocations permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;em&gt;object&lt;/em&gt;remove_assocations&lt;/h5&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;void _object_remove_assocations(id object) {
    vector&amp;lt; ObjcAssociation,ObjcAllocator&amp;lt;ObjcAssociation&amp;gt; &amp;gt; elements;
    {
        AssociationsManager manager;
        AssociationsHashMap &amp;amp;associations(manager.associations());
        if (associations.size() == 0) return;
        disguised_ptr_t disguised_object = DISGUISE(object);
        AssociationsHashMap::iterator i = associations.find(disguised_object);
        if (i != associations.end()) {
            // 获取到所有的关联对象的associations实例
            ObjectAssociationMap *refs = i-&amp;gt;second;
            for (ObjectAssociationMap::iterator j = refs-&amp;gt;begin(), end = refs-&amp;gt;end(); j != end; ++j) {
                elements.push_back(j-&amp;gt;second);
            }
            delete refs;    //删除ObjectAssociationMap
            associations.erase(i);//删除AssociationsHashMap
        }
    }
    //删除elements集合中的所有ObjcAssociation元素
    for_each(elements.begin(), elements.end(), ReleaseValue());
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除关联对象的流程相对就比较简单了，将获取到的关联对象ObjcAssociation的实例放入一个 &lt;code class=&quot;language-text&quot;&gt;vector&lt;/code&gt;中，删除对应的 &lt;code class=&quot;language-text&quot;&gt;ObjectAssociationMap&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;AssociationsHashMap&lt;/code&gt;,最后对 &lt;code class=&quot;language-text&quot;&gt;vector&lt;/code&gt; 中每个 &lt;code class=&quot;language-text&quot;&gt;ObjcAssociation&lt;/code&gt; 实例做release操作&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#%E6%80%BB%E7%BB%93&quot; aria-label=&quot;总结 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;总结&lt;/h3&gt;
&lt;p&gt;Category在iOS开发中是比较常见的，用于给现有的类拓展新的方法和属性。本文从底层分析了Category的原理，以及关联对象实现，使大家对Category能有一个更深的认识，在以后的开发工作中能更好的使用这一特性。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Mach-O 可执行文件]]></title><description><![CDATA[我们用 Xcode 构建一个程序的过程中，会把源文件 ( 和 ) 文件转换为一个可执行文件。这个可执行文件中包含的字节码会将被 CPU (iOS 设备中的 ARM 处理器或 Mac 上的 Intel…]]></description><link>https://lizhi1026.cc/2018/02-27/Mach-O</link><guid isPermaLink="false">https://lizhi1026.cc/2018/02-27/Mach-O</guid><pubDate>Tue, 27 Feb 2018 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;我们用 Xcode 构建一个程序的过程中，会把源文件 (&lt;code class=&quot;language-text&quot;&gt;.m&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;.h&lt;/code&gt;) 文件转换为一个可执行文件。这个可执行文件中包含的字节码会将被 CPU (iOS 设备中的 ARM 处理器或 Mac 上的 Intel 处理器) 执行。&lt;/p&gt;
&lt;p&gt;本文将介绍一下上面的过程中编译器都做了些什么，同时深入看看可执行文件内部是怎样的。实际上里面的东西要比我们第一眼看到的多得多。&lt;/p&gt;
&lt;p&gt;这里我们把 Xcode 放一边，将使用命令行工具 (command-line tools)。当我们用 Xcode 构建一个程序时，Xcode 只是简单的调用了一系列的工具而已。Florian 对工具调用是如何工作的做了更详细的讨论。本文我们就直接调用这些工具，并看看它们都做了些什么。&lt;/p&gt;
&lt;p&gt;真心希望本文能帮助你更好的理解 iOS 或 OS X 中的一个可执行文件 (也叫做 &lt;em&gt;Mach-O executable&lt;/em&gt;) 是如何执行，以及怎样组装起来的。&lt;/p&gt;
&lt;h2 id=&quot;xcrun&quot;&gt;&lt;a href=&quot;#xcrun&quot; aria-label=&quot;xcrun permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;xcrun&lt;/h2&gt;
&lt;p&gt;先来看一些基础性的东西：这里会大量使用一个名为 &lt;code class=&quot;language-text&quot;&gt;xcrun&lt;/code&gt; 的命令行工具。看起来可能会有点奇怪，不过它非常的出色。这个小工具用来调用别的一些工具。原先，我们在终端执行如下命令：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% clang -v&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们用下面的命令代替：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% xcrun clang -v&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里 &lt;code class=&quot;language-text&quot;&gt;xcrun&lt;/code&gt; 做的是定位到 &lt;code class=&quot;language-text&quot;&gt;clang&lt;/code&gt;，并执行它，附带输入 &lt;code class=&quot;language-text&quot;&gt;clang&lt;/code&gt; 后面的参数。&lt;/p&gt;
&lt;p&gt;我们为什么要这样做呢？看起来没有什么意义。不过 &lt;code class=&quot;language-text&quot;&gt;xcode&lt;/code&gt; 允许我们: (1) 使用多个版本的 Xcode，以及使用某个特定 Xcode 版本中的工具。(2) 针对某个特定的 SDK (software development kit) 使用不同的工具。如果你有 Xcode 4.5 和 Xcode 5，通过 &lt;code class=&quot;language-text&quot;&gt;xcode-select&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;xcrun&lt;/code&gt; 可以选择使用 Xcode 5 中 iOS SDK 的工具，或者 Xcode 4.5 中的 OS X 工具。在许多其它平台中，这是不可能做到的。查阅 &lt;code class=&quot;language-text&quot;&gt;xcrun&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;xcode-select&lt;/code&gt; 的主页内容可以了解到详细内容。不用安装 &lt;em&gt;Command Line Tools&lt;/em&gt;，就能使用命令行中的开发者工具。&lt;/p&gt;
&lt;h2 id=&quot;不使用-ide-的-hello-world&quot;&gt;&lt;a href=&quot;#%E4%B8%8D%E4%BD%BF%E7%94%A8-ide-%E7%9A%84-hello-world&quot; aria-label=&quot;不使用 ide 的 hello world permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;不使用 IDE 的 Hello World&lt;/h2&gt;
&lt;p&gt;回到终端 (Terminal)，创建一个包含一个 C 文件的文件夹：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% mkdir ~/Desktop/objcio-command-line
% cd !$
% touch helloworld.c&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着使用你喜欢的文本编辑器来编辑这个文件 -- 例如 TextEdit.app：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% open -e helloworld.c&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输入如下代码：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int main(int argc, char *argv[])
{
    printf(&amp;quot;Hello World!\n&amp;quot;);
    return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;保存并返回到终端，然后运行如下命令：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% xcrun clang helloworld.c
% ./a.out&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在你能够在终端上看到熟悉的 &lt;code class=&quot;language-text&quot;&gt;Hello World!&lt;/code&gt;。这里我们编译并运行 C 程序，全程没有使用 IDE。深呼吸一下，高兴高兴。&lt;/p&gt;
&lt;p&gt;上面我们到底做了些什么呢？我们将 &lt;code class=&quot;language-text&quot;&gt;helloworld.c&lt;/code&gt; 编译为一个名为 &lt;code class=&quot;language-text&quot;&gt;a.out&lt;/code&gt; 的 Mach-O 二进制文件。注意，如果我们没有指定名字，那么编译器会默认的将其指定为 a.out。&lt;/p&gt;
&lt;p&gt;这个二进制文件是如何生成的呢？实际上有许多内容需要观察和理解。我们先看看编译器吧。&lt;/p&gt;
&lt;h3 id=&quot;hello-world-和编译器&quot;&gt;&lt;a href=&quot;#hello-world-%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8&quot; aria-label=&quot;hello world 和编译器 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Hello World 和编译器&lt;/h3&gt;
&lt;p&gt;时下 Xcode 中编译器默认选择使用 &lt;code class=&quot;language-text&quot;&gt;clang&lt;/code&gt;(读作 /klæŋ/)。&lt;a href=&quot;http://objccn.io/issue-6-2/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;关于编译器&lt;/a&gt;，Chris 写了更详细的文章。&lt;/p&gt;
&lt;p&gt;简单的说，编译器处理过程中，将 &lt;code class=&quot;language-text&quot;&gt;helloworld.c&lt;/code&gt; 当做输入文件，并生成一个可执行文件 &lt;code class=&quot;language-text&quot;&gt;a.out&lt;/code&gt;。这个过程有多个步骤/阶段。我们需要做的就是正确的执行它们。&lt;/p&gt;
&lt;h5 id=&quot;预处理&quot;&gt;&lt;a href=&quot;#%E9%A2%84%E5%A4%84%E7%90%86&quot; aria-label=&quot;预处理 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;预处理&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;符号化 (Tokenization)&lt;/li&gt;
&lt;li&gt;宏定义的展开&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;#include&lt;/code&gt; 的展开&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;语法和语义分析&quot;&gt;&lt;a href=&quot;#%E8%AF%AD%E6%B3%95%E5%92%8C%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90&quot; aria-label=&quot;语法和语义分析 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;语法和语义分析&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;将符号化后的内容转化为一棵解析树 (parse tree)&lt;/li&gt;
&lt;li&gt;解析树做语义分析&lt;/li&gt;
&lt;li&gt;输出一棵&lt;em&gt;抽象语法树&lt;/em&gt;（Abstract Syntax Tree* (AST)）&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;生成代码和优化&quot;&gt;&lt;a href=&quot;#%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E5%92%8C%E4%BC%98%E5%8C%96&quot; aria-label=&quot;生成代码和优化 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;生成代码和优化&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;将 AST 转换为更低级的中间码 (LLVM IR)&lt;/li&gt;
&lt;li&gt;对生成的中间码做优化&lt;/li&gt;
&lt;li&gt;生成特定目标代码&lt;/li&gt;
&lt;li&gt;输出汇编代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;汇编器&quot;&gt;&lt;a href=&quot;#%E6%B1%87%E7%BC%96%E5%99%A8&quot; aria-label=&quot;汇编器 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;汇编器&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;将汇编代码转换为目标对象文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;链接器&quot;&gt;&lt;a href=&quot;#%E9%93%BE%E6%8E%A5%E5%99%A8&quot; aria-label=&quot;链接器 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;链接器&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;将多个目标对象文件合并为一个可执行文件 (或者一个动态库)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们来看一个关于这些步骤的简单的例子。&lt;/p&gt;
&lt;h4 id=&quot;预处理-1&quot;&gt;&lt;a href=&quot;#%E9%A2%84%E5%A4%84%E7%90%86-1&quot; aria-label=&quot;预处理 1 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;预处理&lt;/h4&gt;
&lt;p&gt;编译过程中，编译器首先要做的事情就是对文件做处理。预处理结束之后，如果我们停止编译过程，那么我们可以让编译器显示出预处理的一些内容：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% xcrun clang -E helloworld.c&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;喔喔。 上面的命令输出的内容有 413 行。我们用编辑器打开这些内容，看看到底发生了什么：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% xcrun clang -E helloworld.c | open -f&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在顶部可以看到的许多行语句都是以 &lt;code class=&quot;language-text&quot;&gt;#&lt;/code&gt; 开头 (读作 &lt;code class=&quot;language-text&quot;&gt;hash&lt;/code&gt;)。这些被称为 &lt;em&gt;行标记&lt;/em&gt; 的语句告诉我们后面跟着的内容来自哪里。如果再回头看看 &lt;code class=&quot;language-text&quot;&gt;helloworld.c&lt;/code&gt; 文件，会发现第一行是：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们都用过 &lt;code class=&quot;language-text&quot;&gt;#include&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;import&lt;/code&gt;。它们所做的事情是告诉预处理器将文件 &lt;code class=&quot;language-text&quot;&gt;stdio.h&lt;/code&gt; 中的内容插入到 &lt;code class=&quot;language-text&quot;&gt;#include&lt;/code&gt; 语句所在的位置。这是一个递归的过程：&lt;code class=&quot;language-text&quot;&gt;stdio.h&lt;/code&gt; 可能会包含其它的文件。&lt;/p&gt;
&lt;p&gt;由于这样的递归插入过程很多，所以我们需要确保记住相关行号信息。为了确保无误，预处理器在发生变更的地方插入以 &lt;code class=&quot;language-text&quot;&gt;#&lt;/code&gt; 开头的 &lt;code class=&quot;language-text&quot;&gt;行标记&lt;/code&gt;。跟在 &lt;code class=&quot;language-text&quot;&gt;#&lt;/code&gt; 后面的数字是在源文件中的行号，而最后的数字是在新文件中的行号。回到刚才打开的文件，紧跟着的是系统头文件，或者是被看做为封装了 &lt;code class=&quot;language-text&quot;&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 代码块的文件。&lt;/p&gt;
&lt;p&gt;如果滚动到文件末尾，可以看到我们的 &lt;code class=&quot;language-text&quot;&gt;helloworld.c&lt;/code&gt; 代码：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# 2 &amp;quot;helloworld.c&amp;quot; 2
int main(int argc, char *argv[])
{
 printf(&amp;quot;Hello World!\n&amp;quot;);
 return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 Xcode 中，可以通过这样的方式查看任意文件的预处理结果：&lt;strong&gt;Product&lt;/strong&gt; -&gt; &lt;strong&gt;Perform Action&lt;/strong&gt; -&gt; &lt;strong&gt;Preprocess&lt;/strong&gt;。注意，编辑器加载预处理后的文件需要花费一些时间 -- 接近 100,000 行代码。&lt;/p&gt;
&lt;h4 id=&quot;编译&quot;&gt;&lt;a href=&quot;#%E7%BC%96%E8%AF%91&quot; aria-label=&quot;编译 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;编译&lt;/h4&gt;
&lt;p&gt;下一步：分析和代码生成。我们可以用下面的命令让 &lt;code class=&quot;language-text&quot;&gt;clang&lt;/code&gt; 输出汇编代码：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% xcrun clang -S -o - helloworld.c | open -f&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们来看看输出的结果。首先会看到有一些以点 &lt;code class=&quot;language-text&quot;&gt;.&lt;/code&gt; 开头的行。这些就是汇编指令。其它的则是实际的 x86_64 汇编代码。最后是一些标记 (label)，与 C 语言中的类似。&lt;/p&gt;
&lt;p&gt;我们先看看前三行：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;    .section    __TEXT,__text,regular,pure_instructions
    .globl  _main
    .align  4, 0x90&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这三行是汇编指令，不是汇编代码。&lt;code class=&quot;language-text&quot;&gt;.section&lt;/code&gt; 指令指定接下来会执行哪一个段。&lt;/p&gt;
&lt;p&gt;第二行的 &lt;code class=&quot;language-text&quot;&gt;.globl&lt;/code&gt; 指令说明 &lt;code class=&quot;language-text&quot;&gt;_main&lt;/code&gt; 是一个外部符号。这就是我们的 &lt;code class=&quot;language-text&quot;&gt;main()&lt;/code&gt; 函数。这个函数对于二进制文件外部来说是可见的，因为系统要调用它来运行可执行文件。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;.align&lt;/code&gt; 指令指出了后面代码的对齐方式。在我们的代码中，后面的代码会按照 16(2^4) 字节对齐，如果需要的话，用 &lt;code class=&quot;language-text&quot;&gt;0x90&lt;/code&gt; 补齐。&lt;/p&gt;
&lt;p&gt;接下来是 main 函数的头部：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;_main:                                  ## @main
    .cfi_startproc
## BB#0:
    pushq   %rbp
Ltmp2:
    .cfi_def_cfa_offset 16
Ltmp3:
    .cfi_offset %rbp, -16
    movq    %rsp, %rbp
Ltmp4:
    .cfi_def_cfa_register %rbp
    subq    $32, %rsp&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码中有一些与 C 标记工作机制一样的一些标记。它们是某些特定部分的汇编代码的符号链接。首先是 &lt;code class=&quot;language-text&quot;&gt;_main&lt;/code&gt; 函数真正开始的地址。这个符号会被 export。二进制文件会有这个位置的一个引用。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;.cfi_startproc&lt;/code&gt; 指令通常用于函数的开始处。CFI 是调用帧信息 (Call Frame Information) 的缩写。这个调用 &lt;code class=&quot;language-text&quot;&gt;帧&lt;/code&gt; 以松散的方式对应着一个函数。当开发者使用 debugger 和 &lt;em&gt;step in&lt;/em&gt; 或 &lt;em&gt;step out&lt;/em&gt; 时，实际上是 stepping in/out 一个调用帧。在 C 代码中，函数有自己的调用帧，当然，别的一些东西也会有类似的调用帧。&lt;code class=&quot;language-text&quot;&gt;.cfi_startproc&lt;/code&gt; 指令给了函数一个 &lt;code class=&quot;language-text&quot;&gt;.eh_frame&lt;/code&gt; 入口，这个入口包含了一些调用栈的信息（抛出异常时也是用其来展开调用帧堆栈的）。这个指令也会发送一些和具体平台相关的指令给 CFI。它与后面的 &lt;code class=&quot;language-text&quot;&gt;.cfi_endproc&lt;/code&gt; 相匹配，以此标记出 &lt;code class=&quot;language-text&quot;&gt;main()&lt;/code&gt; 函数结束的地方。&lt;/p&gt;
&lt;p&gt;接着是另外一个 label &lt;code class=&quot;language-text&quot;&gt;## BB#0:&lt;/code&gt;。然后，终于，看到第一句汇编代码：&lt;code class=&quot;language-text&quot;&gt;pushq %rbp&lt;/code&gt;。从这里开始事情开始变得有趣。在 OS X上，我们会有 X86_64 的代码，对于这种架构，有一个东西叫做 &lt;em&gt;ABI&lt;/em&gt; ( 应用二进制接口 application binary interface)，ABI 指定了函数调用是如何在汇编代码层面上工作的。在函数调用期间，ABI 会让 &lt;code class=&quot;language-text&quot;&gt;rbp&lt;/code&gt; 寄存器 (基础指针寄存器 base pointer register) 被保护起来。当函数调用返回时，确保 &lt;code class=&quot;language-text&quot;&gt;rbp&lt;/code&gt; 寄存器的值跟之前一样，这是属于 main 函数的职责。&lt;code class=&quot;language-text&quot;&gt;pushq %rbp&lt;/code&gt; 将 &lt;code class=&quot;language-text&quot;&gt;rbp&lt;/code&gt; 的值 push 到栈中，以便我们以后将其 pop 出来。&lt;/p&gt;
&lt;p&gt;接下来是两个 CFI 指令：&lt;code class=&quot;language-text&quot;&gt;.cfi_def_cfa_offset 16&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;.cfi_offset %rbp, -16&lt;/code&gt;。这将会输出一些关于生成调用堆栈展开和调试的信息。我们改变了堆栈和基础指针，而这两个指令可以告诉编译器它们都在哪儿，或者更确切的，它们可以确保之后调试器要使用这些信息时，能找到对应的东西。&lt;/p&gt;
&lt;p&gt;接下来，&lt;code class=&quot;language-text&quot;&gt;movq %rsp, %rbp&lt;/code&gt; 将把局部变量放置到栈上。&lt;code class=&quot;language-text&quot;&gt;subq $32, %rsp&lt;/code&gt; 将栈指针移动 32 个字节，也就是函数会调用的位置。我们先将老的栈指针存储到 &lt;code class=&quot;language-text&quot;&gt;rbp&lt;/code&gt; 中，然后将此作为我们局部变量的基址，接着我们更新堆栈指针到我们将会使用的位置。&lt;/p&gt;
&lt;p&gt;之后，我们调用了 &lt;code class=&quot;language-text&quot;&gt;printf()&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;leaq    L_.str(%rip), %rax
movl    $0, -4(%rbp)
movl    %edi, -8(%rbp)
movq    %rsi, -16(%rbp)
movq    %rax, %rdi
movb    $0, %al
callq   _printf&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先，&lt;code class=&quot;language-text&quot;&gt;leaq&lt;/code&gt; 会将 &lt;code class=&quot;language-text&quot;&gt;L_.str&lt;/code&gt; 的指针加载到 &lt;code class=&quot;language-text&quot;&gt;rax&lt;/code&gt; 寄存器中。留意 &lt;code class=&quot;language-text&quot;&gt;L_.str&lt;/code&gt; 标记在后面的汇编代码中是如何定义的。它就是 C 字符串&lt;code class=&quot;language-text&quot;&gt;&amp;quot;Hello World!\n&amp;quot;&lt;/code&gt;。 &lt;code class=&quot;language-text&quot;&gt;edi&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;rsi&lt;/code&gt; 寄存器保存了函数的第一个和第二个参数。由于我们会调用别的函数，所以首先需要将它们的当前值保存起来。这就是为什么我们使用刚刚存储的 &lt;code class=&quot;language-text&quot;&gt;rbp&lt;/code&gt; 偏移32个字节的原因。第一个 32 字节的值是 0，之后的 32 字节的值是 &lt;code class=&quot;language-text&quot;&gt;edi&lt;/code&gt; 寄存器的值 (存储了 &lt;code class=&quot;language-text&quot;&gt;argc&lt;/code&gt;)。然后是 64 字节 的值：&lt;code class=&quot;language-text&quot;&gt;rsi&lt;/code&gt; 寄存器的值 (存储了 &lt;code class=&quot;language-text&quot;&gt;argv&lt;/code&gt;)。我们在后面并没有使用这些值，但是编译器在没有经过优化处理的时候，它们还是会被存下来。&lt;/p&gt;
&lt;p&gt;现在我们把第一个函数 &lt;code class=&quot;language-text&quot;&gt;printf()&lt;/code&gt; 的参数 &lt;code class=&quot;language-text&quot;&gt;rax&lt;/code&gt; 设置给第一个函数参数寄存器 &lt;code class=&quot;language-text&quot;&gt;edi&lt;/code&gt; 中。&lt;code class=&quot;language-text&quot;&gt;printf()&lt;/code&gt; 是一个可变参数的函数。ABI 调用约定指定，将会把使用来存储参数的寄存器数量存储在寄存器 &lt;code class=&quot;language-text&quot;&gt;al&lt;/code&gt; 中。在这里是 0。最后 &lt;code class=&quot;language-text&quot;&gt;callq&lt;/code&gt; 调用了 &lt;code class=&quot;language-text&quot;&gt;printf()&lt;/code&gt; 函数。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;    movl    $0, %ecx
    movl    %eax, -20(%rbp)         ## 4-byte Spill
    movl    %ecx, %eax&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码将 &lt;code class=&quot;language-text&quot;&gt;ecx&lt;/code&gt; 寄存器设置为 0，并把 &lt;code class=&quot;language-text&quot;&gt;eax&lt;/code&gt; 寄存器的值保存至栈中，然后将 &lt;code class=&quot;language-text&quot;&gt;ect&lt;/code&gt; 中的 0 拷贝至 &lt;code class=&quot;language-text&quot;&gt;eax&lt;/code&gt; 中。ABI 规定 &lt;code class=&quot;language-text&quot;&gt;eax&lt;/code&gt; 将用来保存一个函数的返回值，或者此处 &lt;code class=&quot;language-text&quot;&gt;main()&lt;/code&gt; 函数的返回值 0：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;    addq    $32, %rsp
    popq    %rbp
    ret
    .cfi_endproc&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数执行完成后，将恢复堆栈指针 —— 利用上面的指令 &lt;code class=&quot;language-text&quot;&gt;subq $32, %rsp&lt;/code&gt; 把堆栈指针 &lt;code class=&quot;language-text&quot;&gt;rsp&lt;/code&gt; 上移 32 字节。最后，把之前存储至 &lt;code class=&quot;language-text&quot;&gt;rbp&lt;/code&gt; 中的值从栈中弹出来，然后调用 &lt;code class=&quot;language-text&quot;&gt;ret&lt;/code&gt; 返回调用者， &lt;code class=&quot;language-text&quot;&gt;ret&lt;/code&gt; 会读取出栈的返回地址。 &lt;code class=&quot;language-text&quot;&gt;.cfi_endproc&lt;/code&gt; 平衡了 &lt;code class=&quot;language-text&quot;&gt;.cfi_startproc&lt;/code&gt; 指令。&lt;/p&gt;
&lt;p&gt;接下来是输出字符串 &lt;code class=&quot;language-text&quot;&gt;&amp;quot;Hello World!\n&amp;quot;&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;    .section    __TEXT,__cstring,cstring_literals
L_.str:                                 ## @.str
    .asciz   &amp;quot;Hello World!\n&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样，&lt;code class=&quot;language-text&quot;&gt;.section&lt;/code&gt; 指令指出下面将要进入的段。&lt;code class=&quot;language-text&quot;&gt;L_.str&lt;/code&gt; 标记运行在实际的代码中获取到字符串的一个指针。&lt;code class=&quot;language-text&quot;&gt;.asciz&lt;/code&gt; 指令告诉编译器输出一个以 ‘\0’ (null) 结尾的字符串。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;__TEXT __cstring&lt;/code&gt; 开启了一个新的段。这个段中包含了 C 字符串：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;L_.str:                                 ## @.str
    .asciz     &amp;quot;Hello World!\n&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面两行代码创建了一个 null 结尾的字符串。注意 &lt;code class=&quot;language-text&quot;&gt;L_.str&lt;/code&gt; 是如何命名，之后会通过它来访问字符串。&lt;/p&gt;
&lt;p&gt;最后的 &lt;code class=&quot;language-text&quot;&gt;.subsections_via_symbols&lt;/code&gt; 指令是静态链接编辑器使用的。&lt;/p&gt;
&lt;p&gt;更过关于汇编指令的资料可以在 苹果的 &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/Assembler/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;OS X Assembler Reference&lt;/a&gt; 中看到。AMD 64 网站有关于 &lt;a href=&quot;http://www.x86-64.org/documentation/abi.pdf&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;ABI for x86 的文档&lt;/a&gt;。另外还有 &lt;a href=&quot;http://www.x86-64.org/documentation/assembly.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Gentle Introduction to x86-64 Assembly&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;重申一下，通过下面的选择操作，我们可以用 Xcode 查看任意文件的汇编输出结果：&lt;strong&gt;Product&lt;/strong&gt; -&gt; &lt;strong&gt;Perform Action&lt;/strong&gt; -&gt; &lt;strong&gt;Assemble&lt;/strong&gt;.&lt;/p&gt;
&lt;h4 id=&quot;汇编器-1&quot;&gt;&lt;a href=&quot;#%E6%B1%87%E7%BC%96%E5%99%A8-1&quot; aria-label=&quot;汇编器 1 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;汇编器&lt;/h4&gt;
&lt;p&gt;汇编器将可读的汇编代码转换为机器代码。它会创建一个目标对象文件，一般简称为 &lt;em&gt;对象文件&lt;/em&gt;。这些文件以 &lt;code class=&quot;language-text&quot;&gt;.o&lt;/code&gt; 结尾。如果用 Xcode 构建应用程序，可以在工程的 &lt;em&gt;derived data&lt;/em&gt; 目录中，&lt;code class=&quot;language-text&quot;&gt;Objects-normal&lt;/code&gt; 文件夹下找到这些文件。&lt;/p&gt;
&lt;h4 id=&quot;链接器-1&quot;&gt;&lt;a href=&quot;#%E9%93%BE%E6%8E%A5%E5%99%A8-1&quot; aria-label=&quot;链接器 1 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;链接器&lt;/h4&gt;
&lt;p&gt;稍后我们会对链接器做更详细的介绍。这里简单介绍一下：链接器解决了目标文件和库之间的链接。什么意思呢？还记得下面的语句吗：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;callq   _printf&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;printf()&lt;/code&gt; 是 &lt;em&gt;libc&lt;/em&gt; 库中的一个函数。无论怎样，最后的可执行文件需要能需要知道 &lt;code class=&quot;language-text&quot;&gt;printf()&lt;/code&gt; 在内存中的具体位置：例如，&lt;code class=&quot;language-text&quot;&gt;_printf&lt;/code&gt; 的地址符号是什么。链接器会读取所有的目标文件 (此处只有一个) 和库 (此处是 &lt;em&gt;libc&lt;/em&gt;)，并解决所有未知符号 (此处是 &lt;code class=&quot;language-text&quot;&gt;_printf&lt;/code&gt;) 的问题。然后将它们编码进最后的可执行文件中  （可以在 &lt;em&gt;libc&lt;/em&gt; 中找到符号 &lt;code class=&quot;language-text&quot;&gt;_printf&lt;/code&gt;），接着链接器会输出可以运行的执行文件：&lt;code class=&quot;language-text&quot;&gt;a.out&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;section&quot;&gt;&lt;a href=&quot;#section&quot; aria-label=&quot;section permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Section&lt;/h2&gt;
&lt;p&gt;就像我们上面提到的一样，这里有些东西叫做 section。一个可执行文件包含多个段，也就是多个 section。可执行文件不同的部分将加载进不同的 section，并且每个 section 会转换进某个 segment 里。这个概念对于所有的可执行文件都是成立的。&lt;/p&gt;
&lt;p&gt;我们来看看 &lt;code class=&quot;language-text&quot;&gt;a.out&lt;/code&gt; 二进制中的 section。我们可以使用 &lt;code class=&quot;language-text&quot;&gt;size&lt;/code&gt; 工具来观察：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% xcrun size -x -l -m a.out 
Segment __PAGEZERO: 0x100000000 (vmaddr 0x0 fileoff 0)
Segment __TEXT: 0x1000 (vmaddr 0x100000000 fileoff 0)
    Section __text: 0x37 (addr 0x100000f30 offset 3888)
    Section __stubs: 0x6 (addr 0x100000f68 offset 3944)
    Section __stub_helper: 0x1a (addr 0x100000f70 offset 3952)
    Section __cstring: 0xe (addr 0x100000f8a offset 3978)
    Section __unwind_info: 0x48 (addr 0x100000f98 offset 3992)
    Section __eh_frame: 0x18 (addr 0x100000fe0 offset 4064)
    total 0xc5
Segment __DATA: 0x1000 (vmaddr 0x100001000 fileoff 4096)
    Section __nl_symbol_ptr: 0x10 (addr 0x100001000 offset 4096)
    Section __la_symbol_ptr: 0x8 (addr 0x100001010 offset 4112)
    total 0x18
Segment __LINKEDIT: 0x1000 (vmaddr 0x100002000 fileoff 8192)
total 0x100003000&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码所示，我们的 &lt;code class=&quot;language-text&quot;&gt;a.out&lt;/code&gt; 文件有 4 个 segment。有些 segment 中有多个 section。&lt;/p&gt;
&lt;p&gt;当运行一个可执行文件时，虚拟内存 (VM - virtual memory) 系统将 segment 映射到进程的地址空间上。映射完全不同于我们一般的认识，如果你对虚拟内存系统不熟悉，可以简单的想象虚拟内存系统将整个可执行文件加载进内存 -- 虽然在实际上不是这样的。VM 使用了一些技巧来避免全部加载。&lt;/p&gt;
&lt;p&gt;当虚拟内存系统进行映射时，segment 和 section 会以不同的参数和权限被映射。&lt;/p&gt;
&lt;p&gt;上面的代码中，&lt;code class=&quot;language-text&quot;&gt;__TEXT&lt;/code&gt; segment 包含了被执行的代码。它被以只读和可执行的方式映射。进程被允许执行这些代码，但是不能修改。这些代码也不能对自己做出修改，因此这些被映射的页从来不会被改变。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;__DATA&lt;/code&gt; segment 以可读写和不可执行的方式映射。它包含了将会被更改的数据。&lt;/p&gt;
&lt;p&gt;第一个 segment 是 &lt;code class=&quot;language-text&quot;&gt;__PAGEZERO&lt;/code&gt;。它的大小为 4GB。这 4GB 并不是文件的真实大小，但是规定了进程地址空间的前 4GB 被映射为 不可执行、不可写和不可读。这就是为什么当读写一个 &lt;code class=&quot;language-text&quot;&gt;NULL&lt;/code&gt; 指针或更小的值时会得到一个 &lt;code class=&quot;language-text&quot;&gt;EXC_BAD_ACCESS&lt;/code&gt; 错误。这是操作系统在尝试防止&lt;a href=&quot;http://www.xkcd.com/371/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;引起系统崩溃&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在 segment中，一般都会有多个 section。它们包含了可执行文件的不同部分。在 &lt;code class=&quot;language-text&quot;&gt;__TEXT&lt;/code&gt; segment 中，&lt;code class=&quot;language-text&quot;&gt;__text&lt;/code&gt; section 包含了编译所得到的机器码。&lt;code class=&quot;language-text&quot;&gt;__stubs&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;__stub_helper&lt;/code&gt; 是给动态链接器 (&lt;code class=&quot;language-text&quot;&gt;dyld&lt;/code&gt;) 使用的。通过这两个 section，在动态链接代码中，可以允许延迟链接。&lt;code class=&quot;language-text&quot;&gt;__const&lt;/code&gt; (在我们的代码中没有) 是常量，不可变的，就像 &lt;code class=&quot;language-text&quot;&gt;__cstring&lt;/code&gt; (包含了可执行文件中的字符串常量 -- 在源码中被双引号包含的字符串) 常量一样。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;__DATA&lt;/code&gt; segment 中包含了可读写数据。在我们的程序中只有 &lt;code class=&quot;language-text&quot;&gt;__nl_symbol_ptr&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;__la_symbol_ptr&lt;/code&gt;，它们分别是 &lt;em&gt;non-lazy&lt;/em&gt; 和 &lt;em&gt;lazy&lt;/em&gt; 符号指针。延迟符号指针用于可执行文件中调用未定义的函数，例如不包含在可执行文件中的函数，它们将会延迟加载。而针对非延迟符号指针，当可执行文件被加载同时，也会被加载。&lt;/p&gt;
&lt;p&gt;在 &lt;code class=&quot;language-text&quot;&gt;_DATA&lt;/code&gt; segment 中的其它常见 section 包括 &lt;code class=&quot;language-text&quot;&gt;__const&lt;/code&gt;，在这里面会包含一些需要重定向的常量数据。例如 &lt;code class=&quot;language-text&quot;&gt;char * const p = &amp;quot;foo&amp;quot;;&lt;/code&gt; -- &lt;code class=&quot;language-text&quot;&gt;p&lt;/code&gt; 指针指向的数据是可变的。&lt;code class=&quot;language-text&quot;&gt;__bss&lt;/code&gt; section 没有被初始化的静态变量，例如 &lt;code class=&quot;language-text&quot;&gt;static int a;&lt;/code&gt; -- ANSI C 标准规定静态变量必须设置为 0。并且在运行时静态变量的值是可以修改的。&lt;code class=&quot;language-text&quot;&gt;__common&lt;/code&gt; section 包含未初始化的外部全局变量，跟 &lt;code class=&quot;language-text&quot;&gt;static&lt;/code&gt; 变量类似。例如在函数外面定义的 &lt;code class=&quot;language-text&quot;&gt;int a;&lt;/code&gt;。最后，&lt;code class=&quot;language-text&quot;&gt;__dyld&lt;/code&gt; 是一个 section 占位符，被用于动态链接器。&lt;/p&gt;
&lt;p&gt;苹果的 &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/Assembler/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;OS X Assembler Reference&lt;/a&gt; 文档有更多关于 section 类型的介绍。&lt;/p&gt;
&lt;h3 id=&quot;section-中的内容&quot;&gt;&lt;a href=&quot;#section-%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9&quot; aria-label=&quot;section 中的内容 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Section 中的内容&lt;/h3&gt;
&lt;p&gt;下面，我们用 &lt;code class=&quot;language-text&quot;&gt;otool(1)&lt;/code&gt; 来观察一个 section 中的内容：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% xcrun otool -s __TEXT __text a.out 
a.out:
(__TEXT,__text) section
0000000100000f30 55 48 89 e5 48 83 ec 20 48 8d 05 4b 00 00 00 c7 
0000000100000f40 45 fc 00 00 00 00 89 7d f8 48 89 75 f0 48 89 c7 
0000000100000f50 b0 00 e8 11 00 00 00 b9 00 00 00 00 89 45 ec 89 
0000000100000f60 c8 48 83 c4 20 5d c3 &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面是我们 app 中的代码。由于 &lt;code class=&quot;language-text&quot;&gt;-s __TEXT __text&lt;/code&gt; 很常见，&lt;code class=&quot;language-text&quot;&gt;otool&lt;/code&gt; 对其设置了一个缩写 &lt;code class=&quot;language-text&quot;&gt;-t&lt;/code&gt; 。我们还可以通过添加 &lt;code class=&quot;language-text&quot;&gt;-v&lt;/code&gt; 来查看反汇编代码：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% xcrun otool -v -t a.out
a.out:
(__TEXT,__text) section
_main:
0000000100000f30    pushq   %rbp
0000000100000f31    movq    %rsp, %rbp
0000000100000f34    subq    $0x20, %rsp
0000000100000f38    leaq    0x4b(%rip), %rax
0000000100000f3f    movl    $0x0, 0xfffffffffffffffc(%rbp)
0000000100000f46    movl    %edi, 0xfffffffffffffff8(%rbp)
0000000100000f49    movq    %rsi, 0xfffffffffffffff0(%rbp)
0000000100000f4d    movq    %rax, %rdi
0000000100000f50    movb    $0x0, %al
0000000100000f52    callq   0x100000f68
0000000100000f57    movl    $0x0, %ecx
0000000100000f5c    movl    %eax, 0xffffffffffffffec(%rbp)
0000000100000f5f    movl    %ecx, %eax
0000000100000f61    addq    $0x20, %rsp
0000000100000f65    popq    %rbp
0000000100000f66    ret&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的内容是一样的，只不过以反汇编形式显示出来。你应该感觉很熟悉，这就是我们在前面编译时候的代码。唯一的不同就是，在这里我们没有任何的汇编指令在里面。这是纯粹的二进制执行文件。&lt;/p&gt;
&lt;p&gt;同样的方法，我们可以查看别的 section：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% xcrun otool -v -s __TEXT __cstring a.out
a.out:
Contents of (__TEXT,__cstring) section
0x0000000100000f8a  Hello World!\n&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% xcrun otool -v -s __TEXT __eh_frame a.out 
a.out:
Contents of (__TEXT,__eh_frame) section
0000000100000fe0    14 00 00 00 00 00 00 00 01 7a 52 00 01 78 10 01 
0000000100000ff0    10 0c 07 08 90 01 00 00 &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;性能上需要注意的事项&quot;&gt;&lt;a href=&quot;#%E6%80%A7%E8%83%BD%E4%B8%8A%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E9%A1%B9&quot; aria-label=&quot;性能上需要注意的事项 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;性能上需要注意的事项&lt;/h4&gt;
&lt;p&gt;从侧面来讲，&lt;code class=&quot;language-text&quot;&gt;__DATA&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;__TEXT&lt;/code&gt; segment对性能会有所影响。如果你有一个很大的二进制文件，你可能得去看看苹果的文档：&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Performance/Conceptual/CodeFootprint/Articles/MachOOverview.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;关于代码大小性能指南&lt;/a&gt;。将数据移至 &lt;code class=&quot;language-text&quot;&gt;__TEXT&lt;/code&gt; 是个不错的选择，因为这些页从来不会被改变。&lt;/p&gt;
&lt;h4 id=&quot;任意的片段&quot;&gt;&lt;a href=&quot;#%E4%BB%BB%E6%84%8F%E7%9A%84%E7%89%87%E6%AE%B5&quot; aria-label=&quot;任意的片段 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;任意的片段&lt;/h4&gt;
&lt;p&gt;使用链接符号 &lt;code class=&quot;language-text&quot;&gt;-sectcreate&lt;/code&gt; 我们可以给可执行文件以 section 的方式添加任意的数据。这就是如何将一个 Info.plist 文件添加到一个独立的可执行文件中的方法。Info.plist 文件中的数据需要放入到 &lt;code class=&quot;language-text&quot;&gt;__TEXT&lt;/code&gt; segment 里面的一个 &lt;code class=&quot;language-text&quot;&gt;__info_plist&lt;/code&gt; section 中。可以将 &lt;code class=&quot;language-text&quot;&gt;-sectcreate segname sectname file&lt;/code&gt; 传递给链接器（通过将下面的内容传递给 clang）：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;-Wl,-sectcreate,__TEXT,__info_plist,path/to/Info.plist&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样，&lt;code class=&quot;language-text&quot;&gt;-sectalign&lt;/code&gt; 规定了对其方式。如果你添加的是一个全新的 segment，那么需要通过 &lt;code class=&quot;language-text&quot;&gt;-segprot&lt;/code&gt; 来规定 segment 的保护方式 (读/写/可执行)。这些所有内容在链接器的帮助文档中都有，例如 &lt;code class=&quot;language-text&quot;&gt;ld(1)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们可以利用定义在 &lt;code class=&quot;language-text&quot;&gt;/usr/include/mach-o/getsect.h&lt;/code&gt; 中的函数 &lt;code class=&quot;language-text&quot;&gt;getsectdata()&lt;/code&gt; 得到 section，例如 &lt;code class=&quot;language-text&quot;&gt;getsectdata()&lt;/code&gt; 可以得到指向 section 数据的一个指针，并返回相关 section 的长度。&lt;/p&gt;
&lt;h3 id=&quot;mach-o&quot;&gt;&lt;a href=&quot;#mach-o&quot; aria-label=&quot;mach o permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Mach-O&lt;/h3&gt;
&lt;p&gt;在 OS X 和 iOS 中可执行文件的格式为 &lt;a href=&quot;https://en.wikipedia.org/wiki/Mach-o&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Mach-O&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% file a.out 
a.out: Mach-O 64-bit executable x86_64&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于 GUI 程序也是一样的：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% file /Applications/Preview.app/Contents/MacOS/Preview 
/Applications/Preview.app/Contents/MacOS/Preview: Mach-O 64-bit executable x86_64&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于 &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/MachORuntime/index.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Mach-O 文件格式&lt;/a&gt; 苹果有详细的介绍。&lt;/p&gt;
&lt;p&gt;我们可以使用 &lt;code class=&quot;language-text&quot;&gt;otool(1)&lt;/code&gt; 来观察可执行文件的头部 -- 规定了这个文件是什么，以及文件是如何被加载的。通过 &lt;code class=&quot;language-text&quot;&gt;-h&lt;/code&gt; 可以打印出头信息：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% otool -v -h a.out           a.out:
Mach header
      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64  X86_64        ALL LIB64     EXECUTE    16       1296   NOUNDEFS DYLDLINK TWOLEVEL PIE&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;cputype&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;cpusubtype&lt;/code&gt; 规定了这个可执行文件能够运行在哪些目标架构上。&lt;code class=&quot;language-text&quot;&gt;ncmds&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;sizeofcmds&lt;/code&gt; 是加载命令，可以通过 &lt;code class=&quot;language-text&quot;&gt;-l&lt;/code&gt; 来查看这两个加载命令：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% otool -v -l a.out | open -f
a.out:
Load command 0
      cmd LC_SEGMENT_64
  cmdsize 72
  segname __PAGEZERO
   vmaddr 0x0000000000000000
   vmsize 0x0000000100000000
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加载命令规定了文件的逻辑结构和文件在虚拟内存中的布局。&lt;code class=&quot;language-text&quot;&gt;otool&lt;/code&gt; 打印出的大多数信息都是源自这里的加载命令。看一下 &lt;code class=&quot;language-text&quot;&gt;Load command 1&lt;/code&gt; 部分，可以找到 &lt;code class=&quot;language-text&quot;&gt;initprot r-x&lt;/code&gt;，它规定了之前提到的保护方式：只读和可执行。&lt;/p&gt;
&lt;p&gt;对于每一个 segment，以及segment 中的每个 section，加载命令规定了它们在内存中结束的位置，以及保护模式等。例如，下面是 &lt;code class=&quot;language-text&quot;&gt;__TEXT __text&lt;/code&gt; section 的输出内容：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Section
  sectname __text
   segname __TEXT
      addr 0x0000000100000f30
      size 0x0000000000000037
    offset 3888
     align 2^4 (16)
    reloff 0
    nreloc 0
      type S_REGULAR
attributes PURE_INSTRUCTIONS SOME_INSTRUCTIONS
 reserved1 0
 reserved2 0&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码将在 0x100000f30 处结束。它在文件中的偏移量为 3888。如果看一下之前 &lt;code class=&quot;language-text&quot;&gt;xcrun otool -v -t a.out&lt;/code&gt; 输出的反汇编代码，可以发现代码实际位置在 0x100000f30。&lt;/p&gt;
&lt;p&gt;我们同样看看在可执行文件中，动态链接库是如何使用的：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% otool -v -L a.out
a.out:
    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 169.3.0)
    time stamp 2 Thu Jan  1 01:00:02 1970&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面就是我们可执行文件将要找到 &lt;code class=&quot;language-text&quot;&gt;_printf&lt;/code&gt; 符号的地方。&lt;/p&gt;
&lt;h2 id=&quot;一个更复杂的例子&quot;&gt;&lt;a href=&quot;#%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E4%BE%8B%E5%AD%90&quot; aria-label=&quot;一个更复杂的例子 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;一个更复杂的例子&lt;/h2&gt;
&lt;p&gt;我们来看看有三个文件的复杂例子：&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Foo.h&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;

@interface Foo : NSObject

- (void)run;

@end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Foo.m&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#import &amp;quot;Foo.h&amp;quot;

@implementation Foo

- (void)run
{
    NSLog(@&amp;quot;%@&amp;quot;, NSFullUserName());
}

@end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;helloworld.m&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#import &amp;quot;Foo.h&amp;quot;

int main(int argc, char *argv[])
{
    @autoreleasepool {
        Foo *foo = [[Foo alloc] init];
        [foo run];
        return 0;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;编译多个文件&quot;&gt;&lt;a href=&quot;#%E7%BC%96%E8%AF%91%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6&quot; aria-label=&quot;编译多个文件 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;编译多个文件&lt;/h3&gt;
&lt;p&gt;在上面的示例中，有多个源文件。所以我们需要让 clang 对输入每个文件生成对应的目标文件：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% xcrun clang -c Foo.m
% xcrun clang -c helloworld.m&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们从来不编译头文件。头文件的作用就是在被编译的实现文件中对代码做简单的共享。&lt;code class=&quot;language-text&quot;&gt;Foo.m&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;helloworld.m&lt;/code&gt; 都是通过 &lt;code class=&quot;language-text&quot;&gt;#import&lt;/code&gt; 语句将 &lt;code class=&quot;language-text&quot;&gt;Foo.h&lt;/code&gt; 文件中的内容添加到实现文件中的。&lt;/p&gt;
&lt;p&gt;最终得到了两个目标文件：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% file helloworld.o Foo.o
helloworld.o: Mach-O 64-bit object x86_64
Foo.o:        Mach-O 64-bit object x86_64&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了生成一个可执行文件，我们需要将这两个目标文件和 Foundation framework 链接起来：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;xcrun clang helloworld.o Foo.o -Wl,`xcrun --show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在可以运行我们的程序了:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% ./a.out 
2013-11-03 18:03:03.386 a.out[8302:303] Daniel Eggert&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;符号表和链接&quot;&gt;&lt;a href=&quot;#%E7%AC%A6%E5%8F%B7%E8%A1%A8%E5%92%8C%E9%93%BE%E6%8E%A5&quot; aria-label=&quot;符号表和链接 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;符号表和链接&lt;/h3&gt;
&lt;p&gt;我们这个简单的程序是将两个目标文件合并到一起的。&lt;code class=&quot;language-text&quot;&gt;Foo.o&lt;/code&gt; 目标文件包含了 &lt;code class=&quot;language-text&quot;&gt;Foo&lt;/code&gt; 类的实现，而 &lt;code class=&quot;language-text&quot;&gt;helloworld.o&lt;/code&gt; 目标文件包含了 &lt;code class=&quot;language-text&quot;&gt;main()&lt;/code&gt; 函数，以及调用/使用 &lt;code class=&quot;language-text&quot;&gt;Foo&lt;/code&gt; 类。&lt;/p&gt;
&lt;p&gt;另外，这两个目标对象都使用了 Foundation framework。&lt;code class=&quot;language-text&quot;&gt;helloworld.o&lt;/code&gt; 目标文件使用了它的 autorelease pool，并间接的使用了  &lt;code class=&quot;language-text&quot;&gt;libobjc.dylib&lt;/code&gt; 中的 Objective-C 运行时。它需要运行时函数来进行消息的调用。&lt;code class=&quot;language-text&quot;&gt;Foo.o&lt;/code&gt; 目标文件也有类似的原理。&lt;/p&gt;
&lt;p&gt;所有的这些东西都被形象的称之为符号。我们可以把符号看成是一些在运行时将会变成指针的东西。虽然实际上并不是这样的。&lt;/p&gt;
&lt;p&gt;每个函数、全局变量和类等都是通过符号的形式来定义和使用的。当我们将目标文件链接为一个可执行文件时，链接器 (&lt;code class=&quot;language-text&quot;&gt;ld(1)&lt;/code&gt;) 在目标文件盒动态库之间对符号做了解析处理。&lt;/p&gt;
&lt;p&gt;可执行文件和目标文件有一个符号表，这个符号表规定了它们的符号。如果我们用 &lt;code class=&quot;language-text&quot;&gt;nm(1)&lt;/code&gt; 工具观察一下 &lt;code class=&quot;language-text&quot;&gt;helloworld.0&lt;/code&gt; 目标文件，可以看到如下内容：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% xcrun nm -nm helloworld.o
                 (undefined) external _OBJC_CLASS_$_Foo
0000000000000000 (__TEXT,__text) external _main
                 (undefined) external _objc_autoreleasePoolPop
                 (undefined) external _objc_autoreleasePoolPush
                 (undefined) external _objc_msgSend
                 (undefined) external _objc_msgSend_fixup
0000000000000088 (__TEXT,__objc_methname) non-external L_OBJC_METH_VAR_NAME_
000000000000008e (__TEXT,__objc_methname) non-external L_OBJC_METH_VAR_NAME_1
0000000000000093 (__TEXT,__objc_methname) non-external L_OBJC_METH_VAR_NAME_2
00000000000000a0 (__DATA,__objc_msgrefs) weak private external l_objc_msgSend_fixup_alloc
00000000000000e8 (__TEXT,__eh_frame) non-external EH_frame0
0000000000000100 (__TEXT,__eh_frame) external _main.eh&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面就是那个目标文件的所有符号。&lt;code class=&quot;language-text&quot;&gt;_OBJC_CLASS_$_Foo&lt;/code&gt; 是 &lt;code class=&quot;language-text&quot;&gt;Foo&lt;/code&gt; Objective-C 类的符号。该符号是 &lt;em&gt;undefined, external&lt;/em&gt; 。&lt;em&gt;External&lt;/em&gt; 的意思是指对于这个目标文件该类并不是私有的，相反，&lt;code class=&quot;language-text&quot;&gt;non-external&lt;/code&gt; 的符号则表示对于目标文件是私有的。我们的 &lt;code class=&quot;language-text&quot;&gt;helloworld.o&lt;/code&gt; 目标文件引用了类 &lt;code class=&quot;language-text&quot;&gt;Foo&lt;/code&gt;，不过这并没有实现它。因此符号表中将其标示为 undefined。&lt;/p&gt;
&lt;p&gt;接下来是 &lt;code class=&quot;language-text&quot;&gt;_main&lt;/code&gt; 符号，它是表示 &lt;code class=&quot;language-text&quot;&gt;main()&lt;/code&gt; 函数，同样为 &lt;em&gt;external&lt;/em&gt;，这是因为该函数需要被调用，所以应该为可见的。由于在 &lt;code class=&quot;language-text&quot;&gt;helloworld.o&lt;/code&gt; 文件中实现了 这个 main 函数。这个函数地址位于 0处，并且需要转入到  &lt;code class=&quot;language-text&quot;&gt;__TEXT,__text&lt;/code&gt; section。接着是 4 个 Objective-C 运行时函数。它们同样是 undefined的，需要链接器进行符号解析。&lt;/p&gt;
&lt;p&gt;如果我们转而观察 &lt;code class=&quot;language-text&quot;&gt;Foo.o&lt;/code&gt; 目标文件，可以看到如下输出：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% xcrun nm -nm Foo.o
0000000000000000 (__TEXT,__text) non-external -[Foo run]
                 (undefined) external _NSFullUserName
                 (undefined) external _NSLog
                 (undefined) external _OBJC_CLASS_$_NSObject
                 (undefined) external _OBJC_METACLASS_$_NSObject
                 (undefined) external ___CFConstantStringClassReference
                 (undefined) external __objc_empty_cache
                 (undefined) external __objc_empty_vtable
000000000000002f (__TEXT,__cstring) non-external l_.str
0000000000000060 (__TEXT,__objc_classname) non-external L_OBJC_CLASS_NAME_
0000000000000068 (__DATA,__objc_const) non-external l_OBJC_METACLASS_RO_$_Foo
00000000000000b0 (__DATA,__objc_const) non-external l_OBJC_$_INSTANCE_METHODS_Foo
00000000000000d0 (__DATA,__objc_const) non-external l_OBJC_CLASS_RO_$_Foo
0000000000000118 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo
0000000000000140 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo
0000000000000168 (__TEXT,__objc_methname) non-external L_OBJC_METH_VAR_NAME_
000000000000016c (__TEXT,__objc_methtype) non-external L_OBJC_METH_VAR_TYPE_
00000000000001a8 (__TEXT,__eh_frame) non-external EH_frame0
00000000000001c0 (__TEXT,__eh_frame) non-external -[Foo run].eh&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第五行至最后一行显示了 &lt;code class=&quot;language-text&quot;&gt;_OBJC_CLASS_$_Foo&lt;/code&gt; 已经定义了，并且对于 &lt;code class=&quot;language-text&quot;&gt;Foo.o&lt;/code&gt; 是一个外部符号 -- ·Foo.o· 包含了这个类的实现。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Foo.o&lt;/code&gt; 同样有 undefined 的符号。首先是使用了符号 &lt;code class=&quot;language-text&quot;&gt;NSFullUserName()&lt;/code&gt;，&lt;code class=&quot;language-text&quot;&gt;NSLog()&lt;/code&gt;和 &lt;code class=&quot;language-text&quot;&gt;NSObject&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当我们将这两个目标文件和 Foundation framework (是一个动态库) 进行链接处理时，链接器会尝试解析所有的 undefined 符号。它可以解析  &lt;code class=&quot;language-text&quot;&gt;_OBJC_CLASS_$_Foo&lt;/code&gt;。另外，它将使用 Foundation framework。&lt;/p&gt;
&lt;p&gt;当链接器通过动态库 (此处是 Foundation framework) 解析成功一个符号时，它会在最终的链接图中记录这个符号是通过动态库进行解析的。链接器会记录输出文件是依赖于哪个动态链接库，并连同其路径一起进行记录。在我们的例子中，&lt;code class=&quot;language-text&quot;&gt;_NSFullUserName&lt;/code&gt;，&lt;code class=&quot;language-text&quot;&gt;_NSLog&lt;/code&gt;，&lt;code class=&quot;language-text&quot;&gt;_OBJC_CLASS_$_NSObject&lt;/code&gt;，&lt;code class=&quot;language-text&quot;&gt;_objc_autoreleasePoolPop&lt;/code&gt; 等符号都是遵循这个过程。&lt;/p&gt;
&lt;p&gt;我们可以看一下最终可执行文件 &lt;code class=&quot;language-text&quot;&gt;a.out&lt;/code&gt; 的符号表，并注意观察链接器是如何解析所有符号的：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% xcrun nm -nm a.out 
                 (undefined) external _NSFullUserName (from Foundation)
                 (undefined) external _NSLog (from Foundation)
                 (undefined) external _OBJC_CLASS_$_NSObject (from CoreFoundation)
                 (undefined) external _OBJC_METACLASS_$_NSObject (from CoreFoundation)
                 (undefined) external ___CFConstantStringClassReference (from CoreFoundation)
                 (undefined) external __objc_empty_cache (from libobjc)
                 (undefined) external __objc_empty_vtable (from libobjc)
                 (undefined) external _objc_autoreleasePoolPop (from libobjc)
                 (undefined) external _objc_autoreleasePoolPush (from libobjc)
                 (undefined) external _objc_msgSend (from libobjc)
                 (undefined) external _objc_msgSend_fixup (from libobjc)
                 (undefined) external dyld_stub_binder (from libSystem)
0000000100000000 (__TEXT,__text) [referenced dynamically] external __mh_execute_header
0000000100000e50 (__TEXT,__text) external _main
0000000100000ed0 (__TEXT,__text) non-external -[Foo run]
0000000100001128 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo
0000000100001150 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到所有的 Foundation 和 Objective-C 运行时符号依旧是 undefined，不过现在的符号表中已经多了如何解析它们的信息，例如在哪个动态库中可以找到对应的符号。&lt;/p&gt;
&lt;p&gt;可执行文件同样知道去哪里找到所需库：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% xcrun otool -L a.out
a.out:
    /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation (compatibility version 300.0.0, current version 1056.0.0)
    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1197.1.1)
    /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 855.11.0)
    /usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在运行时，动态链接器  &lt;code class=&quot;language-text&quot;&gt;dyld(1)&lt;/code&gt; 可以解析这些 undefined 符号，&lt;code class=&quot;language-text&quot;&gt;dyld&lt;/code&gt; 将会确定好 &lt;code class=&quot;language-text&quot;&gt;_NSFullUserName&lt;/code&gt; 等符号，并指向它们在 Foundation 中的实现等。&lt;/p&gt;
&lt;p&gt;我们可以针对 Foundation 运行 &lt;code class=&quot;language-text&quot;&gt;nm(1)&lt;/code&gt;，并检查这些符号的定义情况： &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% xcrun nm -nm `xcrun --show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation | grep NSFullUserName
0000000000007f3e (__TEXT,__text) external _NSFullUserName &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;动态链接编辑器&quot;&gt;&lt;a href=&quot;#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%BC%96%E8%BE%91%E5%99%A8&quot; aria-label=&quot;动态链接编辑器 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;动态链接编辑器&lt;/h3&gt;
&lt;p&gt;有一些环境变量对于 &lt;code class=&quot;language-text&quot;&gt;dyld&lt;/code&gt; 的输出信息非常有用。首先，如果设置了 &lt;code class=&quot;language-text&quot;&gt;DYLD_PRINT_LIBRARIES&lt;/code&gt;，那么 &lt;code class=&quot;language-text&quot;&gt;dyld&lt;/code&gt; 将会打印出什么库被加载了：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% (export DYLD_PRINT_LIBRARIES=; ./a.out )
dyld: loaded: /Users/deggert/Desktop/command_line/./a.out
dyld: loaded: /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation
dyld: loaded: /usr/lib/libSystem.B.dylib
dyld: loaded: /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation
dyld: loaded: /usr/lib/libobjc.A.dylib
dyld: loaded: /usr/lib/libauto.dylib
[...]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面将会显示出在加载 Foundation 时，同时会加载的 70 个动态库。这是由于 Foundation 依赖于另外一些动态库。运行下面的命令：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% xcrun otool -L `xcrun --show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到 Foundation 使用了 15 个动态库。&lt;/p&gt;
&lt;h3 id=&quot;dyld-的共享缓存&quot;&gt;&lt;a href=&quot;#dyld-%E7%9A%84%E5%85%B1%E4%BA%AB%E7%BC%93%E5%AD%98&quot; aria-label=&quot;dyld 的共享缓存 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;dyld 的共享缓存&lt;/h3&gt;
&lt;p&gt;当你构建一个真正的程序时，将会链接各种各样的库。它们又会依赖其他一些 framework 和 动态库。需要加载的动态库会非常多。而对于相互依赖的符号就更多了。可能将会有上千个符号需要解析处理，这将花费很长的时间：一般是好几秒钟。&lt;/p&gt;
&lt;p&gt;为了缩短这个处理过程所花费时间，在 OS X 和 iOS 上的动态链接器使用了共享缓存，共享缓存存于 &lt;code class=&quot;language-text&quot;&gt;/var/db/dyld/&lt;/code&gt;。对于每一种架构，操作系统都有一个单独的文件，文件中包含了绝大多数的动态库，这些库都已经链接为一个文件，并且已经处理好了它们之间的符号关系。当加载一个 Mach-O 文件 (一个可执行文件或者一个库) 时，动态链接器首先会检查 &lt;em&gt;共享缓存&lt;/em&gt; 看看是否存在其中，如果存在，那么就直接从共享缓存中拿出来使用。每一个进程都把这个共享缓存映射到了自己的地址空间中。这个方法大大优化了 OS X 和 iOS 上程序的启动时间。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[JavaScript 执行机制]]></title><description><![CDATA[1.关于javascript javascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的"多线程"都是用单线程模拟出来的，一切javascript多线程都是纸老虎！…]]></description><link>https://lizhi1026.cc/2017/11-20/javascript-run-loop-ics</link><guid isPermaLink="false">https://lizhi1026.cc/2017/11-20/javascript-run-loop-ics</guid><pubDate>Mon, 20 Nov 2017 00:00:00 GMT</pubDate><content:encoded>&lt;h3 id=&quot;1关于javascript&quot;&gt;&lt;a href=&quot;#1%E5%85%B3%E4%BA%8Ejavascript&quot; aria-label=&quot;1关于javascript permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1.关于javascript&lt;/h3&gt;
&lt;p&gt;javascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的&quot;多线程&quot;都是用单线程模拟出来的，一切javascript多线程都是纸老虎！&lt;/p&gt;
&lt;h3 id=&quot;2javascript事件循环&quot;&gt;&lt;a href=&quot;#2javascript%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF&quot; aria-label=&quot;2javascript事件循环 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2.javascript事件循环&lt;/h3&gt;
&lt;p&gt;既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步任务&lt;/li&gt;
&lt;li&gt;异步任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明：&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1200px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 83.65384615384615%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsSAAALEgHS3X78AAACOUlEQVQ4y3VT23LTQAzt/w88wC/AF8BMH2hTpgO02CVJaS5OmjQOduw4tmPvxXvxbRfFGYITwo4e1tI5Wh1JvqhbRyudyayP+n36aESmGZtd1O1lfZesdK2rugJMVVUH/MUJmQhiINPMHm7Xt2B36b3BTBsvz5Ph3ra6VmVZK60zzhFjWuuyqlWlDoCyrA73o5fh5HkuuSCOG1x3/A8f07ElMAZnURR7wJmywaWUYoxtkwQnyfLy0nvzNnj12n73fjOfMyHCzQZSAOZ/ZE0IwYRAqVC2pBmPorq5w6GECi5A1PmGASKXkmV0R653ucDV+CvwME5BkG48Rw0DcLAlwxXtzjbfx6uRx/yIqCbMMuGOkDskg7tf817oDmjkYcDvnwcyJFZeiHo2MqdA9ns2cTcIXgeFGRWLx8TuI8vwZz+iRRcFTvqXvC9A7YZcF7kUnENMtWpTWpV1EW8jTNFOUCt2pFlKQWnTsPbmALkq/LWXouQ48kdzmNAnOzZGy/unxWCZBDForhrN3BmnzghZpvvyGDpDHPknmlXtx7g7j42xZ1he30brLd3PSPDcHWFnQAbfnOlDsPyJw1WLDF0BmGqmWRaFYAykF0JKLjnjsDYiZ7LgKU5gyU7L5lLgDBNOqcgiFM8WM8d3EpKGSYQIFkJyLjiDZPmZ3X7Bi5v085V/fR10PvlXnU3nJtp9fmFf53gOi7KbmNLNFv6z22EWWmhiJZNJY8/oeZJOra01JdOABqrSrR/ulPwbswbF/Hmh1bMAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;EventQueue&quot;
        title=&quot;EventQueue&quot;
        src=&quot;/static/e761e7e868e9268921dadd66a3f4091d/6ff5e/EventQueue.png&quot;
        srcset=&quot;/static/e761e7e868e9268921dadd66a3f4091d/135ae/EventQueue.png 300w,
/static/e761e7e868e9268921dadd66a3f4091d/34e8a/EventQueue.png 600w,
/static/e761e7e868e9268921dadd66a3f4091d/6ff5e/EventQueue.png 1200w,
/static/e761e7e868e9268921dadd66a3f4091d/005f0/EventQueue.png 1456w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;导图要表达的内容用文字来表述的话：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步和异步任务分别进入不同的执行&quot;场所&quot;，同步的进入主线程，异步的进入Event Table并注册函数&lt;/li&gt;
&lt;li&gt;当指定的事情完成时，Event Table会将这个函数移入Event Queue&lt;/li&gt;
&lt;li&gt;主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行&lt;/li&gt;
&lt;li&gt;上述过程会不断重复，也就是常说的Event Loop(事件循环)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数&lt;/p&gt;
&lt;p&gt;说了这么多文字，不如直接一段代码更直白:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; data &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
$&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;ajax&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    url&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;www&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;javascript&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;com&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    data&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token function-variable function&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;发送成功!&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;代码执行结束&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面是一段简易的&lt;code class=&quot;language-text&quot;&gt;ajax&lt;/code&gt;请求代码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ajax进入Event Table，注册回调函数&lt;code class=&quot;language-text&quot;&gt;success&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行&lt;code class=&quot;language-text&quot;&gt;console.log(&amp;#39;代码执行结束&amp;#39;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ajax事件完成，回调函数&lt;code class=&quot;language-text&quot;&gt;success&lt;/code&gt;进入Event Queue&lt;/li&gt;
&lt;li&gt;主线程从Event Queue读取回调函数&lt;code class=&quot;language-text&quot;&gt;success&lt;/code&gt;并执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：setTimeout.&lt;/p&gt;
&lt;h3 id=&quot;3又爱又恨的settimeout&quot;&gt;&lt;a href=&quot;#3%E5%8F%88%E7%88%B1%E5%8F%88%E6%81%A8%E7%9A%84settimeout&quot; aria-label=&quot;3又爱又恨的settimeout permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3.又爱又恨的setTimeout&lt;/h3&gt;
&lt;p&gt;大名鼎鼎的&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;延时3秒&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;渐渐的&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？&lt;/p&gt;
&lt;p&gt;先看一个例子：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;执行console&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据前面我们的结论，&lt;code class=&quot;language-text&quot;&gt;setTimeou&lt;/code&gt;t是异步的，应该先执行&lt;code class=&quot;language-text&quot;&gt;console.log&lt;/code&gt;这个同步任务，所以我们的结论是：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;//执行console
//task()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;去验证一下，结果正确！
然后我们修改一下前面的代码：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;10000000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？&lt;/p&gt;
&lt;p&gt;这时候我们需要重新理解&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;的定义。我们先说上述代码是怎么执行的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;task()&lt;/code&gt;进入Event Table并注册,计时开始&lt;/li&gt;
&lt;li&gt;执行&lt;code class=&quot;language-text&quot;&gt;sleep&lt;/code&gt;函数，很慢，非常慢，计时仍在继续&lt;/li&gt;
&lt;li&gt;3秒到了，计时事件&lt;code class=&quot;language-text&quot;&gt;timeout&lt;/code&gt;完成，&lt;code class=&quot;language-text&quot;&gt;task()&lt;/code&gt;进入Event Queue，但是&lt;code class=&quot;language-text&quot;&gt;sleep&lt;/code&gt;也太慢了吧，还没执行完，只好等着&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;sleep&lt;/code&gt;终于执行完了，&lt;code class=&quot;language-text&quot;&gt;task()&lt;/code&gt;终于从Event Queue进入了主线程执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述的流程走完，我们知道&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;这个函数，是经过指定时间后，把要执行的任务(本例中为&lt;code class=&quot;language-text&quot;&gt;task()&lt;/code&gt;)加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。&lt;/p&gt;
&lt;p&gt;我们还经常遇到&lt;code class=&quot;language-text&quot;&gt;setTimeout(fn,0)&lt;/code&gt;这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？&lt;/p&gt;
&lt;p&gt;答案是不会的，&lt;code class=&quot;language-text&quot;&gt;setTimeout(fn,0)&lt;/code&gt;的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;//代码1&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;先执行这里&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;执行啦&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;//代码2
console.log(&amp;#39;先执行这里&amp;#39;);
setTimeout(() =&amp;gt; {
    console.log(&amp;#39;执行啦&amp;#39;)
},3000);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码1的输出结果是：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;//先执行这里
//执行啦&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码2的输出结果是：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;//先执行这里
// ... 3s later
// 执行啦&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。&lt;/p&gt;
&lt;h3 id=&quot;4又恨又爱的setinterval&quot;&gt;&lt;a href=&quot;#4%E5%8F%88%E6%81%A8%E5%8F%88%E7%88%B1%E7%9A%84setinterval&quot; aria-label=&quot;4又恨又爱的setinterval permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4.又恨又爱的setInterval&lt;/h3&gt;
&lt;p&gt;上面说完了&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;，当然不能错过它的孪生兄弟&lt;code class=&quot;language-text&quot;&gt;setInterval&lt;/code&gt;。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，&lt;code class=&quot;language-text&quot;&gt;setInterval&lt;/code&gt;会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。&lt;/p&gt;
&lt;p&gt;唯一需要注意的一点是，对于&lt;code class=&quot;language-text&quot;&gt;setInterval(fn,ms)&lt;/code&gt;来说，我们已经知道不是每过&lt;code class=&quot;language-text&quot;&gt;ms&lt;/code&gt;秒会执行一次&lt;code class=&quot;language-text&quot;&gt;fn&lt;/code&gt;，&lt;strong&gt;而是每过&lt;code class=&quot;language-text&quot;&gt;ms&lt;/code&gt;秒，会有&lt;code class=&quot;language-text&quot;&gt;fn&lt;/code&gt;进入Event Queue。一旦&lt;code class=&quot;language-text&quot;&gt;setInterval&lt;/code&gt; 的回调函数fn执行时间超过了延迟时间&lt;code class=&quot;language-text&quot;&gt;ms&lt;/code&gt;&lt;/strong&gt;，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。&lt;/p&gt;
&lt;h3 id=&quot;5promise与processnexttickcallback&quot;&gt;&lt;a href=&quot;#5promise%E4%B8%8Eprocessnexttickcallback&quot; aria-label=&quot;5promise与processnexttickcallback permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5.Promise与process.nextTick(callback)&lt;/h3&gt;
&lt;p&gt;传统的定时器我们已经研究过了，接着我们探究&lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt;与&lt;code class=&quot;language-text&quot;&gt;process.nextTick(callback)&lt;/code&gt;的表现。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt;的定义和功能本文不再赘述，不了解的读者可以学习一下阮一峰老师的&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/promise&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Promise&lt;/a&gt;。而&lt;code class=&quot;language-text&quot;&gt;process.nextTick(callback)&lt;/code&gt;类似node.js版的&quot;setTimeout&quot;，在事件循环的下一次循环中调用 callback 回调函数。&lt;/p&gt;
&lt;p&gt;我们进入正题，除了广义的同步任务和异步任务，我们对任务有更精细的定义:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;macro-task(宏任务)：包括整体代码script，setTimeout，setInterval&lt;/li&gt;
&lt;li&gt;micro-task(微任务)：Promise，process.nextTick&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同类型的任务会进入对应的Event Queue，比如&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;和&lt;code class=&quot;language-text&quot;&gt;setInterval&lt;/code&gt;会进入相同的Event Queue。&lt;/p&gt;
&lt;p&gt;事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用文章最开始的一段代码说明：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;setTimeout&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;promise&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;then&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;console&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;这段代码作为宏任务，进入主线程。&lt;/li&gt;
&lt;li&gt;先遇到&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述)&lt;/li&gt;
&lt;li&gt;接下来遇到了&lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt;，&lt;code class=&quot;language-text&quot;&gt;new Promise&lt;/code&gt;立即执行，&lt;code class=&quot;language-text&quot;&gt;then&lt;/code&gt;函数分发到微任务Event Queue。遇到&lt;code class=&quot;language-text&quot;&gt;console.log()&lt;/code&gt;，立即执行。&lt;/li&gt;
&lt;li&gt;好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了&lt;code class=&quot;language-text&quot;&gt;then&lt;/code&gt;在微任务Event Queue里面，执行。&lt;/li&gt;
&lt;li&gt;ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;对应的回调函数，立即执行。&lt;/li&gt;
&lt;li&gt;结束.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事件循环，宏任务，微任务的关系如图所示：
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1200px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 83.78746594005449%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsSAAALEgHS3X78AAABuUlEQVQ4y41TaU+DQBD1//8jTaz6RY1XYoxoa6rSFkqhsMzucuwB9cFG1NpGJ03zdnfeHG+Gg7Zt67o2xjS/zTRaNUZ30Frr7gYAOwBZCKG1Ht50b1VZL9nbgj8u8uecZ0Ybd/89+A8yMOecKC8KuY7T8epyIkfj/NRfTKUo4EZEZVnCzeXfJgPjAQAnUbEgma55qLXa9AY3KSXA7szAXf9tY40VJZtFk4TCWlWICGmKomCMKaWcRjvIwABaWZ/uPXb0zE5IpsbYNE3BDMMwyzLw4bOXbLRd0ft7dj9nniiobVpXNpJvl42SfpTdG5yi5aqqlfPGPxJC0S/BcJXnue/7OAMjMMgAUHZ+exsej2ZnZ9Hrq8SDlFAbgm2r7TLjAS252HCNPC85v1heXa+DoP60vUtSVVUcx8gxlE3ooq/INdWPcM+SDGX3o2pas0kTpkrTGHDs7/XdrXaXU2YBf5qEN7PsIaI3jP1fZCdYJsIXeTIWoyc69OkOk2vav8hQHtsLPqN0kU782Iv4NOHBd52+yF2FRBigI0NwqC06w2RKnkurIcDG7usZIg+LgaP7BnrQ/Xqp7M7MH24k1/S6qr7pAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;process&quot;
        title=&quot;process&quot;
        src=&quot;/static/c8221a1ed40d5f993b71c0e25412ff97/6ff5e/process.png&quot;
        srcset=&quot;/static/c8221a1ed40d5f993b71c0e25412ff97/135ae/process.png 300w,
/static/c8221a1ed40d5f993b71c0e25412ff97/34e8a/process.png 600w,
/static/c8221a1ed40d5f993b71c0e25412ff97/6ff5e/process.png 1200w,
/static/c8221a1ed40d5f993b71c0e25412ff97/f3171/process.png 1468w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;1&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;2&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    process&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;nextTick&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;3&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;4&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token function&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;5&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
process&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;nextTick&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;6&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;7&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;8&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;9&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    process&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;nextTick&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;10&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;11&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token function&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;12&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一轮事件循环流程分析如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整体script作为第一个宏任务进入主线程，遇到&lt;code class=&quot;language-text&quot;&gt;console.log&lt;/code&gt;，输出1。&lt;/li&gt;
&lt;li&gt;遇到&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;，其回调函数被分发到宏任务Event Queue中。我们暂且记为&lt;code class=&quot;language-text&quot;&gt;setTimeout1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;遇到&lt;code class=&quot;language-text&quot;&gt;process.nextTick()&lt;/code&gt;，其回调函数被分发到微任务Event Queue中。我们记为&lt;code class=&quot;language-text&quot;&gt;process1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;遇到&lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt;，&lt;code class=&quot;language-text&quot;&gt;new Promise&lt;/code&gt;直接执行，输出7。&lt;code class=&quot;language-text&quot;&gt;then&lt;/code&gt;被分发到微任务Event Queue中。我们记为&lt;code class=&quot;language-text&quot;&gt;then1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;又遇到了&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;，其回调函数被分发到宏任务Event Queue中，我们记为&lt;code class=&quot;language-text&quot;&gt;setTimeout2&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;宏任务Event Queue&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;微任务Event Queue&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;setTimeout1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;process1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;setTimeout2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;then1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7&lt;/li&gt;
&lt;li&gt;我们发现了&lt;code class=&quot;language-text&quot;&gt;process1&lt;/code&gt;和&lt;code class=&quot;language-text&quot;&gt;then1&lt;/code&gt;两个微任务&lt;/li&gt;
&lt;li&gt;执行&lt;code class=&quot;language-text&quot;&gt;process1&lt;/code&gt;,输出6。&lt;/li&gt;
&lt;li&gt;执行&lt;code class=&quot;language-text&quot;&gt;then1&lt;/code&gt;，输出8。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从&lt;code class=&quot;language-text&quot;&gt;setTimeout1&lt;/code&gt;宏任务开始：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先输出2。接下来遇到了&lt;code class=&quot;language-text&quot;&gt;process.nextTick()&lt;/code&gt;，同样将其分发到微任务Event Queue中，记为&lt;code class=&quot;language-text&quot;&gt;process2&lt;/code&gt;。&lt;code class=&quot;language-text&quot;&gt;new Promise&lt;/code&gt;立即执行输出4，&lt;code class=&quot;language-text&quot;&gt;then&lt;/code&gt;也分发到微任务Event Queue中，记为&lt;code class=&quot;language-text&quot;&gt;then2&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;宏任务Event Queue&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;微任务Event Queue&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;setTimeout2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;process2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;then2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。&lt;/li&gt;
&lt;li&gt;输出3。&lt;/li&gt;
&lt;li&gt;输出5。&lt;/li&gt;
&lt;li&gt;第二轮事件循环结束，第二轮输出2，4，3，5。&lt;/li&gt;
&lt;li&gt;第三轮事件循环开始，此时只剩setTimeout2了，执行。&lt;/li&gt;
&lt;li&gt;直接输出9。&lt;/li&gt;
&lt;li&gt;将process.nextTick()分发到微任务Event Queue中。记为process3。&lt;/li&gt;
&lt;li&gt;直接执行new Promise，输出11。&lt;/li&gt;
&lt;li&gt;将then分发到微任务Event Queue中，记为then3。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;宏任务Event Queue&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;微任务Event Queue&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;process3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;then3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。&lt;/li&gt;
&lt;li&gt;输出10。&lt;/li&gt;
&lt;li&gt;输出12。&lt;/li&gt;
&lt;li&gt;第三轮事件循环结束，第三轮输出9，11，10，12。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。
(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)&lt;/p&gt;
&lt;h3 id=&quot;6写在最后&quot;&gt;&lt;a href=&quot;#6%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E&quot; aria-label=&quot;6写在最后 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6.写在最后&lt;/h3&gt;
&lt;h4 id=&quot;1js的异步&quot;&gt;&lt;a href=&quot;#1js%E7%9A%84%E5%BC%82%E6%AD%A5&quot; aria-label=&quot;1js的异步 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;(1)js的异步&lt;/h4&gt;
&lt;p&gt;我们从最开头就说javascript是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。&lt;/p&gt;
&lt;h4 id=&quot;2事件循环event-loop&quot;&gt;&lt;a href=&quot;#2%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFevent-loop&quot; aria-label=&quot;2事件循环event loop permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;(2)事件循环Event Loop&lt;/h4&gt;
&lt;p&gt;事件循环是js实现异步的一种方法，也是js的执行机制。&lt;/p&gt;
&lt;h4 id=&quot;3javascript的执行和运行&quot;&gt;&lt;a href=&quot;#3javascript%E7%9A%84%E6%89%A7%E8%A1%8C%E5%92%8C%E8%BF%90%E8%A1%8C&quot; aria-label=&quot;3javascript的执行和运行 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;(3)javascript的执行和运行&lt;/h4&gt;
&lt;p&gt;执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。&lt;/p&gt;
&lt;h4 id=&quot;4setimmediate&quot;&gt;&lt;a href=&quot;#4setimmediate&quot; aria-label=&quot;4setimmediate permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;(4)setImmediate&lt;/h4&gt;
&lt;p&gt;微任务和宏任务还有很多种类，比如&lt;code class=&quot;language-text&quot;&gt;setImmediate&lt;/code&gt;等等，执行都是有共同点的，有兴趣的同学可以自行了解。&lt;/p&gt;
&lt;h4 id=&quot;5最后的最后&quot;&gt;&lt;a href=&quot;#5%E6%9C%80%E5%90%8E%E7%9A%84%E6%9C%80%E5%90%8E&quot; aria-label=&quot;5最后的最后 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;(5)最后的最后&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;javascript是一门单线程语言&lt;/li&gt;
&lt;li&gt;Event Loop是javascript的执行机制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;牢牢把握两个基本点，以认真学习javascript为中心，早日实现成为前端高手的伟大梦想！&lt;/p&gt;</content:encoded></item><item><title><![CDATA[iOS编译器]]></title><description><![CDATA[编译器做些什么？ 本文主要探讨一下编译器主要做些什么，以及如何有效的利用编译器。 简单的说，编译器有两个职责：把 Objective-C 代码转化成低级代码，以及对代码做分析，确保代码中没有任何明显的错误。 现在，Xcode 的默认编译器是 clang…]]></description><link>https://lizhi1026.cc/2016/06-04/ios-complie-ics</link><guid isPermaLink="false">https://lizhi1026.cc/2016/06-04/ios-complie-ics</guid><pubDate>Sat, 04 Jun 2016 00:00:00 GMT</pubDate><content:encoded>&lt;h2 id=&quot;编译器做些什么？&quot;&gt;&lt;a href=&quot;#%E7%BC%96%E8%AF%91%E5%99%A8%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F&quot; aria-label=&quot;编译器做些什么？ permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;编译器做些什么？&lt;/h2&gt;
&lt;p&gt;本文主要探讨一下编译器主要做些什么，以及如何有效的利用编译器。&lt;/p&gt;
&lt;p&gt;简单的说，编译器有两个职责：把 Objective-C 代码转化成低级代码，以及对代码做分析，确保代码中没有任何明显的错误。&lt;/p&gt;
&lt;p&gt;现在，Xcode 的默认编译器是 clang。本文中我们提到的编译器都表示 clang。clang 的功能是首先对 Objective-C 代码做分析检查，然后将其转换为低级的类汇编代码：LLVM Intermediate Representation(LLVM 中间表达码)。接着 LLVM 会执行相关指令将 LLVM IR 编译成目标平台上的本地字节码，这个过程的完成方式可以是即时编译 (Just-in-time)，或在编译的时候完成。&lt;/p&gt;
&lt;p&gt;LLVM 指令的一个好处就是可以在支持 LLVM 的任意平台上生成和运行 LLVM 指令。例如，你写的一个 iOS app, 它可以自动的运行在两个完全不同的架构(Inter 和 ARM)上，LLVM 会根据不同的平台将 IR 码转换为对应的本地字节码。&lt;/p&gt;
&lt;p&gt;LLVM 的优点主要得益于它的三层式架构 -- 第一层支持多种语言作为输入(例如 C, ObjectiveC, C++ 和 Haskell)，第二层是一个共享式的优化器(对 LLVM IR 做优化处理)，第三层是许多不同的目标平台(例如 Intel, ARM 和 PowerPC)。在这三层式的架构中，如果你想要添加一门语言到 LLVM 中，那么可以把重要精力集中到第一层上，如果想要增加另外一个目标平台，那么你没必要过多的考虑输入语言。在书 &lt;em&gt;The Architecture of Open Source Applications&lt;/em&gt; 中 LLVM 的创建者 (Chris Lattner) 写了一章很棒的内容：关于 &lt;a href=&quot;http://www.aosabook.org/en/llvm.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;LLVM 架构&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在编译一个源文件时，编译器的处理过程分为几个阶段。要想查看编译 &lt;em&gt;hello.m&lt;/em&gt; 源文件需要几个不同的阶段，我们可以让通过 clang 命令观察：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;% clang -ccc-print-phases hello.m

0: input, &amp;quot;hello.m&amp;quot;, objective-c
1: preprocessor, {0}, objective-c-cpp-output
2: compiler, {1}, assembler
3: assembler, {2}, object
4: linker, {3}, image
5: bind-arch, &amp;quot;x86_64&amp;quot;, {4}, image&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本文我们将重点关注第一阶段和第二阶段。在文章 &lt;a href=&quot;http://objccn.io/issue-6-3/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Mach-O Executables&lt;/a&gt; 中，Daniel 会对第三阶段和第四阶段进行阐述。&lt;/p&gt;
&lt;h3 id=&quot;预处理&quot;&gt;&lt;a href=&quot;#%E9%A2%84%E5%A4%84%E7%90%86&quot; aria-label=&quot;预处理 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;预处理&lt;/h3&gt;
&lt;p&gt;每当编源译文件的时候，编译器首先做的是一些预处理工作。比如预处理器会处理源文件中的宏定义，将代码中的宏用其对应定义的具体内容进行替换。&lt;/p&gt;
&lt;p&gt;例如，如果在源文件中出现下述代码：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;预处理器对这行代码的处理是用 Foundation.h 文件中的内容去替换这行代码，如果 Foundation.h 中也使用了类似的宏引入，则会按照同样的处理方式用各个宏对应的真正代码进行逐级替代。&lt;/p&gt;
&lt;p&gt;这也就是为什么人们主张头文件最好尽量少的去引入其他的类或库，因为引入的东西越多，编译器需要做的处理就越多。例如，在头文件中用：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;@class MyClass;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代替：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#import &amp;quot;MyClass.h&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这么写是告诉编译器 MyClass 是一个类，并且在 .m 实现文件中可以通过 import &lt;code class=&quot;language-text&quot;&gt;MyClass.h&lt;/code&gt; 的方式来使用它。&lt;/p&gt;
&lt;p&gt;假设我们写了一个简单的 C 程序 &lt;code class=&quot;language-text&quot;&gt;hello.c&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
  printf(&amp;quot;hello world\n&amp;quot;);
  return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后给上面的代码执行以下预处理命令，看看是什么效果：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;clang -E hello.c | less&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来看看处理后的代码，一共是 401 行。如果将如下一行代码添加到上面代码的顶部：：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再执行一下上面的预处理命令，处理后的文件代码行数暴增至 89,839 行。这个数字比某些操作系统的总代码行数还要多。&lt;/p&gt;
&lt;p&gt;幸好，目前的情况已经改善许多了：引入了&lt;a href=&quot;http://clang.llvm.org/docs/Modules.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;模块 - modules&lt;/a&gt;功能，这使预处理变得更加的高级。&lt;/p&gt;
&lt;h4 id=&quot;自定义宏&quot;&gt;&lt;a href=&quot;#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%8F&quot; aria-label=&quot;自定义宏 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;自定义宏&lt;/h4&gt;
&lt;p&gt;我们来看看另外一种情形定义或者使用自定义宏，比如定义了如下宏：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#define MY_CONSTANT 4&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么，凡是在此行宏定义作用域内，输入了 &lt;code class=&quot;language-text&quot;&gt;MY_CONSTANT&lt;/code&gt;，在预处理过程中 &lt;code class=&quot;language-text&quot;&gt;MY_CONSTANT&lt;/code&gt; 都会被替换成 &lt;code class=&quot;language-text&quot;&gt;4&lt;/code&gt;。我们定义的宏也是可以携带参数的， 比如：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#define MY_MACRO(x) x&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;鉴于本文的内容所限，就不对强大的预处理做更多、更全面的展开讨论了。但是还是要强调一点，建议大家不要在需要预处理的代码中加入内联代码逻辑。&lt;/p&gt;
&lt;p&gt;例如，下面这段代码，这样用没什么问题：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#define MAX(a,b) a &amp;gt; b ? a : b

int main() {
  printf(&amp;quot;largest: %d\n&amp;quot;, MAX(10,100));
  return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是如果换成这么写：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#define MAX(a,b) a &amp;gt; b ? a : b

int main() {
  int i = 200;
  printf(&amp;quot;largest: %d\n&amp;quot;, MAX(i++,100));
  printf(&amp;quot;i: %d\n&amp;quot;, i);
  return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用 &lt;code class=&quot;language-text&quot;&gt;clang max.c&lt;/code&gt; 编译一下，结果是：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;largest: 201
i: 202&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用 &lt;code class=&quot;language-text&quot;&gt;clang -E max.c&lt;/code&gt; 进行宏展开的预处理结果是如下所示：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;int main() {
  int i = 200;
  printf(&amp;quot;largest: %d\n&amp;quot;, i++ &amp;gt; 100 ? i++ : 100);
  printf(&amp;quot;i: %d\n&amp;quot;, i);
  return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本例是典型的宏使用不当，而且通常这类问题非常隐蔽且难以 debug 。针对本例这类情况，最好使用 &lt;code class=&quot;language-text&quot;&gt;static inline&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
static const int MyConstant = 200;

static inline int max(int l, int r) {
   return l &amp;gt; r ? l : r;
}

int main() {
  int i = MyConstant;
  printf(&amp;quot;largest: %d\n&amp;quot;, max(i++,100));
  printf(&amp;quot;i: %d\n&amp;quot;, i);
  return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样改过之后，就可以输出正常的结果 (&lt;code class=&quot;language-text&quot;&gt;i:201&lt;/code&gt;)。因为这里定义的代码是内联的 (inlined)，所以它的效率和宏变量差不多，但是可靠性比宏定义要好许多。再者，还可以设置断点、类型检查以及避免异常行为。&lt;/p&gt;
&lt;p&gt;基本上，宏的最佳使用场景是日志输出，可以使用 &lt;code class=&quot;language-text&quot;&gt;__FILE__&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;__LINE__&lt;/code&gt; 和 assert 宏。&lt;/p&gt;
&lt;h3 id=&quot;词法解析标记&quot;&gt;&lt;a href=&quot;#%E8%AF%8D%E6%B3%95%E8%A7%A3%E6%9E%90%E6%A0%87%E8%AE%B0&quot; aria-label=&quot;词法解析标记 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;词法解析标记&lt;/h3&gt;
&lt;p&gt;预处理完成以后，每一个 &lt;code class=&quot;language-text&quot;&gt;.m&lt;/code&gt; 源文件里都有一堆的声明和定义。这些代码文本都会从 string 转化成特殊的标记流。&lt;/p&gt;
&lt;p&gt;例如，下面是一段简单的 Objective-C hello word 程序：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;int main() {
  NSLog(@&amp;quot;hello, %@&amp;quot;, @&amp;quot;world&amp;quot;);
  return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;利用 clang 命令 &lt;code class=&quot;language-text&quot;&gt;clang -Xclang -dump-tokens hello.m&lt;/code&gt; 来将上面代码的标记流导出：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;int &amp;#39;int&amp;#39;        [StartOfLine]  Loc=&amp;lt;hello.m:4:1&amp;gt;
identifier &amp;#39;main&amp;#39;        [LeadingSpace] Loc=&amp;lt;hello.m:4:5&amp;gt;
l_paren &amp;#39;(&amp;#39;             Loc=&amp;lt;hello.m:4:9&amp;gt;
r_paren &amp;#39;)&amp;#39;             Loc=&amp;lt;hello.m:4:10&amp;gt;
l_brace &amp;#39;{&amp;#39;      [LeadingSpace] Loc=&amp;lt;hello.m:4:12&amp;gt;
identifier &amp;#39;NSLog&amp;#39;       [StartOfLine] [LeadingSpace]   Loc=&amp;lt;hello.m:5:3&amp;gt;
l_paren &amp;#39;(&amp;#39;             Loc=&amp;lt;hello.m:5:8&amp;gt;
at &amp;#39;@&amp;#39;          Loc=&amp;lt;hello.m:5:9&amp;gt;
string_literal &amp;#39;&amp;quot;hello, %@&amp;quot;&amp;#39;            Loc=&amp;lt;hello.m:5:10&amp;gt;
comma &amp;#39;,&amp;#39;               Loc=&amp;lt;hello.m:5:21&amp;gt;
at &amp;#39;@&amp;#39;   [LeadingSpace] Loc=&amp;lt;hello.m:5:23&amp;gt;
string_literal &amp;#39;&amp;quot;world&amp;quot;&amp;#39;                Loc=&amp;lt;hello.m:5:24&amp;gt;
r_paren &amp;#39;)&amp;#39;             Loc=&amp;lt;hello.m:5:31&amp;gt;
semi &amp;#39;;&amp;#39;                Loc=&amp;lt;hello.m:5:32&amp;gt;
return &amp;#39;return&amp;#39;  [StartOfLine] [LeadingSpace]   Loc=&amp;lt;hello.m:6:3&amp;gt;
numeric_constant &amp;#39;0&amp;#39;     [LeadingSpace] Loc=&amp;lt;hello.m:6:10&amp;gt;
semi &amp;#39;;&amp;#39;                Loc=&amp;lt;hello.m:6:11&amp;gt;
r_brace &amp;#39;}&amp;#39;      [StartOfLine]  Loc=&amp;lt;hello.m:7:1&amp;gt;
eof &amp;#39;&amp;#39;          Loc=&amp;lt;hello.m:7:2&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;仔细观察可以发现，每一个标记都包含了对应的源码内容和其在源码中的位置。注意这里的位置是宏展开之前的位置，这样一来，如果编译过程中遇到什么问题，clang 能够在源码中指出出错的具体位置。&lt;/p&gt;
&lt;h3 id=&quot;解析&quot;&gt;&lt;a href=&quot;#%E8%A7%A3%E6%9E%90&quot; aria-label=&quot;解析 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;解析&lt;/h3&gt;
&lt;p&gt;接下来要说的东西比较有意思：之前生成的标记流将会被解析成一棵抽象语法树 (abstract syntax tree -- AST)。由于 Objective-C 是一门复杂的语言，因此解析的过程不简单。解析过后，源程序变成了一棵抽象语法树：一棵代表源程序的树。假设我们有一个程序 &lt;code class=&quot;language-text&quot;&gt;hello.m&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;

@interface World
- (void)hello;
@end

@implementation World
- (void)hello {
  NSLog(@&amp;quot;hello, world&amp;quot;);
}
@end

int main() {
   World* world = [World new];
   [world hello];
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们执行 clang 命令 &lt;code class=&quot;language-text&quot;&gt;clang -Xclang -ast-dump -fsyntax-only hello.m&lt;/code&gt; 之后，命令行中输出的结果如下所示：：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;@interface World- (void) hello;
@end
@implementation World
- (void) hello (CompoundStmt 0x10372ded0 &amp;lt;hello.m:8:15, line:10:1&amp;gt;
  (CallExpr 0x10372dea0 &amp;lt;line:9:3, col:24&amp;gt; &amp;#39;void&amp;#39;
    (ImplicitCastExpr 0x10372de88 &amp;lt;col:3&amp;gt; &amp;#39;void (*)(NSString *, ...)&amp;#39; &amp;lt;FunctionToPointerDecay&amp;gt;
      (DeclRefExpr 0x10372ddd8 &amp;lt;col:3&amp;gt; &amp;#39;void (NSString *, ...)&amp;#39; Function 0x1023510d0 &amp;#39;NSLog&amp;#39; &amp;#39;void (NSString *, ...)&amp;#39;))
    (ObjCStringLiteral 0x10372de38 &amp;lt;col:9, col:10&amp;gt; &amp;#39;NSString *&amp;#39;
      (StringLiteral 0x10372de00 &amp;lt;col:10&amp;gt; &amp;#39;char [13]&amp;#39; lvalue &amp;quot;hello, world&amp;quot;))))


@end
int main() (CompoundStmt 0x10372e118 &amp;lt;hello.m:13:12, line:16:1&amp;gt;
  (DeclStmt 0x10372e090 &amp;lt;line:14:4, col:30&amp;gt;
    0x10372dfe0 &amp;quot;World *world =
      (ImplicitCastExpr 0x10372e078 &amp;lt;col:19, col:29&amp;gt; &amp;#39;World *&amp;#39; &amp;lt;BitCast&amp;gt;
        (ObjCMessageExpr 0x10372e048 &amp;lt;col:19, col:29&amp;gt; &amp;#39;id&amp;#39;:&amp;#39;id&amp;#39; selector=new class=&amp;#39;World&amp;#39;))&amp;quot;)
  (ObjCMessageExpr 0x10372e0e8 &amp;lt;line:15:4, col:16&amp;gt; &amp;#39;void&amp;#39; selector=hello
    (ImplicitCastExpr 0x10372e0d0 &amp;lt;col:5&amp;gt; &amp;#39;World *&amp;#39; &amp;lt;LValueToRValue&amp;gt;
      (DeclRefExpr 0x10372e0a8 &amp;lt;col:5&amp;gt; &amp;#39;World *&amp;#39; lvalue Var 0x10372dfe0 &amp;#39;world&amp;#39; &amp;#39;World *&amp;#39;))))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在抽象语法树中的每个节点都标注了其对应源码中的位置，同样的，如果产生了什么问题，clang 可以定位到问题所在处的源码位置。&lt;/p&gt;
&lt;h5 id=&quot;延伸阅读&quot;&gt;&lt;a href=&quot;#%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB&quot; aria-label=&quot;延伸阅读 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;延伸阅读&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://clang.llvm.org/docs/IntroductionToTheClangAST.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;clang AST 介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;静态分析&quot;&gt;&lt;a href=&quot;#%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90&quot; aria-label=&quot;静态分析 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;静态分析&lt;/h3&gt;
&lt;p&gt;一旦编译器把源码生成了抽象语法树，编译器可以对这棵树做分析处理，以找出代码中的错误，比如类型检查：即检查程序中是否有类型错误。例如：如果代码中给某个对象发送了一个消息，编译器会检查这个对象是否实现了这个消息（函数、方法）。此外，clang 对整个程序还做了其它更高级的一些分析，以确保程序没有错误。&lt;/p&gt;
&lt;h4 id=&quot;类型检查&quot;&gt;&lt;a href=&quot;#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5&quot; aria-label=&quot;类型检查 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;类型检查&lt;/h4&gt;
&lt;p&gt;每当开发人员编写代码的时候，clang 都会帮忙检查错误。其中最常见的就是检查程序是否发送正确的消息给正确的对象，是否在正确的值上调用了正确的函数。如果你给一个单纯的 &lt;code class=&quot;language-text&quot;&gt;NSObject*&lt;/code&gt; 对象发送了一个 &lt;code class=&quot;language-text&quot;&gt;hello&lt;/code&gt; 消息，那么 clang 就会报错。同样，如果你创建了 &lt;code class=&quot;language-text&quot;&gt;NSObject&lt;/code&gt; 的一个子类 &lt;code class=&quot;language-text&quot;&gt;Test&lt;/code&gt;, 如下所示：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;@interface Test : NSObject
@end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后试图给这个子类中某个属性设置一个与其自身类型不相符的对象，编译器会给出一个可能使用不正确的警告。&lt;/p&gt;
&lt;p&gt;一般会把类型分为两类：动态的和静态的。动态的在运行时做检查，静态的在编译时做检查。以往，编写代码时可以向任意对象发送任何消息，在运行时，才会检查对象是否能够响应这些消息。由于只是在运行时做此类检查，所以叫做动态类型。&lt;/p&gt;
&lt;p&gt;至于静态类型，是在编译时做检查。当在代码中使用 ARC 时，编译器在编译期间，会做许多的类型检查：因为编译器需要知道哪个对象该如何使用。例如，如果 myObject 没有 hello 方法，那么就不能写如下这行代码了：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;[myObject hello]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;其他分析&quot;&gt;&lt;a href=&quot;#%E5%85%B6%E4%BB%96%E5%88%86%E6%9E%90&quot; aria-label=&quot;其他分析 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;其他分析&lt;/h4&gt;
&lt;p&gt;clang 在静态分析阶段，除了类型检查外，还会做许多其它一些分析。如果你把 clang 的代码仓库 clone 到本地，然后进入目录 &lt;code class=&quot;language-text&quot;&gt;lib/StaticAnalyzer/Checkers&lt;/code&gt;，你会看到所有静态检查内容。比如 &lt;code class=&quot;language-text&quot;&gt;ObjCUnusedIVarsChecker.cpp&lt;/code&gt; 是用来检查是否有定义了，但是从未使用过的变量。而 &lt;code class=&quot;language-text&quot;&gt;ObjCSelfInitChecker.cpp&lt;/code&gt; 则是检查在 你的初始化方法中中调用 &lt;code class=&quot;language-text&quot;&gt;self&lt;/code&gt; 之前，是否已经调用 &lt;code class=&quot;language-text&quot;&gt;[self initWith...]&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;[super init]&lt;/code&gt; 了。编译器还进行了一些其它的检查，例如在 &lt;code class=&quot;language-text&quot;&gt;lib/Sema/SemaExprObjC.cpp&lt;/code&gt; 的 2,534 行，有这样一句：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Diag(SelLoc, diag::warn_arc_perform_selector_leaks);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个会生成严重错误的警告 “performSelector may cause a leak because its selector is unknown” 。&lt;/p&gt;
&lt;h2 id=&quot;代码生成&quot;&gt;&lt;a href=&quot;#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90&quot; aria-label=&quot;代码生成 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;代码生成&lt;/h2&gt;
&lt;p&gt;clang 完成代码的标记，解析和分析后，接着就会生成 LLVM 代码。下面继续看看&lt;code class=&quot;language-text&quot;&gt;hello.c&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
  printf(&amp;quot;hello world\n&amp;quot;);
  return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要把这段代码编译成 LLVM 字节码（绝大多数情况下是二进制码格式），我们可以执行下面的命令：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;clang -O3 -emit-LLVM hello.c -c -o hello.bc&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着用另一个命令来查看刚刚生成的二进制文件：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;llvm-dis &amp;lt; hello.bc | less&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;; ModuleID = &amp;#39;&amp;lt;stdin&amp;gt;&amp;#39;
target datalayout = &amp;quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128&amp;quot;
target triple = &amp;quot;x86_64-apple-macosx10.8.0&amp;quot;

@str = private unnamed_addr constant [12 x i8] c&amp;quot;hello world\00&amp;quot;

; Function Attrs: nounwind ssp uwtable
define i32 @main() #0 {
  %puts = tail call i32 @puts(i8* getelementptr inbounds ([12 x i8]* @str, i64 0, i64 0))
  ret i32 0
}

; Function Attrs: nounwind
declare i32 @puts(i8* nocapture) #1

attributes #0 = { nounwind ssp uwtable }
attributes #1 = { nounwind }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的代码中，可以看到 &lt;code class=&quot;language-text&quot;&gt;main&lt;/code&gt; 函数只有两行代码：一行输出string，另一行返回 &lt;code class=&quot;language-text&quot;&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;再换一个程序，拿 &lt;code class=&quot;language-text&quot;&gt;five.m&lt;/code&gt; 为例，对其做相同的编译，然后执行 &lt;code class=&quot;language-text&quot;&gt;LLVM-dis &amp;lt; five.bc | less&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#import &amp;lt;Foundation/Foundation.h&amp;gt;

int main() {
  NSLog(@&amp;quot;%@&amp;quot;, [@5 description]);
  return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;抛开其他的不说，单看 &lt;code class=&quot;language-text&quot;&gt;main&lt;/code&gt; 函数：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;define i32 @main() #0 {
  %1 = load %struct._class_t** @&amp;quot;\01L_OBJC_CLASSLIST_REFERENCES_$_&amp;quot;, align 8
  %2 = load i8** @&amp;quot;\01L_OBJC_SELECTOR_REFERENCES_&amp;quot;, align 8, !invariant.load !4
  %3 = bitcast %struct._class_t* %1 to i8*
  %4 = tail call %0* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to %0* (i8*, i8*, i32)*)(i8* %3, i8* %2, i32 5)
  %5 = load i8** @&amp;quot;\01L_OBJC_SELECTOR_REFERENCES_2&amp;quot;, align 8, !invariant.load !4
  %6 = bitcast %0* %4 to i8*
  %7 = tail call %1* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to %1* (i8*, i8*)*)(i8* %6, i8* %5)
  tail call void (%1*, ...)* @NSLog(%1* bitcast (%struct.NSConstantString* @_unnamed_cfstring_ to %1*), %1* %7)
  ret i32 0
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码中最重要的是第 4 行，它创建了一个 &lt;code class=&quot;language-text&quot;&gt;NSNumber&lt;/code&gt; 对象。第 7 行，给这个 number 对象发送了一个  &lt;code class=&quot;language-text&quot;&gt;description&lt;/code&gt; 消息。第 8 行，将 &lt;code class=&quot;language-text&quot;&gt;description&lt;/code&gt; 消息返回的内容打印出来。&lt;/p&gt;
&lt;h3 id=&quot;优化&quot;&gt;&lt;a href=&quot;#%E4%BC%98%E5%8C%96&quot; aria-label=&quot;优化 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;优化&lt;/h3&gt;
&lt;p&gt;要想了解 LLVM 的优化内容，以及 clang 能做哪些优化，我们先看一个略微复杂的 C 程序：这个函数主要是递归计算 &lt;code class=&quot;language-text&quot;&gt;阶乘&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int factorial(int x) {
   if (x &amp;gt; 1) return x * factorial(x-1);
   else return 1;
}

int main() {
  printf(&amp;quot;factorial 10: %d\n&amp;quot;, factorial(10));
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先看看不做优化的编译情况，执行下面命令：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;clang -O0 -emit-llvm factorial.c  -c -o factorial.bc &amp;amp;&amp;amp; llvm-dis &amp;lt; factorial.bc&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重点看一下针对 &lt;code class=&quot;language-text&quot;&gt;阶乘&lt;/code&gt; 部分生成的代码：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;define i32 @factorial(i32 %x) #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  store i32 %x, i32* %2, align 4
  %3 = load i32* %2, align 4
  %4 = icmp sgt i32 %3, 1
  br i1 %4, label %5, label %11

; &amp;lt;label&amp;gt;:5                                       ; preds = %0
  %6 = load i32* %2, align 4
  %7 = load i32* %2, align 4
  %8 = sub nsw i32 %7, 1
  %9 = call i32 @factorial(i32 %8)
  %10 = mul nsw i32 %6, %9
  store i32 %10, i32* %1
  br label %12

; &amp;lt;label&amp;gt;:11                                      ; preds = %0
  store i32 1, i32* %1
  br label %12

; &amp;lt;label&amp;gt;:12                                      ; preds = %11, %5
  %13 = load i32* %1
  ret i32 %13
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看一下 &lt;code class=&quot;language-text&quot;&gt;%9&lt;/code&gt; 标注的那一行，这行代码正是递归调用阶乘函数本身，实际上这样调用是非常低效的，因为每次递归调用都要重新压栈。接下来可以看一下优化后的效果，可以通过这样的方式开启优化 -- 将 &lt;code class=&quot;language-text&quot;&gt;-03&lt;/code&gt; 标志传给 clang：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;clang -O3 -emit-llvm factorial.c  -c -o factorial.bc &amp;amp;&amp;amp; llvm-dis &amp;lt; factorial.bc&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在 &lt;code class=&quot;language-text&quot;&gt;阶乘&lt;/code&gt; 计算相关代码编译后生成的代码如下：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;define i32 @factorial(i32 %x) #0 {
  %1 = icmp sgt i32 %x, 1
  br i1 %1, label %tailrecurse, label %tailrecurse._crit_edge

tailrecurse:                                      ; preds = %tailrecurse, %0
  %x.tr2 = phi i32 [ %2, %tailrecurse ], [ %x, %0 ]
  %accumulator.tr1 = phi i32 [ %3, %tailrecurse ], [ 1, %0 ]
  %2 = add nsw i32 %x.tr2, -1
  %3 = mul nsw i32 %x.tr2, %accumulator.tr1
  %4 = icmp sgt i32 %2, 1
  br i1 %4, label %tailrecurse, label %tailrecurse._crit_edge

tailrecurse._crit_edge:                           ; preds = %tailrecurse, %0
  %accumulator.tr.lcssa = phi i32 [ 1, %0 ], [ %3, %tailrecurse ]
  ret i32 %accumulator.tr.lcssa
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即便我们的函数并没有按照&lt;a href=&quot;http://en.wikipedia.org/wiki/Tail_call&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;尾递归&lt;/a&gt;的方式编写，clang 仍然能对其做优化处理，让该函数编译的结果中只包含一个循环。当然 clang 能对代码进行的优化还有很多方面。可以看以下这个比较不错的 gcc 的优化例子&lt;a href=&quot;http://ridiculousfish.com/blog/posts/will-it-optimize.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;ridiculousfish.com&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.llvm.org/search/label/optimization&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;LLVM blog: posts tagged &apos;optimization&apos;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.llvm.org/2013/05/llvm-33-vectorization-improvements.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;LLVM blog: vectorization improvements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.llvm.org/2011/09/greedy-register-allocation-in-llvm-30.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;LLVM blog: greedy register allocation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://polly.llvm.org/index.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;The Polly project&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;如何在实际中应用这些特性&quot;&gt;&lt;a href=&quot;#%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AE%9E%E9%99%85%E4%B8%AD%E5%BA%94%E7%94%A8%E8%BF%99%E4%BA%9B%E7%89%B9%E6%80%A7&quot; aria-label=&quot;如何在实际中应用这些特性 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;如何在实际中应用这些特性&lt;/h2&gt;
&lt;p&gt;刚刚我们探讨了编译的全过程，从标记到解析，从抽象语法树到分析检查，再到汇编。读者不禁要问，为什么要关注这些？&lt;/p&gt;
&lt;h3 id=&quot;使用-libclan-g或-clang-插件&quot;&gt;&lt;a href=&quot;#%E4%BD%BF%E7%94%A8-libclan-g%E6%88%96-clang-%E6%8F%92%E4%BB%B6&quot; aria-label=&quot;使用 libclan g或 clang 插件 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;使用 libclan g或 clang 插件&lt;/h3&gt;
&lt;p&gt;之所以 clang 很酷：是因为它是一个开源的项目、并且它是一个非常好的工程：几乎可以说全身是宝。使用者可以创建自己的 clang 版本，针对自己的需求对其进行改造。比如说，可以改变 clang 生成代码的方式，增加更强的类型检查，或者按照自己的定义进行代码的检查分析等等。要想达成以上的目标，有很多种方法，其中最简单的就是使用一个名为 &lt;a href=&quot;http://clang.llvm.org/doxygen/group__CINDEX.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;libclang&lt;/a&gt; 的C类库。libclang 提供的 API 非常简单，可以对 C 和 clang 做桥接，并可以用它对所有的源码做分析处理。不过，根据我的经验，如果使用者的需求更高，那么 libclang 就不怎么行了。针对这种情况，推荐使用 &lt;a href=&quot;https://github.com/macmade/ClangKit&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Clangkit&lt;/a&gt;，它是基于 clang 提供的功能，用 Objective-C 进行封装的一个库。&lt;/p&gt;
&lt;p&gt;最后，clang 还提供了一个直接使用 LibTooling 的 C++ 类库。这里要做的事儿比较多，而且涉及到 C++，但是它能够发挥 clang 的强大功能。用它你可以对源码做任意类型的分析，甚至重写程序。如果你想要给 clang 添加一些自定义的分析、创建自己的重构器 (refactorer)、或者需要基于现有代码做出大量修改，甚至想要基于工程生成相关图形或者文档，那么 LibTooling 是很好的选择。&lt;/p&gt;
&lt;h3 id=&quot;自定义分析器&quot;&gt;&lt;a href=&quot;#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E6%9E%90%E5%99%A8&quot; aria-label=&quot;自定义分析器 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;自定义分析器&lt;/h3&gt;
&lt;p&gt;开发者可以按照 &lt;a href=&quot;http://clang.LLVM.org/docs/LibASTMatchersTutorial.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Tutorial for building tools using LibTooling&lt;/a&gt; 中的说明去构造 LLVM ，clang 以及 clan g的附加工具。需要注意的是，编译代码是需要花费一些时间的，即时机器已经很快了，但是在编译期间，我还是可以吃顿饭的。&lt;/p&gt;
&lt;p&gt;接下来，进入到 LLVM 目录，然后执行命令&lt;code class=&quot;language-text&quot;&gt;cd ~/llvm/tools/clang/tools/&lt;/code&gt;。在这个目录中，可以创建自己独立的 clang 工具。例如，我们创建一个小工具，用来检查某个库是否正确使用。首先将 &lt;a href=&quot;https://github.com/objcio/issue6-compiler-tool&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;样例工程&lt;/a&gt; 克隆到本地，然后输入 &lt;code class=&quot;language-text&quot;&gt;make&lt;/code&gt;。这样就会生成一个名为 &lt;code class=&quot;language-text&quot;&gt;example&lt;/code&gt; 的二进制文件。&lt;/p&gt;
&lt;p&gt;我们的使用场景是：假如有一个 &lt;code class=&quot;language-text&quot;&gt;Observer&lt;/code&gt; 类, 代码如下所示：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;@interface Observer
+ (instancetype)observerWithTarget:(id)target action:(SEL)selector;
@end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，我们想要检查一下每当这个类被调用的时候，在 &lt;code class=&quot;language-text&quot;&gt;target&lt;/code&gt; 对象中是否都有对应的 &lt;code class=&quot;language-text&quot;&gt;action&lt;/code&gt; 方法存在。可以写个 C++ 函数来做这件事（注意，这是我第一次写 C++ 程序，可能不那么严谨）：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;virtual bool VisitObjCMessageExpr(ObjCMessageExpr *E) {
  if (E-&amp;gt;getReceiverKind() == ObjCMessageExpr::Class) {
    QualType ReceiverType = E-&amp;gt;getClassReceiver();
    Selector Sel = E-&amp;gt;getSelector();
    string TypeName = ReceiverType.getAsString();
    string SelName = Sel.getAsString();
    if (TypeName == &amp;quot;Observer&amp;quot; &amp;amp;&amp;amp; SelName == &amp;quot;observerWithTarget:action:&amp;quot;) {
      Expr *Receiver = E-&amp;gt;getArg(0)-&amp;gt;IgnoreParenCasts();
      ObjCSelectorExpr* SelExpr = cast&amp;lt;ObjCSelectorExpr&amp;gt;(E-&amp;gt;getArg(1)-&amp;gt;IgnoreParenCasts());
      Selector Sel = SelExpr-&amp;gt;getSelector();
      if (const ObjCObjectPointerType *OT = Receiver-&amp;gt;getType()-&amp;gt;getAs&amp;lt;ObjCObjectPointerType&amp;gt;()) {
        ObjCInterfaceDecl *decl = OT-&amp;gt;getInterfaceDecl();
        if (! decl-&amp;gt;lookupInstanceMethod(Sel)) {
          errs() &amp;lt;&amp;lt; &amp;quot;Warning: class &amp;quot; &amp;lt;&amp;lt; TypeName &amp;lt;&amp;lt; &amp;quot; does not implement selector &amp;quot; &amp;lt;&amp;lt; Sel.getAsString() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
          SourceLocation Loc = E-&amp;gt;getExprLoc();
          PresumedLoc PLoc = astContext-&amp;gt;getSourceManager().getPresumedLoc(Loc);
          errs() &amp;lt;&amp;lt; &amp;quot;in &amp;quot; &amp;lt;&amp;lt; PLoc.getFilename() &amp;lt;&amp;lt; &amp;quot; &amp;lt;&amp;quot; &amp;lt;&amp;lt; PLoc.getLine() &amp;lt;&amp;lt; &amp;quot;:&amp;quot; &amp;lt;&amp;lt; PLoc.getColumn() &amp;lt;&amp;lt; &amp;quot;&amp;gt;\n&amp;quot;;
        }
      }
    }
  }
  return true;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的这个方法首先查找消息表达式， 以 &lt;code class=&quot;language-text&quot;&gt;Observer&lt;/code&gt; 作为接收者， &lt;code class=&quot;language-text&quot;&gt;observerWithTarget:action:&lt;/code&gt; 作为 selector，然后检查 target 中是否存在相应的方法。虽然这个例子有点儿刻意，但如果你想要利用 AST 对自己的代码库做某些检查，按照上面的例子来就可以了。&lt;/p&gt;
&lt;h3 id=&quot;clang的其他特性&quot;&gt;&lt;a href=&quot;#clang%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7&quot; aria-label=&quot;clang的其他特性 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;clang的其他特性&lt;/h3&gt;
&lt;p&gt;clang还有许多其他的用途。比如，可以写编译器插件（例如，类似上面的检查器例子）并且动态的加载到编译器中。虽然我没有亲自实验过，但是我觉得在 Xcode 中应该是可行的。再比如，也可以通过编写 clang 插件来自定义代码样式（具体可以参见 &lt;a href=&quot;http://objccn.io/issue-6-1/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;编译过程&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;另外，如果想对现有的代码做大规模的重构， 而 Xcode 或 AppCode 本身集成的重构工具无法达你的要求，你完全可以用 clang 自己写个重构工具。听起来有点儿可怕，读读下面的文档和教程，你会发现其实没那么难。&lt;/p&gt;
&lt;p&gt;最后，如果是真的有这种需求，你完全可以引导 Xcdoe 使用你自己编译的 clang 。再一次，如果你去尝试，其实这些事儿真的没想象中那么复杂，反而会发现许多个中乐趣。&lt;/p&gt;</content:encoded></item></channel></rss>