{"componentChunkName":"component---src-templates-post-page-js","path":"/2018/02-27/Mach-O","webpackCompilationHash":"532c5d6d6f2b2e6d7aed","result":{"data":{"prevPost":{"id":"35a57728-eb3b-5827-b69c-ab4c2d50829a","fields":{"slug":"/2017/11-20/javascript-run-loop-ics"},"excerpt":"1.关于javascript javascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的\"多线程\"都是用单线程模拟出来的，一切javascript多线程都是纸老虎！…","timeToRead":6,"frontmatter":{"title":"JavaScript 执行机制","cover":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAARlAAAEZQAGA43XUAAABvUlEQVQoz41RTUsbURSd3/LefLzJ5AOaiW4tVrFustAuWveuC9kW3QnuhYK4K4XSqgTExIVI0GJJMiYhodREEycfYxKSrlJtmk/Pmykuo3Dmzp1733nn3DvCvxK9vxLvr8W/1zxBdMDzIv1TcFpit2jXeeR1sAChW6L1FKsmWTXBSj9clsEaacWMq+WE2smLzYxiGWo9zeopBUDXumAo9m5sMl44dHcljqqkX6aDCumbFEDdEeTi3BqFBZ5wd+J/5buCaERd8UPt/MCdiGhGVEtGtNiup3jOOnnp5JvnLOxpZ6VBmXRtt07ECLbtIm3npEZarhkKAP+trMxjToJ4MyPjE2rIx7ekZ9JRg4wsOmoSTsYDk7h4yEER+yaxI7VbpHdD0P2dk9ZCvlZW2t/R3i75tza8g7JNhjhfpo3H/NEkHOKuekpemA1cHLFXM4EvH93fwypagjP6BODQsEJqhhxc0GtJefODd/6lfvhJG1aeR8aq25fS4pyeP1WwcyOqTgemYnsuYTINe8JffL/64t2Sf2XZnz1mb4L6esj3ek7HCMKTsgOTFs6Ur9tuMy6PLfIrpnzecv+MKeMaeQDXF5ToxITb0wAAAABJRU5ErkJggg==","aspectRatio":2.4,"src":"/static/fc27b8857fa5b646f973b09b09e2f04f/27b4b/cover.png","srcSet":"/static/fc27b8857fa5b646f973b09b09e2f04f/59f52/cover.png 300w,\n/static/fc27b8857fa5b646f973b09b09e2f04f/975a1/cover.png 600w,\n/static/fc27b8857fa5b646f973b09b09e2f04f/27b4b/cover.png 1200w,\n/static/fc27b8857fa5b646f973b09b09e2f04f/12377/cover.png 1536w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"date":"Nov 20","author":{"id":"westwood","nickname":"westwood","avatar":{"childImageSharp":{"resize":{"src":"/static/dcc5ea15ad3a22318ed1bbf58a6b2b8f/3c462/westwood.png"}}}}}},"nextPost":{"id":"16f26f67-fd38-5e46-9907-169bfff4369b","fields":{"slug":"/2018/03-06/Category"},"excerpt":"什么是category？ category是 Objective-C 2.0 之后添加的语言特性，主要作用是为已经存在的类添加方法。除此之外，Apple 还推荐了category…","timeToRead":8,"frontmatter":{"title":"从源码解读Category实现原理","cover":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAADd0lEQVQ4yz2Q2VMaZhTF+ZPy2KfaaRwbNWqqcSUIxEBRArhgkQjugKCIiAIFFHBhUQd3bYxJmi4PmUxr+9D2wSTTtNOHTJPUBRdq0l+/Op0+nLlzzz3fufc7kjcvX7L/6g8OXr/i6M83ZA/2OTrc5yR7xMnxEacn2f9xLLjjo0Oy/+Gizx6Kt6/5/dffeLb3HMmzp8/ZF0Qum+Xk8IAzITo/PeFMGOTORD09vkBO4O/z3AXe/ou/znibO+X87JR3or4T2pxYInm/Somhz8lQKIbdHyGcmGf74SPSK+tsbO+wfvceW/fuk9ncZuvBl3z9+Am7P3zPd7u77O095cWLX/jxp5/5RvBPvt1FcqmwgvfKpeTLVMhaOmj41Iqh28aAZwx3IERgKs5EJIY3FBV9BF9oEo8/yPB4AId3HItzBGO/gxsGI0VKDZL86nrKVbeR6oxo7/RgGRwWYj/+yCThaJxwbJqZRJK5ZJpkKk0qnWIqLvholEAkQpdziNauXrQdnVQ0NCKp1WjRmc1YHXZcY158QT+x6SkSyVkWFlIsZRZZW8mwubrE1toya0sLzKdmScyIeMIBxiZGcXqGaO+yckuvQ9KgrkOtrqFZL8dpN+F2tBP/bJDw+ABR/wDxoINYwE4y4iTu7yPosTLh7sRivIXH0YalQ4O2SYZaVY1MVopEpSzhpvwq7a1KQh4j3SYlgz160lEXo7ZmVmdcbCTcBN1mFmNu/E4j9s5G2lsaMOmlaOQlNDfVYjHJUUgLkVR+fJkGxXXCPqsYSBlzdeBzGJj2WQiO9DIz0cXnySHivj6+WPSQGjdj0MgJuK0M9bdQVlKAQa+mvqaYG1WXkZQUf0inSUOn8SbS2lJUykratPU4OvV8tZ5iLjQiLtLxeDuDSSwM2I2Y27W4ew14xZdT0xPMJ0Io5LWUFuchcQ1asQ+YCI3bWUpNEvKP0mfRiaz6ycyEub+cFL2RNTGL+3ppa6zjo8ICysqK6O/tYC7qxTbQTpNGSlHhB0g2VxI82Fri0UaanXk/dzPTOAesrKZj7KwtspyK0viJgsCojdsiGrWsgt4uIy5nDy5XN80GBTJlNdeuX6XgijD0jg0SnfTh8/RRmncJnaqOOx2tZJKTPNzKMD8boexasTAxUVRcyLCrj9m4n0hwBJvNTGVNIVV15VQq5ORdyecfBbDPHrHSnJIAAAAASUVORK5CYII=","aspectRatio":2.4,"src":"/static/703bae1019733ed6126772862bf29955/27b4b/cover.png","srcSet":"/static/703bae1019733ed6126772862bf29955/59f52/cover.png 300w,\n/static/703bae1019733ed6126772862bf29955/975a1/cover.png 600w,\n/static/703bae1019733ed6126772862bf29955/27b4b/cover.png 1200w,\n/static/703bae1019733ed6126772862bf29955/db925/cover.png 1800w,\n/static/703bae1019733ed6126772862bf29955/eaf75/cover.png 1818w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"date":"Mar 6","author":{"id":"westwood","nickname":"westwood","avatar":{"childImageSharp":{"resize":{"src":"/static/dcc5ea15ad3a22318ed1bbf58a6b2b8f/3c462/westwood.png"}}}}}},"post":{"id":"61c3ffd1-2fef-586d-961c-a105ad284c8d","fields":{"slug":"/2018/02-27/Mach-O"},"html":"<p>我们用 Xcode 构建一个程序的过程中，会把源文件 (<code class=\"language-text\">.m</code> 和 <code class=\"language-text\">.h</code>) 文件转换为一个可执行文件。这个可执行文件中包含的字节码会将被 CPU (iOS 设备中的 ARM 处理器或 Mac 上的 Intel 处理器) 执行。</p>\n<p>本文将介绍一下上面的过程中编译器都做了些什么，同时深入看看可执行文件内部是怎样的。实际上里面的东西要比我们第一眼看到的多得多。</p>\n<p>这里我们把 Xcode 放一边，将使用命令行工具 (command-line tools)。当我们用 Xcode 构建一个程序时，Xcode 只是简单的调用了一系列的工具而已。Florian 对工具调用是如何工作的做了更详细的讨论。本文我们就直接调用这些工具，并看看它们都做了些什么。</p>\n<p>真心希望本文能帮助你更好的理解 iOS 或 OS X 中的一个可执行文件 (也叫做 <em>Mach-O executable</em>) 是如何执行，以及怎样组装起来的。</p>\n<h2 id=\"xcrun\"><a href=\"#xcrun\" aria-label=\"xcrun permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>xcrun</h2>\n<p>先来看一些基础性的东西：这里会大量使用一个名为 <code class=\"language-text\">xcrun</code> 的命令行工具。看起来可能会有点奇怪，不过它非常的出色。这个小工具用来调用别的一些工具。原先，我们在终端执行如下命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% clang -v</code></pre></div>\n<p>现在我们用下面的命令代替：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% xcrun clang -v</code></pre></div>\n<p>在这里 <code class=\"language-text\">xcrun</code> 做的是定位到 <code class=\"language-text\">clang</code>，并执行它，附带输入 <code class=\"language-text\">clang</code> 后面的参数。</p>\n<p>我们为什么要这样做呢？看起来没有什么意义。不过 <code class=\"language-text\">xcode</code> 允许我们: (1) 使用多个版本的 Xcode，以及使用某个特定 Xcode 版本中的工具。(2) 针对某个特定的 SDK (software development kit) 使用不同的工具。如果你有 Xcode 4.5 和 Xcode 5，通过 <code class=\"language-text\">xcode-select</code> 和 <code class=\"language-text\">xcrun</code> 可以选择使用 Xcode 5 中 iOS SDK 的工具，或者 Xcode 4.5 中的 OS X 工具。在许多其它平台中，这是不可能做到的。查阅 <code class=\"language-text\">xcrun</code> 和 <code class=\"language-text\">xcode-select</code> 的主页内容可以了解到详细内容。不用安装 <em>Command Line Tools</em>，就能使用命令行中的开发者工具。</p>\n<h2 id=\"不使用-ide-的-hello-world\"><a href=\"#%E4%B8%8D%E4%BD%BF%E7%94%A8-ide-%E7%9A%84-hello-world\" aria-label=\"不使用 ide 的 hello world permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>不使用 IDE 的 Hello World</h2>\n<p>回到终端 (Terminal)，创建一个包含一个 C 文件的文件夹：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% mkdir ~/Desktop/objcio-command-line\n% cd !$\n% touch helloworld.c</code></pre></div>\n<p>接着使用你喜欢的文本编辑器来编辑这个文件 -- 例如 TextEdit.app：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% open -e helloworld.c</code></pre></div>\n<p>输入如下代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#include &lt;stdio.h&gt;\nint main(int argc, char *argv[])\n{\n    printf(&quot;Hello World!\\n&quot;);\n    return 0;\n}</code></pre></div>\n<p>保存并返回到终端，然后运行如下命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% xcrun clang helloworld.c\n% ./a.out</code></pre></div>\n<p>现在你能够在终端上看到熟悉的 <code class=\"language-text\">Hello World!</code>。这里我们编译并运行 C 程序，全程没有使用 IDE。深呼吸一下，高兴高兴。</p>\n<p>上面我们到底做了些什么呢？我们将 <code class=\"language-text\">helloworld.c</code> 编译为一个名为 <code class=\"language-text\">a.out</code> 的 Mach-O 二进制文件。注意，如果我们没有指定名字，那么编译器会默认的将其指定为 a.out。</p>\n<p>这个二进制文件是如何生成的呢？实际上有许多内容需要观察和理解。我们先看看编译器吧。</p>\n<h3 id=\"hello-world-和编译器\"><a href=\"#hello-world-%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8\" aria-label=\"hello world 和编译器 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hello World 和编译器</h3>\n<p>时下 Xcode 中编译器默认选择使用 <code class=\"language-text\">clang</code>(读作 /klæŋ/)。<a href=\"http://objccn.io/issue-6-2/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">关于编译器</a>，Chris 写了更详细的文章。</p>\n<p>简单的说，编译器处理过程中，将 <code class=\"language-text\">helloworld.c</code> 当做输入文件，并生成一个可执行文件 <code class=\"language-text\">a.out</code>。这个过程有多个步骤/阶段。我们需要做的就是正确的执行它们。</p>\n<h5 id=\"预处理\"><a href=\"#%E9%A2%84%E5%A4%84%E7%90%86\" aria-label=\"预处理 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>预处理</h5>\n<ul>\n<li>符号化 (Tokenization)</li>\n<li>宏定义的展开</li>\n<li><code class=\"language-text\">#include</code> 的展开</li>\n</ul>\n<h5 id=\"语法和语义分析\"><a href=\"#%E8%AF%AD%E6%B3%95%E5%92%8C%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90\" aria-label=\"语法和语义分析 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>语法和语义分析</h5>\n<ul>\n<li>将符号化后的内容转化为一棵解析树 (parse tree)</li>\n<li>解析树做语义分析</li>\n<li>输出一棵<em>抽象语法树</em>（Abstract Syntax Tree* (AST)）</li>\n</ul>\n<h5 id=\"生成代码和优化\"><a href=\"#%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E5%92%8C%E4%BC%98%E5%8C%96\" aria-label=\"生成代码和优化 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>生成代码和优化</h5>\n<ul>\n<li>将 AST 转换为更低级的中间码 (LLVM IR)</li>\n<li>对生成的中间码做优化</li>\n<li>生成特定目标代码</li>\n<li>输出汇编代码</li>\n</ul>\n<h5 id=\"汇编器\"><a href=\"#%E6%B1%87%E7%BC%96%E5%99%A8\" aria-label=\"汇编器 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>汇编器</h5>\n<ul>\n<li>将汇编代码转换为目标对象文件。</li>\n</ul>\n<h5 id=\"链接器\"><a href=\"#%E9%93%BE%E6%8E%A5%E5%99%A8\" aria-label=\"链接器 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>链接器</h5>\n<ul>\n<li>将多个目标对象文件合并为一个可执行文件 (或者一个动态库)</li>\n</ul>\n<p>我们来看一个关于这些步骤的简单的例子。</p>\n<h4 id=\"预处理-1\"><a href=\"#%E9%A2%84%E5%A4%84%E7%90%86-1\" aria-label=\"预处理 1 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>预处理</h4>\n<p>编译过程中，编译器首先要做的事情就是对文件做处理。预处理结束之后，如果我们停止编译过程，那么我们可以让编译器显示出预处理的一些内容：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% xcrun clang -E helloworld.c</code></pre></div>\n<p>喔喔。 上面的命令输出的内容有 413 行。我们用编辑器打开这些内容，看看到底发生了什么：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% xcrun clang -E helloworld.c | open -f</code></pre></div>\n<p>在顶部可以看到的许多行语句都是以 <code class=\"language-text\">#</code> 开头 (读作 <code class=\"language-text\">hash</code>)。这些被称为 <em>行标记</em> 的语句告诉我们后面跟着的内容来自哪里。如果再回头看看 <code class=\"language-text\">helloworld.c</code> 文件，会发现第一行是：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#include &lt;stdio.h&gt;</code></pre></div>\n<p>我们都用过 <code class=\"language-text\">#include</code> 和 <code class=\"language-text\">import</code>。它们所做的事情是告诉预处理器将文件 <code class=\"language-text\">stdio.h</code> 中的内容插入到 <code class=\"language-text\">#include</code> 语句所在的位置。这是一个递归的过程：<code class=\"language-text\">stdio.h</code> 可能会包含其它的文件。</p>\n<p>由于这样的递归插入过程很多，所以我们需要确保记住相关行号信息。为了确保无误，预处理器在发生变更的地方插入以 <code class=\"language-text\">#</code> 开头的 <code class=\"language-text\">行标记</code>。跟在 <code class=\"language-text\">#</code> 后面的数字是在源文件中的行号，而最后的数字是在新文件中的行号。回到刚才打开的文件，紧跟着的是系统头文件，或者是被看做为封装了 <code class=\"language-text\">extern &quot;C&quot;</code> 代码块的文件。</p>\n<p>如果滚动到文件末尾，可以看到我们的 <code class=\"language-text\">helloworld.c</code> 代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># 2 &quot;helloworld.c&quot; 2\nint main(int argc, char *argv[])\n{\n printf(&quot;Hello World!\\n&quot;);\n return 0;\n}</code></pre></div>\n<p>在 Xcode 中，可以通过这样的方式查看任意文件的预处理结果：<strong>Product</strong> -> <strong>Perform Action</strong> -> <strong>Preprocess</strong>。注意，编辑器加载预处理后的文件需要花费一些时间 -- 接近 100,000 行代码。</p>\n<h4 id=\"编译\"><a href=\"#%E7%BC%96%E8%AF%91\" aria-label=\"编译 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>编译</h4>\n<p>下一步：分析和代码生成。我们可以用下面的命令让 <code class=\"language-text\">clang</code> 输出汇编代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% xcrun clang -S -o - helloworld.c | open -f</code></pre></div>\n<p>我们来看看输出的结果。首先会看到有一些以点 <code class=\"language-text\">.</code> 开头的行。这些就是汇编指令。其它的则是实际的 x86_64 汇编代码。最后是一些标记 (label)，与 C 语言中的类似。</p>\n<p>我们先看看前三行：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    .section    __TEXT,__text,regular,pure_instructions\n    .globl  _main\n    .align  4, 0x90</code></pre></div>\n<p>这三行是汇编指令，不是汇编代码。<code class=\"language-text\">.section</code> 指令指定接下来会执行哪一个段。</p>\n<p>第二行的 <code class=\"language-text\">.globl</code> 指令说明 <code class=\"language-text\">_main</code> 是一个外部符号。这就是我们的 <code class=\"language-text\">main()</code> 函数。这个函数对于二进制文件外部来说是可见的，因为系统要调用它来运行可执行文件。</p>\n<p><code class=\"language-text\">.align</code> 指令指出了后面代码的对齐方式。在我们的代码中，后面的代码会按照 16(2^4) 字节对齐，如果需要的话，用 <code class=\"language-text\">0x90</code> 补齐。</p>\n<p>接下来是 main 函数的头部：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">_main:                                  ## @main\n    .cfi_startproc\n## BB#0:\n    pushq   %rbp\nLtmp2:\n    .cfi_def_cfa_offset 16\nLtmp3:\n    .cfi_offset %rbp, -16\n    movq    %rsp, %rbp\nLtmp4:\n    .cfi_def_cfa_register %rbp\n    subq    $32, %rsp</code></pre></div>\n<p>上面的代码中有一些与 C 标记工作机制一样的一些标记。它们是某些特定部分的汇编代码的符号链接。首先是 <code class=\"language-text\">_main</code> 函数真正开始的地址。这个符号会被 export。二进制文件会有这个位置的一个引用。</p>\n<p><code class=\"language-text\">.cfi_startproc</code> 指令通常用于函数的开始处。CFI 是调用帧信息 (Call Frame Information) 的缩写。这个调用 <code class=\"language-text\">帧</code> 以松散的方式对应着一个函数。当开发者使用 debugger 和 <em>step in</em> 或 <em>step out</em> 时，实际上是 stepping in/out 一个调用帧。在 C 代码中，函数有自己的调用帧，当然，别的一些东西也会有类似的调用帧。<code class=\"language-text\">.cfi_startproc</code> 指令给了函数一个 <code class=\"language-text\">.eh_frame</code> 入口，这个入口包含了一些调用栈的信息（抛出异常时也是用其来展开调用帧堆栈的）。这个指令也会发送一些和具体平台相关的指令给 CFI。它与后面的 <code class=\"language-text\">.cfi_endproc</code> 相匹配，以此标记出 <code class=\"language-text\">main()</code> 函数结束的地方。</p>\n<p>接着是另外一个 label <code class=\"language-text\">## BB#0:</code>。然后，终于，看到第一句汇编代码：<code class=\"language-text\">pushq %rbp</code>。从这里开始事情开始变得有趣。在 OS X上，我们会有 X86_64 的代码，对于这种架构，有一个东西叫做 <em>ABI</em> ( 应用二进制接口 application binary interface)，ABI 指定了函数调用是如何在汇编代码层面上工作的。在函数调用期间，ABI 会让 <code class=\"language-text\">rbp</code> 寄存器 (基础指针寄存器 base pointer register) 被保护起来。当函数调用返回时，确保 <code class=\"language-text\">rbp</code> 寄存器的值跟之前一样，这是属于 main 函数的职责。<code class=\"language-text\">pushq %rbp</code> 将 <code class=\"language-text\">rbp</code> 的值 push 到栈中，以便我们以后将其 pop 出来。</p>\n<p>接下来是两个 CFI 指令：<code class=\"language-text\">.cfi_def_cfa_offset 16</code> 和 <code class=\"language-text\">.cfi_offset %rbp, -16</code>。这将会输出一些关于生成调用堆栈展开和调试的信息。我们改变了堆栈和基础指针，而这两个指令可以告诉编译器它们都在哪儿，或者更确切的，它们可以确保之后调试器要使用这些信息时，能找到对应的东西。</p>\n<p>接下来，<code class=\"language-text\">movq %rsp, %rbp</code> 将把局部变量放置到栈上。<code class=\"language-text\">subq $32, %rsp</code> 将栈指针移动 32 个字节，也就是函数会调用的位置。我们先将老的栈指针存储到 <code class=\"language-text\">rbp</code> 中，然后将此作为我们局部变量的基址，接着我们更新堆栈指针到我们将会使用的位置。</p>\n<p>之后，我们调用了 <code class=\"language-text\">printf()</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">leaq    L_.str(%rip), %rax\nmovl    $0, -4(%rbp)\nmovl    %edi, -8(%rbp)\nmovq    %rsi, -16(%rbp)\nmovq    %rax, %rdi\nmovb    $0, %al\ncallq   _printf</code></pre></div>\n<p>首先，<code class=\"language-text\">leaq</code> 会将 <code class=\"language-text\">L_.str</code> 的指针加载到 <code class=\"language-text\">rax</code> 寄存器中。留意 <code class=\"language-text\">L_.str</code> 标记在后面的汇编代码中是如何定义的。它就是 C 字符串<code class=\"language-text\">&quot;Hello World!\\n&quot;</code>。 <code class=\"language-text\">edi</code> 和 <code class=\"language-text\">rsi</code> 寄存器保存了函数的第一个和第二个参数。由于我们会调用别的函数，所以首先需要将它们的当前值保存起来。这就是为什么我们使用刚刚存储的 <code class=\"language-text\">rbp</code> 偏移32个字节的原因。第一个 32 字节的值是 0，之后的 32 字节的值是 <code class=\"language-text\">edi</code> 寄存器的值 (存储了 <code class=\"language-text\">argc</code>)。然后是 64 字节 的值：<code class=\"language-text\">rsi</code> 寄存器的值 (存储了 <code class=\"language-text\">argv</code>)。我们在后面并没有使用这些值，但是编译器在没有经过优化处理的时候，它们还是会被存下来。</p>\n<p>现在我们把第一个函数 <code class=\"language-text\">printf()</code> 的参数 <code class=\"language-text\">rax</code> 设置给第一个函数参数寄存器 <code class=\"language-text\">edi</code> 中。<code class=\"language-text\">printf()</code> 是一个可变参数的函数。ABI 调用约定指定，将会把使用来存储参数的寄存器数量存储在寄存器 <code class=\"language-text\">al</code> 中。在这里是 0。最后 <code class=\"language-text\">callq</code> 调用了 <code class=\"language-text\">printf()</code> 函数。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    movl    $0, %ecx\n    movl    %eax, -20(%rbp)         ## 4-byte Spill\n    movl    %ecx, %eax</code></pre></div>\n<p>上面的代码将 <code class=\"language-text\">ecx</code> 寄存器设置为 0，并把 <code class=\"language-text\">eax</code> 寄存器的值保存至栈中，然后将 <code class=\"language-text\">ect</code> 中的 0 拷贝至 <code class=\"language-text\">eax</code> 中。ABI 规定 <code class=\"language-text\">eax</code> 将用来保存一个函数的返回值，或者此处 <code class=\"language-text\">main()</code> 函数的返回值 0：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    addq    $32, %rsp\n    popq    %rbp\n    ret\n    .cfi_endproc</code></pre></div>\n<p>函数执行完成后，将恢复堆栈指针 —— 利用上面的指令 <code class=\"language-text\">subq $32, %rsp</code> 把堆栈指针 <code class=\"language-text\">rsp</code> 上移 32 字节。最后，把之前存储至 <code class=\"language-text\">rbp</code> 中的值从栈中弹出来，然后调用 <code class=\"language-text\">ret</code> 返回调用者， <code class=\"language-text\">ret</code> 会读取出栈的返回地址。 <code class=\"language-text\">.cfi_endproc</code> 平衡了 <code class=\"language-text\">.cfi_startproc</code> 指令。</p>\n<p>接下来是输出字符串 <code class=\"language-text\">&quot;Hello World!\\n&quot;</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    .section    __TEXT,__cstring,cstring_literals\nL_.str:                                 ## @.str\n    .asciz   &quot;Hello World!\\n&quot;</code></pre></div>\n<p>同样，<code class=\"language-text\">.section</code> 指令指出下面将要进入的段。<code class=\"language-text\">L_.str</code> 标记运行在实际的代码中获取到字符串的一个指针。<code class=\"language-text\">.asciz</code> 指令告诉编译器输出一个以 ‘\\0’ (null) 结尾的字符串。</p>\n<p><code class=\"language-text\">__TEXT __cstring</code> 开启了一个新的段。这个段中包含了 C 字符串：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">L_.str:                                 ## @.str\n    .asciz     &quot;Hello World!\\n&quot;</code></pre></div>\n<p>上面两行代码创建了一个 null 结尾的字符串。注意 <code class=\"language-text\">L_.str</code> 是如何命名，之后会通过它来访问字符串。</p>\n<p>最后的 <code class=\"language-text\">.subsections_via_symbols</code> 指令是静态链接编辑器使用的。</p>\n<p>更过关于汇编指令的资料可以在 苹果的 <a href=\"https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/Assembler/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">OS X Assembler Reference</a> 中看到。AMD 64 网站有关于 <a href=\"http://www.x86-64.org/documentation/abi.pdf\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ABI for x86 的文档</a>。另外还有 <a href=\"http://www.x86-64.org/documentation/assembly.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Gentle Introduction to x86-64 Assembly</a>。</p>\n<p>重申一下，通过下面的选择操作，我们可以用 Xcode 查看任意文件的汇编输出结果：<strong>Product</strong> -> <strong>Perform Action</strong> -> <strong>Assemble</strong>.</p>\n<h4 id=\"汇编器-1\"><a href=\"#%E6%B1%87%E7%BC%96%E5%99%A8-1\" aria-label=\"汇编器 1 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>汇编器</h4>\n<p>汇编器将可读的汇编代码转换为机器代码。它会创建一个目标对象文件，一般简称为 <em>对象文件</em>。这些文件以 <code class=\"language-text\">.o</code> 结尾。如果用 Xcode 构建应用程序，可以在工程的 <em>derived data</em> 目录中，<code class=\"language-text\">Objects-normal</code> 文件夹下找到这些文件。</p>\n<h4 id=\"链接器-1\"><a href=\"#%E9%93%BE%E6%8E%A5%E5%99%A8-1\" aria-label=\"链接器 1 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>链接器</h4>\n<p>稍后我们会对链接器做更详细的介绍。这里简单介绍一下：链接器解决了目标文件和库之间的链接。什么意思呢？还记得下面的语句吗：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">callq   _printf</code></pre></div>\n<p><code class=\"language-text\">printf()</code> 是 <em>libc</em> 库中的一个函数。无论怎样，最后的可执行文件需要能需要知道 <code class=\"language-text\">printf()</code> 在内存中的具体位置：例如，<code class=\"language-text\">_printf</code> 的地址符号是什么。链接器会读取所有的目标文件 (此处只有一个) 和库 (此处是 <em>libc</em>)，并解决所有未知符号 (此处是 <code class=\"language-text\">_printf</code>) 的问题。然后将它们编码进最后的可执行文件中  （可以在 <em>libc</em> 中找到符号 <code class=\"language-text\">_printf</code>），接着链接器会输出可以运行的执行文件：<code class=\"language-text\">a.out</code>。</p>\n<h2 id=\"section\"><a href=\"#section\" aria-label=\"section permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Section</h2>\n<p>就像我们上面提到的一样，这里有些东西叫做 section。一个可执行文件包含多个段，也就是多个 section。可执行文件不同的部分将加载进不同的 section，并且每个 section 会转换进某个 segment 里。这个概念对于所有的可执行文件都是成立的。</p>\n<p>我们来看看 <code class=\"language-text\">a.out</code> 二进制中的 section。我们可以使用 <code class=\"language-text\">size</code> 工具来观察：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% xcrun size -x -l -m a.out \nSegment __PAGEZERO: 0x100000000 (vmaddr 0x0 fileoff 0)\nSegment __TEXT: 0x1000 (vmaddr 0x100000000 fileoff 0)\n    Section __text: 0x37 (addr 0x100000f30 offset 3888)\n    Section __stubs: 0x6 (addr 0x100000f68 offset 3944)\n    Section __stub_helper: 0x1a (addr 0x100000f70 offset 3952)\n    Section __cstring: 0xe (addr 0x100000f8a offset 3978)\n    Section __unwind_info: 0x48 (addr 0x100000f98 offset 3992)\n    Section __eh_frame: 0x18 (addr 0x100000fe0 offset 4064)\n    total 0xc5\nSegment __DATA: 0x1000 (vmaddr 0x100001000 fileoff 4096)\n    Section __nl_symbol_ptr: 0x10 (addr 0x100001000 offset 4096)\n    Section __la_symbol_ptr: 0x8 (addr 0x100001010 offset 4112)\n    total 0x18\nSegment __LINKEDIT: 0x1000 (vmaddr 0x100002000 fileoff 8192)\ntotal 0x100003000</code></pre></div>\n<p>如上代码所示，我们的 <code class=\"language-text\">a.out</code> 文件有 4 个 segment。有些 segment 中有多个 section。</p>\n<p>当运行一个可执行文件时，虚拟内存 (VM - virtual memory) 系统将 segment 映射到进程的地址空间上。映射完全不同于我们一般的认识，如果你对虚拟内存系统不熟悉，可以简单的想象虚拟内存系统将整个可执行文件加载进内存 -- 虽然在实际上不是这样的。VM 使用了一些技巧来避免全部加载。</p>\n<p>当虚拟内存系统进行映射时，segment 和 section 会以不同的参数和权限被映射。</p>\n<p>上面的代码中，<code class=\"language-text\">__TEXT</code> segment 包含了被执行的代码。它被以只读和可执行的方式映射。进程被允许执行这些代码，但是不能修改。这些代码也不能对自己做出修改，因此这些被映射的页从来不会被改变。</p>\n<p><code class=\"language-text\">__DATA</code> segment 以可读写和不可执行的方式映射。它包含了将会被更改的数据。</p>\n<p>第一个 segment 是 <code class=\"language-text\">__PAGEZERO</code>。它的大小为 4GB。这 4GB 并不是文件的真实大小，但是规定了进程地址空间的前 4GB 被映射为 不可执行、不可写和不可读。这就是为什么当读写一个 <code class=\"language-text\">NULL</code> 指针或更小的值时会得到一个 <code class=\"language-text\">EXC_BAD_ACCESS</code> 错误。这是操作系统在尝试防止<a href=\"http://www.xkcd.com/371/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">引起系统崩溃</a>。</p>\n<p>在 segment中，一般都会有多个 section。它们包含了可执行文件的不同部分。在 <code class=\"language-text\">__TEXT</code> segment 中，<code class=\"language-text\">__text</code> section 包含了编译所得到的机器码。<code class=\"language-text\">__stubs</code> 和 <code class=\"language-text\">__stub_helper</code> 是给动态链接器 (<code class=\"language-text\">dyld</code>) 使用的。通过这两个 section，在动态链接代码中，可以允许延迟链接。<code class=\"language-text\">__const</code> (在我们的代码中没有) 是常量，不可变的，就像 <code class=\"language-text\">__cstring</code> (包含了可执行文件中的字符串常量 -- 在源码中被双引号包含的字符串) 常量一样。</p>\n<p><code class=\"language-text\">__DATA</code> segment 中包含了可读写数据。在我们的程序中只有 <code class=\"language-text\">__nl_symbol_ptr</code> 和 <code class=\"language-text\">__la_symbol_ptr</code>，它们分别是 <em>non-lazy</em> 和 <em>lazy</em> 符号指针。延迟符号指针用于可执行文件中调用未定义的函数，例如不包含在可执行文件中的函数，它们将会延迟加载。而针对非延迟符号指针，当可执行文件被加载同时，也会被加载。</p>\n<p>在 <code class=\"language-text\">_DATA</code> segment 中的其它常见 section 包括 <code class=\"language-text\">__const</code>，在这里面会包含一些需要重定向的常量数据。例如 <code class=\"language-text\">char * const p = &quot;foo&quot;;</code> -- <code class=\"language-text\">p</code> 指针指向的数据是可变的。<code class=\"language-text\">__bss</code> section 没有被初始化的静态变量，例如 <code class=\"language-text\">static int a;</code> -- ANSI C 标准规定静态变量必须设置为 0。并且在运行时静态变量的值是可以修改的。<code class=\"language-text\">__common</code> section 包含未初始化的外部全局变量，跟 <code class=\"language-text\">static</code> 变量类似。例如在函数外面定义的 <code class=\"language-text\">int a;</code>。最后，<code class=\"language-text\">__dyld</code> 是一个 section 占位符，被用于动态链接器。</p>\n<p>苹果的 <a href=\"https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/Assembler/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">OS X Assembler Reference</a> 文档有更多关于 section 类型的介绍。</p>\n<h3 id=\"section-中的内容\"><a href=\"#section-%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9\" aria-label=\"section 中的内容 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Section 中的内容</h3>\n<p>下面，我们用 <code class=\"language-text\">otool(1)</code> 来观察一个 section 中的内容：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% xcrun otool -s __TEXT __text a.out \na.out:\n(__TEXT,__text) section\n0000000100000f30 55 48 89 e5 48 83 ec 20 48 8d 05 4b 00 00 00 c7 \n0000000100000f40 45 fc 00 00 00 00 89 7d f8 48 89 75 f0 48 89 c7 \n0000000100000f50 b0 00 e8 11 00 00 00 b9 00 00 00 00 89 45 ec 89 \n0000000100000f60 c8 48 83 c4 20 5d c3 </code></pre></div>\n<p>上面是我们 app 中的代码。由于 <code class=\"language-text\">-s __TEXT __text</code> 很常见，<code class=\"language-text\">otool</code> 对其设置了一个缩写 <code class=\"language-text\">-t</code> 。我们还可以通过添加 <code class=\"language-text\">-v</code> 来查看反汇编代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% xcrun otool -v -t a.out\na.out:\n(__TEXT,__text) section\n_main:\n0000000100000f30    pushq   %rbp\n0000000100000f31    movq    %rsp, %rbp\n0000000100000f34    subq    $0x20, %rsp\n0000000100000f38    leaq    0x4b(%rip), %rax\n0000000100000f3f    movl    $0x0, 0xfffffffffffffffc(%rbp)\n0000000100000f46    movl    %edi, 0xfffffffffffffff8(%rbp)\n0000000100000f49    movq    %rsi, 0xfffffffffffffff0(%rbp)\n0000000100000f4d    movq    %rax, %rdi\n0000000100000f50    movb    $0x0, %al\n0000000100000f52    callq   0x100000f68\n0000000100000f57    movl    $0x0, %ecx\n0000000100000f5c    movl    %eax, 0xffffffffffffffec(%rbp)\n0000000100000f5f    movl    %ecx, %eax\n0000000100000f61    addq    $0x20, %rsp\n0000000100000f65    popq    %rbp\n0000000100000f66    ret</code></pre></div>\n<p>上面的内容是一样的，只不过以反汇编形式显示出来。你应该感觉很熟悉，这就是我们在前面编译时候的代码。唯一的不同就是，在这里我们没有任何的汇编指令在里面。这是纯粹的二进制执行文件。</p>\n<p>同样的方法，我们可以查看别的 section：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% xcrun otool -v -s __TEXT __cstring a.out\na.out:\nContents of (__TEXT,__cstring) section\n0x0000000100000f8a  Hello World!\\n</code></pre></div>\n<p>或:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% xcrun otool -v -s __TEXT __eh_frame a.out \na.out:\nContents of (__TEXT,__eh_frame) section\n0000000100000fe0    14 00 00 00 00 00 00 00 01 7a 52 00 01 78 10 01 \n0000000100000ff0    10 0c 07 08 90 01 00 00 </code></pre></div>\n<h4 id=\"性能上需要注意的事项\"><a href=\"#%E6%80%A7%E8%83%BD%E4%B8%8A%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E9%A1%B9\" aria-label=\"性能上需要注意的事项 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>性能上需要注意的事项</h4>\n<p>从侧面来讲，<code class=\"language-text\">__DATA</code> 和 <code class=\"language-text\">__TEXT</code> segment对性能会有所影响。如果你有一个很大的二进制文件，你可能得去看看苹果的文档：<a href=\"https://developer.apple.com/library/mac/documentation/Performance/Conceptual/CodeFootprint/Articles/MachOOverview.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">关于代码大小性能指南</a>。将数据移至 <code class=\"language-text\">__TEXT</code> 是个不错的选择，因为这些页从来不会被改变。</p>\n<h4 id=\"任意的片段\"><a href=\"#%E4%BB%BB%E6%84%8F%E7%9A%84%E7%89%87%E6%AE%B5\" aria-label=\"任意的片段 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>任意的片段</h4>\n<p>使用链接符号 <code class=\"language-text\">-sectcreate</code> 我们可以给可执行文件以 section 的方式添加任意的数据。这就是如何将一个 Info.plist 文件添加到一个独立的可执行文件中的方法。Info.plist 文件中的数据需要放入到 <code class=\"language-text\">__TEXT</code> segment 里面的一个 <code class=\"language-text\">__info_plist</code> section 中。可以将 <code class=\"language-text\">-sectcreate segname sectname file</code> 传递给链接器（通过将下面的内容传递给 clang）：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-Wl,-sectcreate,__TEXT,__info_plist,path/to/Info.plist</code></pre></div>\n<p>同样，<code class=\"language-text\">-sectalign</code> 规定了对其方式。如果你添加的是一个全新的 segment，那么需要通过 <code class=\"language-text\">-segprot</code> 来规定 segment 的保护方式 (读/写/可执行)。这些所有内容在链接器的帮助文档中都有，例如 <code class=\"language-text\">ld(1)</code>。</p>\n<p>我们可以利用定义在 <code class=\"language-text\">/usr/include/mach-o/getsect.h</code> 中的函数 <code class=\"language-text\">getsectdata()</code> 得到 section，例如 <code class=\"language-text\">getsectdata()</code> 可以得到指向 section 数据的一个指针，并返回相关 section 的长度。</p>\n<h3 id=\"mach-o\"><a href=\"#mach-o\" aria-label=\"mach o permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mach-O</h3>\n<p>在 OS X 和 iOS 中可执行文件的格式为 <a href=\"https://en.wikipedia.org/wiki/Mach-o\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Mach-O</a>：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% file a.out \na.out: Mach-O 64-bit executable x86_64</code></pre></div>\n<p>对于 GUI 程序也是一样的：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% file /Applications/Preview.app/Contents/MacOS/Preview \n/Applications/Preview.app/Contents/MacOS/Preview: Mach-O 64-bit executable x86_64</code></pre></div>\n<p>关于 <a href=\"https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/MachORuntime/index.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Mach-O 文件格式</a> 苹果有详细的介绍。</p>\n<p>我们可以使用 <code class=\"language-text\">otool(1)</code> 来观察可执行文件的头部 -- 规定了这个文件是什么，以及文件是如何被加载的。通过 <code class=\"language-text\">-h</code> 可以打印出头信息：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% otool -v -h a.out           a.out:\nMach header\n      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags\nMH_MAGIC_64  X86_64        ALL LIB64     EXECUTE    16       1296   NOUNDEFS DYLDLINK TWOLEVEL PIE</code></pre></div>\n<p><code class=\"language-text\">cputype</code> 和 <code class=\"language-text\">cpusubtype</code> 规定了这个可执行文件能够运行在哪些目标架构上。<code class=\"language-text\">ncmds</code> 和 <code class=\"language-text\">sizeofcmds</code> 是加载命令，可以通过 <code class=\"language-text\">-l</code> 来查看这两个加载命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% otool -v -l a.out | open -f\na.out:\nLoad command 0\n      cmd LC_SEGMENT_64\n  cmdsize 72\n  segname __PAGEZERO\n   vmaddr 0x0000000000000000\n   vmsize 0x0000000100000000\n...</code></pre></div>\n<p>加载命令规定了文件的逻辑结构和文件在虚拟内存中的布局。<code class=\"language-text\">otool</code> 打印出的大多数信息都是源自这里的加载命令。看一下 <code class=\"language-text\">Load command 1</code> 部分，可以找到 <code class=\"language-text\">initprot r-x</code>，它规定了之前提到的保护方式：只读和可执行。</p>\n<p>对于每一个 segment，以及segment 中的每个 section，加载命令规定了它们在内存中结束的位置，以及保护模式等。例如，下面是 <code class=\"language-text\">__TEXT __text</code> section 的输出内容：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Section\n  sectname __text\n   segname __TEXT\n      addr 0x0000000100000f30\n      size 0x0000000000000037\n    offset 3888\n     align 2^4 (16)\n    reloff 0\n    nreloc 0\n      type S_REGULAR\nattributes PURE_INSTRUCTIONS SOME_INSTRUCTIONS\n reserved1 0\n reserved2 0</code></pre></div>\n<p>上面的代码将在 0x100000f30 处结束。它在文件中的偏移量为 3888。如果看一下之前 <code class=\"language-text\">xcrun otool -v -t a.out</code> 输出的反汇编代码，可以发现代码实际位置在 0x100000f30。</p>\n<p>我们同样看看在可执行文件中，动态链接库是如何使用的：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% otool -v -L a.out\na.out:\n    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 169.3.0)\n    time stamp 2 Thu Jan  1 01:00:02 1970</code></pre></div>\n<p>上面就是我们可执行文件将要找到 <code class=\"language-text\">_printf</code> 符号的地方。</p>\n<h2 id=\"一个更复杂的例子\"><a href=\"#%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E4%BE%8B%E5%AD%90\" aria-label=\"一个更复杂的例子 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>一个更复杂的例子</h2>\n<p>我们来看看有三个文件的复杂例子：</p>\n<p><code class=\"language-text\">Foo.h</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#import &lt;Foundation/Foundation.h&gt;\n\n@interface Foo : NSObject\n\n- (void)run;\n\n@end</code></pre></div>\n<p><code class=\"language-text\">Foo.m</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#import &quot;Foo.h&quot;\n\n@implementation Foo\n\n- (void)run\n{\n    NSLog(@&quot;%@&quot;, NSFullUserName());\n}\n\n@end</code></pre></div>\n<p><code class=\"language-text\">helloworld.m</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#import &quot;Foo.h&quot;\n\nint main(int argc, char *argv[])\n{\n    @autoreleasepool {\n        Foo *foo = [[Foo alloc] init];\n        [foo run];\n        return 0;\n    }\n}</code></pre></div>\n<h3 id=\"编译多个文件\"><a href=\"#%E7%BC%96%E8%AF%91%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6\" aria-label=\"编译多个文件 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>编译多个文件</h3>\n<p>在上面的示例中，有多个源文件。所以我们需要让 clang 对输入每个文件生成对应的目标文件：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% xcrun clang -c Foo.m\n% xcrun clang -c helloworld.m</code></pre></div>\n<p>我们从来不编译头文件。头文件的作用就是在被编译的实现文件中对代码做简单的共享。<code class=\"language-text\">Foo.m</code> 和 <code class=\"language-text\">helloworld.m</code> 都是通过 <code class=\"language-text\">#import</code> 语句将 <code class=\"language-text\">Foo.h</code> 文件中的内容添加到实现文件中的。</p>\n<p>最终得到了两个目标文件：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% file helloworld.o Foo.o\nhelloworld.o: Mach-O 64-bit object x86_64\nFoo.o:        Mach-O 64-bit object x86_64</code></pre></div>\n<p>为了生成一个可执行文件，我们需要将这两个目标文件和 Foundation framework 链接起来：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">xcrun clang helloworld.o Foo.o -Wl,`xcrun --show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation</code></pre></div>\n<p>现在可以运行我们的程序了:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% ./a.out \n2013-11-03 18:03:03.386 a.out[8302:303] Daniel Eggert</code></pre></div>\n<h3 id=\"符号表和链接\"><a href=\"#%E7%AC%A6%E5%8F%B7%E8%A1%A8%E5%92%8C%E9%93%BE%E6%8E%A5\" aria-label=\"符号表和链接 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>符号表和链接</h3>\n<p>我们这个简单的程序是将两个目标文件合并到一起的。<code class=\"language-text\">Foo.o</code> 目标文件包含了 <code class=\"language-text\">Foo</code> 类的实现，而 <code class=\"language-text\">helloworld.o</code> 目标文件包含了 <code class=\"language-text\">main()</code> 函数，以及调用/使用 <code class=\"language-text\">Foo</code> 类。</p>\n<p>另外，这两个目标对象都使用了 Foundation framework。<code class=\"language-text\">helloworld.o</code> 目标文件使用了它的 autorelease pool，并间接的使用了  <code class=\"language-text\">libobjc.dylib</code> 中的 Objective-C 运行时。它需要运行时函数来进行消息的调用。<code class=\"language-text\">Foo.o</code> 目标文件也有类似的原理。</p>\n<p>所有的这些东西都被形象的称之为符号。我们可以把符号看成是一些在运行时将会变成指针的东西。虽然实际上并不是这样的。</p>\n<p>每个函数、全局变量和类等都是通过符号的形式来定义和使用的。当我们将目标文件链接为一个可执行文件时，链接器 (<code class=\"language-text\">ld(1)</code>) 在目标文件盒动态库之间对符号做了解析处理。</p>\n<p>可执行文件和目标文件有一个符号表，这个符号表规定了它们的符号。如果我们用 <code class=\"language-text\">nm(1)</code> 工具观察一下 <code class=\"language-text\">helloworld.0</code> 目标文件，可以看到如下内容：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% xcrun nm -nm helloworld.o\n                 (undefined) external _OBJC_CLASS_$_Foo\n0000000000000000 (__TEXT,__text) external _main\n                 (undefined) external _objc_autoreleasePoolPop\n                 (undefined) external _objc_autoreleasePoolPush\n                 (undefined) external _objc_msgSend\n                 (undefined) external _objc_msgSend_fixup\n0000000000000088 (__TEXT,__objc_methname) non-external L_OBJC_METH_VAR_NAME_\n000000000000008e (__TEXT,__objc_methname) non-external L_OBJC_METH_VAR_NAME_1\n0000000000000093 (__TEXT,__objc_methname) non-external L_OBJC_METH_VAR_NAME_2\n00000000000000a0 (__DATA,__objc_msgrefs) weak private external l_objc_msgSend_fixup_alloc\n00000000000000e8 (__TEXT,__eh_frame) non-external EH_frame0\n0000000000000100 (__TEXT,__eh_frame) external _main.eh</code></pre></div>\n<p>上面就是那个目标文件的所有符号。<code class=\"language-text\">_OBJC_CLASS_$_Foo</code> 是 <code class=\"language-text\">Foo</code> Objective-C 类的符号。该符号是 <em>undefined, external</em> 。<em>External</em> 的意思是指对于这个目标文件该类并不是私有的，相反，<code class=\"language-text\">non-external</code> 的符号则表示对于目标文件是私有的。我们的 <code class=\"language-text\">helloworld.o</code> 目标文件引用了类 <code class=\"language-text\">Foo</code>，不过这并没有实现它。因此符号表中将其标示为 undefined。</p>\n<p>接下来是 <code class=\"language-text\">_main</code> 符号，它是表示 <code class=\"language-text\">main()</code> 函数，同样为 <em>external</em>，这是因为该函数需要被调用，所以应该为可见的。由于在 <code class=\"language-text\">helloworld.o</code> 文件中实现了 这个 main 函数。这个函数地址位于 0处，并且需要转入到  <code class=\"language-text\">__TEXT,__text</code> section。接着是 4 个 Objective-C 运行时函数。它们同样是 undefined的，需要链接器进行符号解析。</p>\n<p>如果我们转而观察 <code class=\"language-text\">Foo.o</code> 目标文件，可以看到如下输出：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% xcrun nm -nm Foo.o\n0000000000000000 (__TEXT,__text) non-external -[Foo run]\n                 (undefined) external _NSFullUserName\n                 (undefined) external _NSLog\n                 (undefined) external _OBJC_CLASS_$_NSObject\n                 (undefined) external _OBJC_METACLASS_$_NSObject\n                 (undefined) external ___CFConstantStringClassReference\n                 (undefined) external __objc_empty_cache\n                 (undefined) external __objc_empty_vtable\n000000000000002f (__TEXT,__cstring) non-external l_.str\n0000000000000060 (__TEXT,__objc_classname) non-external L_OBJC_CLASS_NAME_\n0000000000000068 (__DATA,__objc_const) non-external l_OBJC_METACLASS_RO_$_Foo\n00000000000000b0 (__DATA,__objc_const) non-external l_OBJC_$_INSTANCE_METHODS_Foo\n00000000000000d0 (__DATA,__objc_const) non-external l_OBJC_CLASS_RO_$_Foo\n0000000000000118 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo\n0000000000000140 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo\n0000000000000168 (__TEXT,__objc_methname) non-external L_OBJC_METH_VAR_NAME_\n000000000000016c (__TEXT,__objc_methtype) non-external L_OBJC_METH_VAR_TYPE_\n00000000000001a8 (__TEXT,__eh_frame) non-external EH_frame0\n00000000000001c0 (__TEXT,__eh_frame) non-external -[Foo run].eh</code></pre></div>\n<p>第五行至最后一行显示了 <code class=\"language-text\">_OBJC_CLASS_$_Foo</code> 已经定义了，并且对于 <code class=\"language-text\">Foo.o</code> 是一个外部符号 -- ·Foo.o· 包含了这个类的实现。</p>\n<p><code class=\"language-text\">Foo.o</code> 同样有 undefined 的符号。首先是使用了符号 <code class=\"language-text\">NSFullUserName()</code>，<code class=\"language-text\">NSLog()</code>和 <code class=\"language-text\">NSObject</code>。</p>\n<p>当我们将这两个目标文件和 Foundation framework (是一个动态库) 进行链接处理时，链接器会尝试解析所有的 undefined 符号。它可以解析  <code class=\"language-text\">_OBJC_CLASS_$_Foo</code>。另外，它将使用 Foundation framework。</p>\n<p>当链接器通过动态库 (此处是 Foundation framework) 解析成功一个符号时，它会在最终的链接图中记录这个符号是通过动态库进行解析的。链接器会记录输出文件是依赖于哪个动态链接库，并连同其路径一起进行记录。在我们的例子中，<code class=\"language-text\">_NSFullUserName</code>，<code class=\"language-text\">_NSLog</code>，<code class=\"language-text\">_OBJC_CLASS_$_NSObject</code>，<code class=\"language-text\">_objc_autoreleasePoolPop</code> 等符号都是遵循这个过程。</p>\n<p>我们可以看一下最终可执行文件 <code class=\"language-text\">a.out</code> 的符号表，并注意观察链接器是如何解析所有符号的：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% xcrun nm -nm a.out \n                 (undefined) external _NSFullUserName (from Foundation)\n                 (undefined) external _NSLog (from Foundation)\n                 (undefined) external _OBJC_CLASS_$_NSObject (from CoreFoundation)\n                 (undefined) external _OBJC_METACLASS_$_NSObject (from CoreFoundation)\n                 (undefined) external ___CFConstantStringClassReference (from CoreFoundation)\n                 (undefined) external __objc_empty_cache (from libobjc)\n                 (undefined) external __objc_empty_vtable (from libobjc)\n                 (undefined) external _objc_autoreleasePoolPop (from libobjc)\n                 (undefined) external _objc_autoreleasePoolPush (from libobjc)\n                 (undefined) external _objc_msgSend (from libobjc)\n                 (undefined) external _objc_msgSend_fixup (from libobjc)\n                 (undefined) external dyld_stub_binder (from libSystem)\n0000000100000000 (__TEXT,__text) [referenced dynamically] external __mh_execute_header\n0000000100000e50 (__TEXT,__text) external _main\n0000000100000ed0 (__TEXT,__text) non-external -[Foo run]\n0000000100001128 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo\n0000000100001150 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo</code></pre></div>\n<p>可以看到所有的 Foundation 和 Objective-C 运行时符号依旧是 undefined，不过现在的符号表中已经多了如何解析它们的信息，例如在哪个动态库中可以找到对应的符号。</p>\n<p>可执行文件同样知道去哪里找到所需库：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% xcrun otool -L a.out\na.out:\n    /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation (compatibility version 300.0.0, current version 1056.0.0)\n    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1197.1.1)\n    /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 855.11.0)\n    /usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)</code></pre></div>\n<p>在运行时，动态链接器  <code class=\"language-text\">dyld(1)</code> 可以解析这些 undefined 符号，<code class=\"language-text\">dyld</code> 将会确定好 <code class=\"language-text\">_NSFullUserName</code> 等符号，并指向它们在 Foundation 中的实现等。</p>\n<p>我们可以针对 Foundation 运行 <code class=\"language-text\">nm(1)</code>，并检查这些符号的定义情况： </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% xcrun nm -nm `xcrun --show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation | grep NSFullUserName\n0000000000007f3e (__TEXT,__text) external _NSFullUserName </code></pre></div>\n<h3 id=\"动态链接编辑器\"><a href=\"#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%BC%96%E8%BE%91%E5%99%A8\" aria-label=\"动态链接编辑器 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>动态链接编辑器</h3>\n<p>有一些环境变量对于 <code class=\"language-text\">dyld</code> 的输出信息非常有用。首先，如果设置了 <code class=\"language-text\">DYLD_PRINT_LIBRARIES</code>，那么 <code class=\"language-text\">dyld</code> 将会打印出什么库被加载了：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% (export DYLD_PRINT_LIBRARIES=; ./a.out )\ndyld: loaded: /Users/deggert/Desktop/command_line/./a.out\ndyld: loaded: /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation\ndyld: loaded: /usr/lib/libSystem.B.dylib\ndyld: loaded: /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation\ndyld: loaded: /usr/lib/libobjc.A.dylib\ndyld: loaded: /usr/lib/libauto.dylib\n[...]</code></pre></div>\n<p>上面将会显示出在加载 Foundation 时，同时会加载的 70 个动态库。这是由于 Foundation 依赖于另外一些动态库。运行下面的命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">% xcrun otool -L `xcrun --show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation</code></pre></div>\n<p>可以看到 Foundation 使用了 15 个动态库。</p>\n<h3 id=\"dyld-的共享缓存\"><a href=\"#dyld-%E7%9A%84%E5%85%B1%E4%BA%AB%E7%BC%93%E5%AD%98\" aria-label=\"dyld 的共享缓存 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>dyld 的共享缓存</h3>\n<p>当你构建一个真正的程序时，将会链接各种各样的库。它们又会依赖其他一些 framework 和 动态库。需要加载的动态库会非常多。而对于相互依赖的符号就更多了。可能将会有上千个符号需要解析处理，这将花费很长的时间：一般是好几秒钟。</p>\n<p>为了缩短这个处理过程所花费时间，在 OS X 和 iOS 上的动态链接器使用了共享缓存，共享缓存存于 <code class=\"language-text\">/var/db/dyld/</code>。对于每一种架构，操作系统都有一个单独的文件，文件中包含了绝大多数的动态库，这些库都已经链接为一个文件，并且已经处理好了它们之间的符号关系。当加载一个 Mach-O 文件 (一个可执行文件或者一个库) 时，动态链接器首先会检查 <em>共享缓存</em> 看看是否存在其中，如果存在，那么就直接从共享缓存中拿出来使用。每一个进程都把这个共享缓存映射到了自己的地址空间中。这个方法大大优化了 OS X 和 iOS 上程序的启动时间。</p>","excerpt":"我们用 Xcode 构建一个程序的过程中，会把源文件 ( 和 ) 文件转换为一个可执行文件。这个可执行文件中包含的字节码会将被 CPU (iOS 设备中的 ARM 处理器或 Mac 上的 Intel…","headings":[{"value":"xcrun","depth":2},{"value":"不使用 IDE 的 Hello World","depth":2},{"value":"Hello World 和编译器","depth":3},{"value":"预处理","depth":5},{"value":"语法和语义分析","depth":5},{"value":"生成代码和优化","depth":5},{"value":"汇编器","depth":5},{"value":"链接器","depth":5},{"value":"预处理","depth":4},{"value":"编译","depth":4},{"value":"汇编器","depth":4},{"value":"链接器","depth":4},{"value":"Section","depth":2},{"value":"Section 中的内容","depth":3},{"value":"性能上需要注意的事项","depth":4},{"value":"任意的片段","depth":4},{"value":"Mach-O","depth":3},{"value":"一个更复杂的例子","depth":2},{"value":"编译多个文件","depth":3},{"value":"符号表和链接","depth":3},{"value":"动态链接编辑器","depth":3},{"value":"dyld 的共享缓存","depth":3}],"timeToRead":17,"wordCount":{"paragraphs":148,"sentences":148,"words":1088},"frontmatter":{"title":"Mach-O 可执行文件","cover":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAAELElEQVQ4yw2S2VPTBxSF83+0D53qYF2m2tG6oTCtohBAGiKioBAQjCxCZCdhEQxBgixBtrBoCFswBIIVMIlEUjBlCVKoC+IGSlC0Y8cZ+/z193Ae7st3zr3nik5JA0iQhWFoLGfC3k99ZgADlh4ezL3i4fQ8E+45pmcXcc/+zfSjZ8wuvuTxixUcxmJulp5l9c1zns05uV5RQsOtdkQZ8SfIig+ht1mNy9aPTnGE5oZK2u+4ue+eZ3ZhiZn5p7imFhh54GHINo1t3EP/jcsYyuJ4KwCfeB5gKE+iShmDaKyvntGuamZcI7jHh6kTgGnJMgLl5WRqu6nvGcM88ic2AWZzznFvzINrwoNJe0GAyAXgEi+XFnBYO/njbg8iZWkBdToNnY1qJp130ecEkhJ7gh3+J/GXxBMlzyFWUUp0Wgnx2ddILmkkW9OIsSSSnqpLrK2+YFoI0lwqx6pXIjqTnkNGpY7qsmxc98xUpR4h5jd/dh2NZH9oDNJjfgSKQ/klLp+gBCW+kSkEnU2iMSsQU+1lvCvLuG0m7K1ZeKcMiNrUF7lemECTRsGEYwj1+cNEig+ydV8A4eeSkSfKiYs9jzhWQYA0Br+QSI5JIqhN8aW3JoP11WWGTS0khh8iRx6OqCwvibmHdp4uTOFxj5EdfYirqRLUijPoWjooNk7QNvqYCm0FSnkYquQIlEkRFMkOYawWUgk39EyMYhJKNek1iCTiYwy266gvzqC6KBNtWjh16cG0Z4dSmJ9Jccc4+qEZtLnx6LNCaMqW0JYn4arMl+5aFa+ePMLSpMHe24hzQFh5/0/buRR8gBjfTTQUXOCx08RDk5a5/gqcgzcxjD1Hb3XjNlcxb61h1nKdGXMFUyYNS9M2lhc9aFMjUAT+yOWgXYiC928hSRjO+W8jTyamu/4q1o5ahgw19LVWkaluQJaWz+2WSuy3W7AJcphbGLO0Mzncy31LG2XJ4eRK95AXsQdR0O7NHN/+DUE7vkXmtxmF2Iei03soizlAuewgO7f5sHPrJoqjfqYoeh9FZ/ZSLEh1ei/5p/aSePQHog9vIXjX9xzw+Q6R4dKvzFaE4FKHMqAKZr5KyvotGWs3ZbzrTOFcWADRYYG860nnX0sGH7rkrN2K53VzFM9uRLBQI0Wf5IcudjdlJ3cgmrom4Ys5lQ1zDq464VF7cvjvbglfhgr5x6IkQXqcGImYF8YsPg0U8smcyxdrAV+tSr4OqQSTPEYq5SzqE3lrvIjIO1jKurmAjTsaPt+5wmd7De/7C1ntU+EdLBRajyIu7Dh/dalYNhWw1KFgpS+f9b5cNgau8LFfxee+dN62x7HSlS4Ahyvx/q5lw9nK2qiOj5OdrDvb8LqMeCe7eeNoxW0o5fV4Fyu2Zt459Kw5mvDeq+WDTcd7ez0fbTWsdQvQjov8D7GfIcEi4XcSAAAAAElFTkSuQmCC","aspectRatio":2.4,"src":"/static/a8f40500bb5edb2e298af254fdba2a55/27b4b/cover.png","srcSet":"/static/a8f40500bb5edb2e298af254fdba2a55/59f52/cover.png 300w,\n/static/a8f40500bb5edb2e298af254fdba2a55/975a1/cover.png 600w,\n/static/a8f40500bb5edb2e298af254fdba2a55/27b4b/cover.png 1200w,\n/static/a8f40500bb5edb2e298af254fdba2a55/e6e5f/cover.png 1725w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"date":"Feb 27","author":{"id":"westwood","nickname":"westwood","avatar":{"childImageSharp":{"resize":{"src":"/static/dcc5ea15ad3a22318ed1bbf58a6b2b8f/3c462/westwood.png"}}}},"tags":[],"series":{"id":"ios","name":"iOS开发"}}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"61c3ffd1-2fef-586d-961c-a105ad284c8d","prevSlug":"/2017/11-20/javascript-run-loop-ics","nextSlug":"/2018/03-06/Category"}}}