{"componentChunkName":"component---src-templates-post-page-js","path":"/2018/03-06/Category","webpackCompilationHash":"532c5d6d6f2b2e6d7aed","result":{"data":{"prevPost":{"id":"61c3ffd1-2fef-586d-961c-a105ad284c8d","fields":{"slug":"/2018/02-27/Mach-O"},"excerpt":"我们用 Xcode 构建一个程序的过程中，会把源文件 ( 和 ) 文件转换为一个可执行文件。这个可执行文件中包含的字节码会将被 CPU (iOS 设备中的 ARM 处理器或 Mac 上的 Intel…","timeToRead":17,"frontmatter":{"title":"Mach-O 可执行文件","cover":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAAELElEQVQ4yw2S2VPTBxSF83+0D53qYF2m2tG6oTCtohBAGiKioBAQjCxCZCdhEQxBgixBtrBoCFswBIIVMIlEUjBlCVKoC+IGSlC0Y8cZ+/z193Ae7st3zr3nik5JA0iQhWFoLGfC3k99ZgADlh4ezL3i4fQ8E+45pmcXcc/+zfSjZ8wuvuTxixUcxmJulp5l9c1zns05uV5RQsOtdkQZ8SfIig+ht1mNy9aPTnGE5oZK2u+4ue+eZ3ZhiZn5p7imFhh54GHINo1t3EP/jcsYyuJ4KwCfeB5gKE+iShmDaKyvntGuamZcI7jHh6kTgGnJMgLl5WRqu6nvGcM88ic2AWZzznFvzINrwoNJe0GAyAXgEi+XFnBYO/njbg8iZWkBdToNnY1qJp130ecEkhJ7gh3+J/GXxBMlzyFWUUp0Wgnx2ddILmkkW9OIsSSSnqpLrK2+YFoI0lwqx6pXIjqTnkNGpY7qsmxc98xUpR4h5jd/dh2NZH9oDNJjfgSKQ/klLp+gBCW+kSkEnU2iMSsQU+1lvCvLuG0m7K1ZeKcMiNrUF7lemECTRsGEYwj1+cNEig+ydV8A4eeSkSfKiYs9jzhWQYA0Br+QSI5JIqhN8aW3JoP11WWGTS0khh8iRx6OqCwvibmHdp4uTOFxj5EdfYirqRLUijPoWjooNk7QNvqYCm0FSnkYquQIlEkRFMkOYawWUgk39EyMYhJKNek1iCTiYwy266gvzqC6KBNtWjh16cG0Z4dSmJ9Jccc4+qEZtLnx6LNCaMqW0JYn4arMl+5aFa+ePMLSpMHe24hzQFh5/0/buRR8gBjfTTQUXOCx08RDk5a5/gqcgzcxjD1Hb3XjNlcxb61h1nKdGXMFUyYNS9M2lhc9aFMjUAT+yOWgXYiC928hSRjO+W8jTyamu/4q1o5ahgw19LVWkaluQJaWz+2WSuy3W7AJcphbGLO0Mzncy31LG2XJ4eRK95AXsQdR0O7NHN/+DUE7vkXmtxmF2Iei03soizlAuewgO7f5sHPrJoqjfqYoeh9FZ/ZSLEh1ei/5p/aSePQHog9vIXjX9xzw+Q6R4dKvzFaE4FKHMqAKZr5KyvotGWs3ZbzrTOFcWADRYYG860nnX0sGH7rkrN2K53VzFM9uRLBQI0Wf5IcudjdlJ3cgmrom4Ys5lQ1zDq464VF7cvjvbglfhgr5x6IkQXqcGImYF8YsPg0U8smcyxdrAV+tSr4OqQSTPEYq5SzqE3lrvIjIO1jKurmAjTsaPt+5wmd7De/7C1ntU+EdLBRajyIu7Dh/dalYNhWw1KFgpS+f9b5cNgau8LFfxee+dN62x7HSlS4Ahyvx/q5lw9nK2qiOj5OdrDvb8LqMeCe7eeNoxW0o5fV4Fyu2Zt459Kw5mvDeq+WDTcd7ez0fbTWsdQvQjov8D7GfIcEi4XcSAAAAAElFTkSuQmCC","aspectRatio":2.4,"src":"/static/a8f40500bb5edb2e298af254fdba2a55/27b4b/cover.png","srcSet":"/static/a8f40500bb5edb2e298af254fdba2a55/59f52/cover.png 300w,\n/static/a8f40500bb5edb2e298af254fdba2a55/975a1/cover.png 600w,\n/static/a8f40500bb5edb2e298af254fdba2a55/27b4b/cover.png 1200w,\n/static/a8f40500bb5edb2e298af254fdba2a55/e6e5f/cover.png 1725w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"date":"Feb 27","author":{"id":"westwood","nickname":"westwood","avatar":{"childImageSharp":{"resize":{"src":"/static/dcc5ea15ad3a22318ed1bbf58a6b2b8f/3c462/westwood.png"}}}}}},"nextPost":{"id":"d57ecb1f-0415-5c99-baa5-c4e91677c15f","fields":{"slug":"/2019/09-20/javascript-run-loop-ics"},"excerpt":"一、前言 斯坦福教授、Tcl语言发明者John Ousterhout 的著作《A Philosophy of Software Design》1，自出版以来，好评如潮。按照IT…","timeToRead":5,"frontmatter":{"title":"降低软件复杂性的一般原则和方法","cover":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAACrUlEQVQ4y32PW1cSURiG52fIKdEo7eippaEiKIok4MDAOHEQhgFKEIJUQBFF7Wi1Ol1UF932O582rnDhWtXFs/b3ve/sd78jZafD1OZUQYTa/DoNj8zhisJZUONV+DFv1CRvtTTv4llea1mOIxkO5E2awU1q/gTbyxtsr2gUllVk5yrSE5dMxS2z5Vqj5F6juhSisRrhOKTRiSRoK0mOYxk6GwaH0Rzt2BOOYlscqyWxF6nLBcoBncKjTeJeDSntDpBeeCTwo3vWKHhDPPNHaYVTtKM6jYjObjhLQynQSVQ4Te1wktrltb7PudHiNF1nT6tQFQ9UN8pI8ryPLlERmBTt8qtRKqEEdUWnHjWoRbKCHHvqFu1UlU62zkmuyVmhRSe/z76+R1PQzjc4K7aQ3NNLeARe5woBVwDVq5D2P8YIJDGCSQpymu1YTlys0NCr1HM77Bi7lNJVjPg2Ga1ISa+xX2py3jhBmhqbY3rcxezUIp6HPvyuIEFPGFkEqz6VRCAuGpR5WW5QSuZ48bxO53mTWmmP2EaecDSLquVJpooYRhVpUgTOTC0wL1q6Hy7jmvbicfpYmvWLXbReDBFeCRPwBtlU4pTTGT4fHfDr2xe+ff5IsbyLknyKT8niXs8gjdwc5/boBPfuPODe7UnujI5xX5x3b43hnJzF+UD8wcQMrpl58qpGPZ8noyoclLf4cX7Kjw8v+fn1Pd8/vaN1eIRktzuw268zODjEtWt2huzDF/OgmB3DXU/oNpvQBrnhuHFxjo6MMDw0jMPhYGJ8nIU5J+t+L0rQj2SxWDCbzZeYTCZMZtPl3PW79LQuNvFAF4vV+sczM2C2MGAyI3UXU1/gv+gF9xfo13pI1q7Rx5WQPs0iGlxgEftfgq4E2gTWHuKCTRjW3kd/Cf8fvwHpVtALnxLtFQAAAABJRU5ErkJggg==","aspectRatio":2.4,"src":"/static/fb6212f8a09d0a36c96801a195e244d2/27b4b/cover.png","srcSet":"/static/fb6212f8a09d0a36c96801a195e244d2/59f52/cover.png 300w,\n/static/fb6212f8a09d0a36c96801a195e244d2/975a1/cover.png 600w,\n/static/fb6212f8a09d0a36c96801a195e244d2/27b4b/cover.png 1200w,\n/static/fb6212f8a09d0a36c96801a195e244d2/db925/cover.png 1800w,\n/static/fb6212f8a09d0a36c96801a195e244d2/ad1be/cover.png 1944w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"date":"Sep 20","author":{"id":"westwood","nickname":"westwood","avatar":{"childImageSharp":{"resize":{"src":"/static/dcc5ea15ad3a22318ed1bbf58a6b2b8f/3c462/westwood.png"}}}}}},"post":{"id":"16f26f67-fd38-5e46-9907-169bfff4369b","fields":{"slug":"/2018/03-06/Category"},"html":"<h3 id=\"什么是category？\"><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AFcategory%EF%BC%9F\" aria-label=\"什么是category？ permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>什么是category？</h3>\n<p>category是 Objective-C 2.0 之后添加的语言特性，主要作用是为已经存在的类添加方法。除此之外，Apple 还推荐了category 的另外两个使用场景。</p>\n<ol>\n<li>\n<p>可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处</p>\n<ul>\n<li>可以减少单个文件的体积</li>\n<li>可以把不同的功能组织到不同的 category 里</li>\n<li>可以由多个开发者共同完成一个类</li>\n<li>可以按需加载想要的 category 等等</li>\n</ul>\n</li>\n<li>声明私有方法</li>\n</ol>\n<p>不过除了apple推荐的使用场景，还衍生出了 category 的其他几个使用场景：</p>\n<ul>\n<li>模拟多继承</li>\n<li>把framework的私有方法公开</li>\n</ul>\n<h3 id=\"category特点\"><a href=\"#category%E7%89%B9%E7%82%B9\" aria-label=\"category特点 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>category特点</h3>\n<ul>\n<li>category 只能给某个已有的类扩充方法，不能扩充成员变量</li>\n<li>category 中也可以添加属性，只不过 <code class=\"language-text\">@property</code> 只会生成 <code class=\"language-text\">setter</code> 和 <code class=\"language-text\">getter</code> 的声明，不会生成 <code class=\"language-text\">setter</code> 和 <code class=\"language-text\">getter</code> 的实现以及成员变量</li>\n<li>如果 category 中的方法和类中原有方法同名，category 中的方法会覆盖掉类中原有的方法</li>\n<li>如果多个 category 中存在同名的方法，运行时到底调用哪个方法由编译器决定，后面参与编译的方法会覆盖前面同名的方法，所以最后一个参与编译的方法会被调用</li>\n</ul>\n<blockquote>\n<p>这里说的是覆盖而不是替换，是因为后编译的方法被放在了方法列表的前面而已，runtime机制先找到前面的方法来执行</p>\n</blockquote>\n<h3 id=\"category--vs--extension\"><a href=\"#category--vs--extension\" aria-label=\"category  vs  extension permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">Category</code>  VS  <code class=\"language-text\">Extension</code></h3>\n<p>category 常常拿来与 extension 做比较，extension 一样可以添加属性和方法，extension 看起来很像一个匿名的 category。但实际上两者几乎完全是两个东西</p>\n<ul>\n<li>extension 运行在编译期，它就是类的一部分，拓展的方法，属性和变量一起形成一个完整的类。category 是运行期决议的，此时对象的内存布局已经确定，无法再添加实例变量</li>\n<li>extension 一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加 extension</li>\n<li>extension 和 category 都可以添加属性，但是 category 的属性不能生成成员变量和 getter、setter 方法的实现</li>\n</ul>\n<h3 id=\"category原理\"><a href=\"#category%E5%8E%9F%E7%90%86\" aria-label=\"category原理 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>category原理</h3>\n<p>讲了一堆category的作用和特点，我们来看一下category的定义</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">typedef struct category_t *Category;\n\nstruct category_t {\n    const char *name;\t//category名称\n    classref_t cls; \t//要拓展的类\n    struct method_list_t *instanceMethods; //给类添加的实例方法的列表\n    struct method_list_t *classMethods;  //给类添加的类方法的列表\n    struct protocol_list_t *protocols;  //给类添加的协议的列表\n    struct property_list_t *instanceProperties;  //给类添加的属性的列表\n};</code></pre></div>\n<p>实际上 <code class=\"language-text\">Category</code> 是一个 <code class=\"language-text\">category_t</code> 的结构体，里面维护着类的信息和category的名称，以及类方法列表，实例方法列表，协议的列表和属性的列表</p>\n<p>那么Category是怎么加载的呢？</p>\n<p>我们知道，Objective-C 的运行是依赖 OC 的 runtime 的， 而 OC 的 runtime 和其他系统库一样，是OS X和iOS通过<a href=\"https://opensource.apple.com/tarballs/objc4/objc4-723.tar.gz\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">dyld</a>动态加载的</p>\n<p>我们从OC运行时，入口方法出发</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">void _objc_init(void)\n{\n    static bool initialized = false;\n    if (initialized) return;\n    initialized = true;\n    \n    // fixme defer initialization until an objc-using image is found?\n    environ_init();\n    tls_init();\n    static_init();\n    lock_init();\n    exception_init();\n\n    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);\n}</code></pre></div>\n<p>到真正完成绑定 category 的函数<code class=\"language-text\">attachCategories</code>中间的函数调用栈是</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">void _objc_init(void);\n└── void map_images(...);\n    └── void map_images_nolock(...);\n        └── void _read_images(...);\n            └── void _read_images(...);\n                └── static void remethodizeClass(Class cls);\n                    └──attachCategories(Class cls, category_list *cats, bool flush_caches);</code></pre></div>\n<p>我们来看一下 <code class=\"language-text\">attachCategories</code> 源码的简易版：</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">static void \nattachCategories(Class cls, category_list *cats, bool flush_caches)\n{\n    if (!cats) return;\n    \n    bool isMeta = cls-&gt;isMetaClass();\n\n    method_list_t **mlists = (method_list_t **)\n        malloc(cats-&gt;count * sizeof(*mlists));\n\n    int mcount = 0;\n    int i = cats-&gt;count;\n    bool fromBundle = NO;\n    while (i--) {\n        auto&amp; entry = cats-&gt;list[i];\n\n        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);\n        if (mlist) {\n            mlists[mcount++] = mlist;\n            fromBundle |= entry.hi-&gt;isBundle();\n        }\n    }\n\n    auto rw = cls-&gt;data();\n\n    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);\n    rw-&gt;methods.attachLists(mlists, mcount);\n    free(mlists);\n    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);\n}</code></pre></div>\n<p>从上面的代码可以看出，增加方法的操作实际是分配一个大的实例方法列表\n<code class=\"language-text\">method_list_t **mlists = (method_list_t **)\n        malloc(cats-&gt;count * sizeof(*mlists));</code> 再通过 for 循环将category中的方法列表填入这个大的列表，最后交给 <code class=\"language-text\">rw-&gt;methods.attachLists(mlists, mcount);</code>将方法列表增加到类的方法列表上去。其他的属性添加与此类似</p>\n<p>我们再看一段 <code class=\"language-text\">attachLists</code>的源码</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">void attachLists(List* const * addedLists, uint32_t addedCount) {\n if (hasArray()) {\n        \n        //旧的方法列表的长度\n        uint32_t oldCount = array()-&gt;count;\n        \n        //新的方法列表的长度\n        uint32_t newCount = oldCount + addedCount;\n        \n        setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));\n        array()-&gt;count = newCount;\n        \n        //从addedCount的偏移量添加旧的方法列表\n        memmove(array()-&gt;lists + addedCount, array()-&gt;lists, \n                oldCount * sizeof(array()-&gt;lists[0]));\n        //从开始添加新方法列表\n        memcpy(array()-&gt;lists, addedLists, \n               addedCount * sizeof(array()-&gt;lists[0]));\n        }\n}</code></pre></div>\n<blockquote>\n<p>从上面的代码也验证了我们上面所说的，同名的方法是覆盖而不是替换，category的方法被放到了新方法列表的前面</p>\n</blockquote>\n<h3 id=\"category和关联对象\"><a href=\"#category%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1\" aria-label=\"category和关联对象 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>category和关联对象</h3>\n<p>如上所述，category 的属性不能生成成员变量和 <code class=\"language-text\">getter</code>、<code class=\"language-text\">setter</code> 方法的实现，我们要自己实现 <code class=\"language-text\">getter</code> 和 <code class=\"language-text\">setter</code> 方法，需借助关联对象来实现</p>\n<p>关联对象来实现提供三个接口 <code class=\"language-text\">objc_setAssociatedObject</code>,<code class=\"language-text\">objc_getAssociatedObject</code>,<code class=\"language-text\">objc_removeAssociatedObjects</code>,他们分别调用的是</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">id objc_getAssociatedObject(id object, const void *key) {\n    return _object_get_associative_reference(object, (void *)key);\n}\n\nvoid objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) {\n    _object_set_associative_reference(object, (void *)key, value, policy);\n}\n\nvoid objc_removeAssociatedObjects(id object) \n{\n    if (object &amp;&amp; object-&gt;hasAssociatedObjects()) {\n        _object_remove_assocations(object);\n    }\n}</code></pre></div>\n<p>他们调用的接口都位于 <code class=\"language-text\">objc-references.mm</code>文件中,</p>\n<h5 id=\"objectgetassociativereference\"><a href=\"#objectgetassociativereference\" aria-label=\"objectgetassociativereference permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><em>object</em>get<em>associative</em>reference</h5>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">id _object_get_associative_reference(id object, void *key) {\n    id value = nil;\n    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;\n    {\n        AssociationsManager manager;\n        AssociationsHashMap &amp;associations(manager.associations());\n        disguised_ptr_t disguised_object = DISGUISE(object);\n        AssociationsHashMap::iterator i = associations.find(disguised_object);\n        if (i != associations.end()) {\n            ObjectAssociationMap *refs = i-&gt;second;\n            ObjectAssociationMap::iterator j = refs-&gt;find(key);\n            if (j != refs-&gt;end()) {\n                ObjcAssociation &amp;entry = j-&gt;second;\n                value = entry.value();\n                policy = entry.policy();\n                if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) {\n                    objc_retain(value);\n                }\n            }\n        }\n    }\n    if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) {\n        objc_autorelease(value);\n    }\n    return value;\n}</code></pre></div>\n<p>这段代码引用的类型有</p>\n<ul>\n<li>AssociationsManager</li>\n<li>AssociationsHashMap</li>\n<li>ObjcAssociationMap</li>\n<li>ObjcAssociation</li>\n</ul>\n<p><strong>AssociationsManager源码</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">spinlock_t AssociationsManagerLock;\n\nclass AssociationsManager {\n    static AssociationsHashMap *_map;\npublic:\n    // 初始化时候\n    AssociationsManager()   { AssociationsManagerLock.lock(); }\n    // 析构的时候\n    ~AssociationsManager()  { AssociationsManagerLock.unlock(); }\n    \n    // associations 方法用于取得一个全局的 AssociationsHashMap 单例\n    AssociationsHashMap &amp;associations() {\n        if (_map == NULL)\n            _map = new AssociationsHashMap();\n        return *_map;\n    }\n};</code></pre></div>\n<p>AssociationsManager 初始化一个 <code class=\"language-text\">AssociationsHashMap</code> 的单例，用自旋锁 <code class=\"language-text\">AssociationsManagerLock</code> 保证线程安全</p>\n<p><strong>AssociationsHashMap源码</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">class AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt; {\n    public:\n        void *operator new(size_t n) { return ::malloc(n); }\n        void operator delete(void *ptr) { ::free(ptr); }\n    };\n    </code></pre></div>\n<p><code class=\"language-text\">AssociationsHashMap</code> 是一个map类型，用于保存对象的对象的 <code class=\"language-text\">disguised_ptr_t</code> 到 <code class=\"language-text\">ObjectAssociationMap</code> 的映射</p>\n<p><strong>ObjectAssociationMap源码</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">class ObjectAssociationMap : public std::map&lt;void *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt; {\n    public:\n        void *operator new(size_t n) { return ::malloc(n); }\n        void operator delete(void *ptr) { ::free(ptr); }\n    };</code></pre></div>\n<p><code class=\"language-text\">ObjectAssociationMap</code> 则保存了从 key 到关联对象  <code class=\"language-text\">ObjcAssociation</code>      的映射，这个数据结构保存了当前对象对应的所有关联对象</p>\n<p><strong>ObjcAssociation源码</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">class ObjcAssociation {\n        uintptr_t _policy;\n        id _value;\n    public:\n        ObjcAssociation(uintptr_t policy, id value) : _policy(policy), _value(value) {}\n        ObjcAssociation() : _policy(0), _value(nil) {}\n\n        uintptr_t policy() const { return _policy; }\n        id value() const { return _value; }\n        \n        bool hasValue() { return _value != nil; }\n    };</code></pre></div>\n<p><code class=\"language-text\">ObjcAssociation</code>  就是真正的关联对象的类，上面的所有数据结构只是为了更好的存储它。</p>\n<p>最关键的 <code class=\"language-text\">ObjcAssociation</code> 包含了 <code class=\"language-text\">policy</code> 以及 <code class=\"language-text\">value</code></p>\n<p>用一张图解释他们的关系就是：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/6/161f8d91dcd23a17?w=3272&#x26;h=513&#x26;f=png&#x26;s=164674\"></p>\n<p>从上图我们不难看出 <code class=\"language-text\">_object_get_associative_reference</code> 获取关联对象的步骤是：</p>\n<ol>\n<li><code class=\"language-text\">AssociationsHashMap &amp;associations(manager.associations())</code> 获取 <code class=\"language-text\">AssociationsHashMap</code> 的单例对象 <code class=\"language-text\">associations</code></li>\n<li><code class=\"language-text\">disguised_ptr_t disguised_object = DISGUISE(object)</code> 获取对象的地址</li>\n<li>通过对象的地址在 <code class=\"language-text\">associations</code> 中获取 <code class=\"language-text\">AssociationsHashMap</code>迭代器</li>\n<li>通过 <code class=\"language-text\">key</code>获取到 <code class=\"language-text\">ObjectAssociationMap</code>的迭代器</li>\n<li>最后得出关联对象类 <code class=\"language-text\">ObjcAssociation</code> 的实例 <code class=\"language-text\">entry</code>，再获取到 <code class=\"language-text\">value</code> 和 <code class=\"language-text\">policy</code> 的值</li>\n</ol>\n<h5 id=\"objectsetassociativereference\"><a href=\"#objectsetassociativereference\" aria-label=\"objectsetassociativereference permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><em>object</em>set<em>associative</em>reference</h5>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {\n    // retain the new value (if any) outside the lock.\n    uintptr_t old_policy = 0; // NOTE:  old_policy is always assigned to when old_value is non-nil.\n    id new_value = value ? acquireValue(value, policy) : nil, old_value = nil; // 调用 acquireValue 对 value 进行 retain 或者 copy\n    {\n\n        // &amp; 取地址 *是指针，就是地址的内容\n        AssociationsManager manager;  // 初始化一个 AssociationsManager 类型的变量 manager\n        AssociationsHashMap &amp;associations(manager.associations());   // 取得一个全局的 AssociationsHashMap 单例\n        if (new_value) {\n\n            // 如果new_value不为空，开始遍历associations指向的map，查找object对象是否存在保存联合存储数据的ObjectAssociationMap对象\n\n            // 查找map中是否包含某个关键字条目，用 find() 方法，传入的参数是要查找的key（被关联对象的内存地址），在这里需要提到的是begin()和end()两个成员，分别代表map对象中第一个条目和最后一个条目，这两个数据的类型是iterator.\n            // 定义一个条目变量 i (实际是指针)\n            AssociationsHashMap::iterator i = associations.find(object);  // AssociationsHashMap 是一个无序的哈希表，维护了从对象地址到 ObjectAssociationMap 的映射；\n\n\n            // iterator是 C++ 中的迭代器 ， 这句话是定义一个 AssociationsHashMap::iterator 类型的变量 i，初始化为 associations.find(object) ， associations是AssociationsHashMap类型对象。\n\n            // 通过map对象的方法获取的iterator数据类型 是一个std::pair对象\n            // 根据对象地址获取起对应的 ObjectAssociationMap对象\n            if (i != associations.end()) {\n                // 存在\n\n                // object对象在associations指向的map中存在一个ObjectAssociationMap对象refs\n\n                // ObjectAssociationMap 是一个 C++ 中的 map ，维护了从 key（就是外界传入的key） 到 ObjcAssociation 的映射，即关联记录\n                ObjectAssociationMap *refs = i-&gt;second;              //  指针 调用方法 需要用 -&gt;   i 是 AssociationsHashMap    i-&gt;second 表示ObjectAssociationMap  i-&gt;first 表示对象的地址\n                ObjectAssociationMap::iterator j = refs-&gt;find(key);  //  根据传入的关联对象的key（一个地址）获取其对应的关联对象  ObjectAssociationMap\n\n\n                // 关联对象是否存在\n                if (j != refs-&gt;end()) {\n                    // 使用过该key保存value，用新的value和policy替换掉原来的值\n                    // 如果存在 持有旧的关联对象\n                    ObjcAssociation &amp;old_entry = j-&gt;second;  \n                    old_policy = old_entry.policy;\n                    old_value = old_entry.value;\n\n                    // 存入新的关联对象\n                    old_entry.policy = policy;\n                    old_entry.value = new_value;\n                } else {\n                    // 没用使用过该key保存value，将value和policy保存到key映射的map中\n                    // 如果不存在 直接存入新的关联对象\n                    (*refs)[key] = ObjcAssociation(policy, new_value);   // 对map 插入元素\n                }\n            }\n            else {\n\n                // 不存在\n                // 没有object就创建\n                // create the new association (first time).\n                ObjectAssociationMap *refs = new ObjectAssociationMap;\n                associations[object] = refs;\n                (*refs)[key] = ObjcAssociation(policy, new_value);\n                _class_setInstancesHaveAssociatedObjects(_object_getClass(object));\n            }\n        } else {\n            // setting the association to nil breaks the association.\n            AssociationsHashMap::iterator i = associations.find(object);\n            if (i !=  associations.end()) {\n                ObjectAssociationMap *refs = i-&gt;second;\n                ObjectAssociationMap::iterator j = refs-&gt;find(key);\n                if (j != refs-&gt;end()) {\n                    ObjcAssociation &amp;old_entry = j-&gt;second;\n                    old_policy = old_entry.policy;\n                    old_value = (id) old_entry.value;\n\n                    // 从 map中删除该项\n                    refs-&gt;erase(j);\n                }\n            }\n        }\n    }\n\n    // 旧的关联对象是否存在，如果存在，释放旧的关联对象。\n    // release the old value (outside of the lock).\n    if (old_value) releaseValue(old_value, old_policy);\n}</code></pre></div>\n<p><code class=\"language-text\">_object_set_associative_reference</code>设置关联对象的流程参照图片：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/6/161f93d77f7144de?w=700&#x26;h=816&#x26;f=jpeg&#x26;s=61761\"></p>\n<h5 id=\"关联策略\"><a href=\"#%E5%85%B3%E8%81%94%E7%AD%96%E7%95%A5\" aria-label=\"关联策略 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>关联策略</h5>\n<p>在给一个对象添加关联对象时有五种关联策略可供选择：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">关联策略</th>\n<th align=\"left\">等价属性</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">OBJC<em>ASSOCIATION</em>ASSIGN</td>\n<td align=\"left\">@property (assign) or @property (unsafe_unretained)</td>\n<td align=\"left\">弱引用关联对象</td>\n</tr>\n<tr>\n<td align=\"left\">OBJC<em>ASSOCIATION</em>RETAIN_NONATOMIC</td>\n<td align=\"left\">@property (strong, nonatomic)</td>\n<td align=\"left\">强引用关联对象，且为非原子操作</td>\n</tr>\n<tr>\n<td align=\"left\">OBJC<em>ASSOCIATION</em>COPY_NONATOMIC</td>\n<td align=\"left\">@property (copy, nonatomic)</td>\n<td align=\"left\">复制关联对象，且为非原子操作</td>\n</tr>\n<tr>\n<td align=\"left\">OBJC<em>ASSOCIATION</em>RETAIN</td>\n<td align=\"left\">@property (strong, atomic)</td>\n<td align=\"left\">强引用关联对象，且为原子操作</td>\n</tr>\n<tr>\n<td align=\"left\">OBJC<em>ASSOCIATION</em>COPY</td>\n<td align=\"left\">@property (copy, atomic)</td>\n<td align=\"left\">复制关联对象，且为原子操作</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"objectremove_assocations\"><a href=\"#objectremove_assocations\" aria-label=\"objectremove_assocations permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><em>object</em>remove_assocations</h5>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">void _object_remove_assocations(id object) {\n    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;\n    {\n        AssociationsManager manager;\n        AssociationsHashMap &amp;associations(manager.associations());\n        if (associations.size() == 0) return;\n        disguised_ptr_t disguised_object = DISGUISE(object);\n        AssociationsHashMap::iterator i = associations.find(disguised_object);\n        if (i != associations.end()) {\n            // 获取到所有的关联对象的associations实例\n            ObjectAssociationMap *refs = i-&gt;second;\n            for (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) {\n                elements.push_back(j-&gt;second);\n            }\n            delete refs;    //删除ObjectAssociationMap\n            associations.erase(i);//删除AssociationsHashMap\n        }\n    }\n    //删除elements集合中的所有ObjcAssociation元素\n    for_each(elements.begin(), elements.end(), ReleaseValue());\n}</code></pre></div>\n<p>删除关联对象的流程相对就比较简单了，将获取到的关联对象ObjcAssociation的实例放入一个 <code class=\"language-text\">vector</code>中，删除对应的 <code class=\"language-text\">ObjectAssociationMap</code> 和 <code class=\"language-text\">AssociationsHashMap</code>,最后对 <code class=\"language-text\">vector</code> 中每个 <code class=\"language-text\">ObjcAssociation</code> 实例做release操作</p>\n<h3 id=\"总结\"><a href=\"#%E6%80%BB%E7%BB%93\" aria-label=\"总结 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>总结</h3>\n<p>Category在iOS开发中是比较常见的，用于给现有的类拓展新的方法和属性。本文从底层分析了Category的原理，以及关联对象实现，使大家对Category能有一个更深的认识，在以后的开发工作中能更好的使用这一特性。</p>","excerpt":"什么是category？ category是 Objective-C 2.0 之后添加的语言特性，主要作用是为已经存在的类添加方法。除此之外，Apple 还推荐了category…","headings":[{"value":"什么是category？","depth":3},{"value":"category特点","depth":3},{"value":"<code class=\"language-text\">Category</code>  VS  <code class=\"language-text\">Extension</code>","depth":3},{"value":"category原理","depth":3},{"value":"category和关联对象","depth":3},{"value":"objectgetassociativereference","depth":5},{"value":"objectsetassociativereference","depth":5},{"value":"关联策略","depth":5},{"value":"objectremove_assocations","depth":5},{"value":"总结","depth":3}],"timeToRead":8,"wordCount":{"paragraphs":67,"sentences":67,"words":213},"frontmatter":{"title":"从源码解读Category实现原理","cover":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAADd0lEQVQ4yz2Q2VMaZhTF+ZPy2KfaaRwbNWqqcSUIxEBRArhgkQjugKCIiAIFFHBhUQd3bYxJmi4PmUxr+9D2wSTTtNOHTJPUBRdq0l+/Op0+nLlzzz3fufc7kjcvX7L/6g8OXr/i6M83ZA/2OTrc5yR7xMnxEacn2f9xLLjjo0Oy/+Gizx6Kt6/5/dffeLb3HMmzp8/ZF0Qum+Xk8IAzITo/PeFMGOTORD09vkBO4O/z3AXe/ou/znibO+X87JR3or4T2pxYInm/Somhz8lQKIbdHyGcmGf74SPSK+tsbO+wfvceW/fuk9ncZuvBl3z9+Am7P3zPd7u77O095cWLX/jxp5/5RvBPvt1FcqmwgvfKpeTLVMhaOmj41Iqh28aAZwx3IERgKs5EJIY3FBV9BF9oEo8/yPB4AId3HItzBGO/gxsGI0VKDZL86nrKVbeR6oxo7/RgGRwWYj/+yCThaJxwbJqZRJK5ZJpkKk0qnWIqLvholEAkQpdziNauXrQdnVQ0NCKp1WjRmc1YHXZcY158QT+x6SkSyVkWFlIsZRZZW8mwubrE1toya0sLzKdmScyIeMIBxiZGcXqGaO+yckuvQ9KgrkOtrqFZL8dpN+F2tBP/bJDw+ABR/wDxoINYwE4y4iTu7yPosTLh7sRivIXH0YalQ4O2SYZaVY1MVopEpSzhpvwq7a1KQh4j3SYlgz160lEXo7ZmVmdcbCTcBN1mFmNu/E4j9s5G2lsaMOmlaOQlNDfVYjHJUUgLkVR+fJkGxXXCPqsYSBlzdeBzGJj2WQiO9DIz0cXnySHivj6+WPSQGjdj0MgJuK0M9bdQVlKAQa+mvqaYG1WXkZQUf0inSUOn8SbS2lJUykratPU4OvV8tZ5iLjQiLtLxeDuDSSwM2I2Y27W4ew14xZdT0xPMJ0Io5LWUFuchcQ1asQ+YCI3bWUpNEvKP0mfRiaz6ycyEub+cFL2RNTGL+3ppa6zjo8ICysqK6O/tYC7qxTbQTpNGSlHhB0g2VxI82Fri0UaanXk/dzPTOAesrKZj7KwtspyK0viJgsCojdsiGrWsgt4uIy5nDy5XN80GBTJlNdeuX6XgijD0jg0SnfTh8/RRmncJnaqOOx2tZJKTPNzKMD8boexasTAxUVRcyLCrj9m4n0hwBJvNTGVNIVV15VQq5ORdyecfBbDPHrHSnJIAAAAASUVORK5CYII=","aspectRatio":2.4,"src":"/static/703bae1019733ed6126772862bf29955/27b4b/cover.png","srcSet":"/static/703bae1019733ed6126772862bf29955/59f52/cover.png 300w,\n/static/703bae1019733ed6126772862bf29955/975a1/cover.png 600w,\n/static/703bae1019733ed6126772862bf29955/27b4b/cover.png 1200w,\n/static/703bae1019733ed6126772862bf29955/db925/cover.png 1800w,\n/static/703bae1019733ed6126772862bf29955/eaf75/cover.png 1818w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"date":"Mar 6","author":{"id":"westwood","nickname":"westwood","avatar":{"childImageSharp":{"resize":{"src":"/static/dcc5ea15ad3a22318ed1bbf58a6b2b8f/3c462/westwood.png"}}}},"tags":[],"series":{"id":"ios","name":"iOS开发"}}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"16f26f67-fd38-5e46-9907-169bfff4369b","prevSlug":"/2018/02-27/Mach-O","nextSlug":"/2019/09-20/javascript-run-loop-ics"}}}