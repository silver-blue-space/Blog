{"componentChunkName":"component---src-templates-post-page-js","path":"/2018/03-06/Category","webpackCompilationHash":"8301db611985dbfc0d3b","result":{"data":{"prevPost":{"id":"7867a23b-5ed7-5b88-aa91-f21c302f29f9","fields":{"slug":"/2018/02-27/Mach-O"},"excerpt":"我们用 Xcode 构建一个程序的过程中，会把源文件 ( 和 ) 文件转换为一个可执行文件。这个可执行文件中包含的字节码会将被 CPU (iOS 设备中的 ARM 处理器或 Mac 上的 Intel…","timeToRead":17,"frontmatter":{"title":"Mach-O 可执行文件","cover":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAADGUlEQVQozx2SbUzTVxSH7/+WAk63SRSmIYK6Cg4EeamWUlre3xktlYFZR2ELIkukBXkRtM3KiiIIYcisBGLGhGjci3MzY4kxxkzNgtmc2Vy2RDc3P0jc5jf9/Hjph5OTm5M853dyH6GZahDmNxGWWkSeA81ah2ZbKSdavjP8llYHMq8Waa5B7q5GZpcjM4rR0gqQKVZkci7athzEViMisuptoqtdvGJ3s9bRzKuqx9ibWOdoCvfVaq4va0QW14cXhJcbKxA7ixCpNuR2iwKakQYT2pZshKknQMGhADW+D3nn6DG8Eyfwn/4I36lx+idH8IwEaTzcR4XXg2Xf+2Q1t7LV6WJ9mZOXcivRZRWi7chDbDMhNmephYeC2IdGcY9N4A1NMX7uDN9dv8iDB0s8/Ocu9//6maV7P3Drp2tcu3GRxavnWfhyltHZMXyTR2k63ENJWxtml5ukKgciqWMAa3+AxuHjtJ9Uyc6E+OLKBe78+j1/Pvqd5afLPPp/mXsP/+DWnZvc/e06S7cvs3hlgUuLc3w8f5KBiSAHR/w09HgQ65s7yO87QpX/A9wnRhn6dJq5b+Y59fkn+Gam+PGXmzx/9oR///ubx0/uc+P2Ihcuz/HVt2eZOR9iemEKz7Cf/YP91Hcr4Ia3WrAd6KLB7+PA+DCDMxNMngvRMjKMob2b+sFBLl39jLmvzzI2H8Lh81Hc1U37sQDVnR7qe7owud9jna2ShJIqREx5A/G1LjLdbZR0dFLuPYi9r5fS7l6KegdoCgboHAvSOuSn0NtFgmsfugI7evUhUZYKdBn5RCTvRmxKVemSESuORRTuQeTvIap0LzG1buLqmol1thDf8C4Je1VXV6S7W4mvqENvLCLijRylitLEoDSJS0KLNSDjXkeLSVTAFDVMV3JmFaEzKmF3VaLPLkNvqiQ6r4ZVtupwEs1YTGSamVWZuUTvtBCZU45uczq6xDRkfDLayxvR1mxAaLFb0F5T9E0pyMR0VRlhQaXySm7PVUly0KdaiM6wKpgqcylRplJkZiFyBbhDiZ1mVQwD2upYXgBqVrs7YjZpLwAAAABJRU5ErkJggg==","aspectRatio":2.4,"src":"/static/155d1563f11c132dc288068c774f8109/27b4b/cover.png","srcSet":"/static/155d1563f11c132dc288068c774f8109/59f52/cover.png 300w,\n/static/155d1563f11c132dc288068c774f8109/975a1/cover.png 600w,\n/static/155d1563f11c132dc288068c774f8109/27b4b/cover.png 1200w,\n/static/155d1563f11c132dc288068c774f8109/73655/cover.png 1599w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"date":"Feb 27","author":{"id":"westwood","nickname":"westwood","avatar":{"childImageSharp":{"resize":{"src":"/static/dcc5ea15ad3a22318ed1bbf58a6b2b8f/3c462/westwood.png"}}}}}},"nextPost":{"id":"97c410cb-19b6-5ad1-8d82-5d5283400be5","fields":{"slug":"/2019/09-20/javascript-run-loop-ics"},"excerpt":"一、前言 斯坦福教授、Tcl语言发明者John Ousterhout 的著作《A Philosophy of Software Design》1，自出版以来，好评如潮。按照IT…","timeToRead":5,"frontmatter":{"title":"降低软件复杂性的一般原则和方法","cover":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,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","aspectRatio":2.4,"src":"/static/f27cdb8374d3a8f2b5e9bc1e79e310d6/09ea6/cover.png","srcSet":"/static/f27cdb8374d3a8f2b5e9bc1e79e310d6/59f52/cover.png 300w,\n/static/f27cdb8374d3a8f2b5e9bc1e79e310d6/09ea6/cover.png 517w","sizes":"(max-width: 517px) 100vw, 517px"}}},"date":"Sep 20","author":{"id":"westwood","nickname":"westwood","avatar":{"childImageSharp":{"resize":{"src":"/static/dcc5ea15ad3a22318ed1bbf58a6b2b8f/3c462/westwood.png"}}}}}},"post":{"id":"4a5097a1-d2f4-57da-a619-73d04f54a593","fields":{"slug":"/2018/03-06/Category"},"html":"<h3 id=\"什么是category？\"><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AFcategory%EF%BC%9F\" aria-label=\"什么是category？ permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>什么是category？</h3>\n<p>category是 Objective-C 2.0 之后添加的语言特性，主要作用是为已经存在的类添加方法。除此之外，Apple 还推荐了category 的另外两个使用场景。</p>\n<ol>\n<li>\n<p>可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处</p>\n<ul>\n<li>可以减少单个文件的体积</li>\n<li>可以把不同的功能组织到不同的 category 里</li>\n<li>可以由多个开发者共同完成一个类</li>\n<li>可以按需加载想要的 category 等等</li>\n</ul>\n</li>\n<li>声明私有方法</li>\n</ol>\n<p>不过除了apple推荐的使用场景，还衍生出了 category 的其他几个使用场景：</p>\n<ul>\n<li>模拟多继承</li>\n<li>把framework的私有方法公开</li>\n</ul>\n<h3 id=\"category特点\"><a href=\"#category%E7%89%B9%E7%82%B9\" aria-label=\"category特点 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>category特点</h3>\n<ul>\n<li>category 只能给某个已有的类扩充方法，不能扩充成员变量</li>\n<li>category 中也可以添加属性，只不过 <code class=\"language-text\">@property</code> 只会生成 <code class=\"language-text\">setter</code> 和 <code class=\"language-text\">getter</code> 的声明，不会生成 <code class=\"language-text\">setter</code> 和 <code class=\"language-text\">getter</code> 的实现以及成员变量</li>\n<li>如果 category 中的方法和类中原有方法同名，category 中的方法会覆盖掉类中原有的方法</li>\n<li>如果多个 category 中存在同名的方法，运行时到底调用哪个方法由编译器决定，后面参与编译的方法会覆盖前面同名的方法，所以最后一个参与编译的方法会被调用</li>\n</ul>\n<blockquote>\n<p>这里说的是覆盖而不是替换，是因为后编译的方法被放在了方法列表的前面而已，runtime机制先找到前面的方法来执行</p>\n</blockquote>\n<h3 id=\"category--vs--extension\"><a href=\"#category--vs--extension\" aria-label=\"category  vs  extension permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">Category</code>  VS  <code class=\"language-text\">Extension</code></h3>\n<p>category 常常拿来与 extension 做比较，extension 一样可以添加属性和方法，extension 看起来很像一个匿名的 category。但实际上两者几乎完全是两个东西</p>\n<ul>\n<li>extension 运行在编译期，它就是类的一部分，拓展的方法，属性和变量一起形成一个完整的类。category 是运行期决议的，此时对象的内存布局已经确定，无法再添加实例变量</li>\n<li>extension 一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加 extension</li>\n<li>extension 和 category 都可以添加属性，但是 category 的属性不能生成成员变量和 getter、setter 方法的实现</li>\n</ul>\n<h3 id=\"category原理\"><a href=\"#category%E5%8E%9F%E7%90%86\" aria-label=\"category原理 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>category原理</h3>\n<p>讲了一堆category的作用和特点，我们来看一下category的定义</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">typedef struct category_t *Category;\n\nstruct category_t {\n    const char *name;\t//category名称\n    classref_t cls; \t//要拓展的类\n    struct method_list_t *instanceMethods; //给类添加的实例方法的列表\n    struct method_list_t *classMethods;  //给类添加的类方法的列表\n    struct protocol_list_t *protocols;  //给类添加的协议的列表\n    struct property_list_t *instanceProperties;  //给类添加的属性的列表\n};</code></pre></div>\n<p>实际上 <code class=\"language-text\">Category</code> 是一个 <code class=\"language-text\">category_t</code> 的结构体，里面维护着类的信息和category的名称，以及类方法列表，实例方法列表，协议的列表和属性的列表</p>\n<p>那么Category是怎么加载的呢？</p>\n<p>我们知道，Objective-C 的运行是依赖 OC 的 runtime 的， 而 OC 的 runtime 和其他系统库一样，是OS X和iOS通过<a href=\"https://opensource.apple.com/tarballs/objc4/objc4-723.tar.gz\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">dyld</a>动态加载的</p>\n<p>我们从OC运行时，入口方法出发</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">void _objc_init(void)\n{\n    static bool initialized = false;\n    if (initialized) return;\n    initialized = true;\n    \n    // fixme defer initialization until an objc-using image is found?\n    environ_init();\n    tls_init();\n    static_init();\n    lock_init();\n    exception_init();\n\n    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);\n}</code></pre></div>\n<p>到真正完成绑定 category 的函数<code class=\"language-text\">attachCategories</code>中间的函数调用栈是</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">void _objc_init(void);\n└── void map_images(...);\n    └── void map_images_nolock(...);\n        └── void _read_images(...);\n            └── void _read_images(...);\n                └── static void remethodizeClass(Class cls);\n                    └──attachCategories(Class cls, category_list *cats, bool flush_caches);</code></pre></div>\n<p>我们来看一下 <code class=\"language-text\">attachCategories</code> 源码的简易版：</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">static void \nattachCategories(Class cls, category_list *cats, bool flush_caches)\n{\n    if (!cats) return;\n    \n    bool isMeta = cls-&gt;isMetaClass();\n\n    method_list_t **mlists = (method_list_t **)\n        malloc(cats-&gt;count * sizeof(*mlists));\n\n    int mcount = 0;\n    int i = cats-&gt;count;\n    bool fromBundle = NO;\n    while (i--) {\n        auto&amp; entry = cats-&gt;list[i];\n\n        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);\n        if (mlist) {\n            mlists[mcount++] = mlist;\n            fromBundle |= entry.hi-&gt;isBundle();\n        }\n    }\n\n    auto rw = cls-&gt;data();\n\n    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);\n    rw-&gt;methods.attachLists(mlists, mcount);\n    free(mlists);\n    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);\n}</code></pre></div>\n<p>从上面的代码可以看出，增加方法的操作实际是分配一个大的实例方法列表\n<code class=\"language-text\">method_list_t **mlists = (method_list_t **)\n        malloc(cats-&gt;count * sizeof(*mlists));</code> 再通过 for 循环将category中的方法列表填入这个大的列表，最后交给 <code class=\"language-text\">rw-&gt;methods.attachLists(mlists, mcount);</code>将方法列表增加到类的方法列表上去。其他的属性添加与此类似</p>\n<p>我们再看一段 <code class=\"language-text\">attachLists</code>的源码</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">void attachLists(List* const * addedLists, uint32_t addedCount) {\n if (hasArray()) {\n        \n        //旧的方法列表的长度\n        uint32_t oldCount = array()-&gt;count;\n        \n        //新的方法列表的长度\n        uint32_t newCount = oldCount + addedCount;\n        \n        setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));\n        array()-&gt;count = newCount;\n        \n        //从addedCount的偏移量添加旧的方法列表\n        memmove(array()-&gt;lists + addedCount, array()-&gt;lists, \n                oldCount * sizeof(array()-&gt;lists[0]));\n        //从开始添加新方法列表\n        memcpy(array()-&gt;lists, addedLists, \n               addedCount * sizeof(array()-&gt;lists[0]));\n        }\n}</code></pre></div>\n<blockquote>\n<p>从上面的代码也验证了我们上面所说的，同名的方法是覆盖而不是替换，category的方法被放到了新方法列表的前面</p>\n</blockquote>\n<h3 id=\"category和关联对象\"><a href=\"#category%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1\" aria-label=\"category和关联对象 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>category和关联对象</h3>\n<p>如上所述，category 的属性不能生成成员变量和 <code class=\"language-text\">getter</code>、<code class=\"language-text\">setter</code> 方法的实现，我们要自己实现 <code class=\"language-text\">getter</code> 和 <code class=\"language-text\">setter</code> 方法，需借助关联对象来实现</p>\n<p>关联对象来实现提供三个接口 <code class=\"language-text\">objc_setAssociatedObject</code>,<code class=\"language-text\">objc_getAssociatedObject</code>,<code class=\"language-text\">objc_removeAssociatedObjects</code>,他们分别调用的是</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">id objc_getAssociatedObject(id object, const void *key) {\n    return _object_get_associative_reference(object, (void *)key);\n}\n\nvoid objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) {\n    _object_set_associative_reference(object, (void *)key, value, policy);\n}\n\nvoid objc_removeAssociatedObjects(id object) \n{\n    if (object &amp;&amp; object-&gt;hasAssociatedObjects()) {\n        _object_remove_assocations(object);\n    }\n}</code></pre></div>\n<p>他们调用的接口都位于 <code class=\"language-text\">objc-references.mm</code>文件中,</p>\n<h5 id=\"objectgetassociativereference\"><a href=\"#objectgetassociativereference\" aria-label=\"objectgetassociativereference permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><em>object</em>get<em>associative</em>reference</h5>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">id _object_get_associative_reference(id object, void *key) {\n    id value = nil;\n    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;\n    {\n        AssociationsManager manager;\n        AssociationsHashMap &amp;associations(manager.associations());\n        disguised_ptr_t disguised_object = DISGUISE(object);\n        AssociationsHashMap::iterator i = associations.find(disguised_object);\n        if (i != associations.end()) {\n            ObjectAssociationMap *refs = i-&gt;second;\n            ObjectAssociationMap::iterator j = refs-&gt;find(key);\n            if (j != refs-&gt;end()) {\n                ObjcAssociation &amp;entry = j-&gt;second;\n                value = entry.value();\n                policy = entry.policy();\n                if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) {\n                    objc_retain(value);\n                }\n            }\n        }\n    }\n    if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) {\n        objc_autorelease(value);\n    }\n    return value;\n}</code></pre></div>\n<p>这段代码引用的类型有</p>\n<ul>\n<li>AssociationsManager</li>\n<li>AssociationsHashMap</li>\n<li>ObjcAssociationMap</li>\n<li>ObjcAssociation</li>\n</ul>\n<p><strong>AssociationsManager源码</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">spinlock_t AssociationsManagerLock;\n\nclass AssociationsManager {\n    static AssociationsHashMap *_map;\npublic:\n    // 初始化时候\n    AssociationsManager()   { AssociationsManagerLock.lock(); }\n    // 析构的时候\n    ~AssociationsManager()  { AssociationsManagerLock.unlock(); }\n    \n    // associations 方法用于取得一个全局的 AssociationsHashMap 单例\n    AssociationsHashMap &amp;associations() {\n        if (_map == NULL)\n            _map = new AssociationsHashMap();\n        return *_map;\n    }\n};</code></pre></div>\n<p>AssociationsManager 初始化一个 <code class=\"language-text\">AssociationsHashMap</code> 的单例，用自旋锁 <code class=\"language-text\">AssociationsManagerLock</code> 保证线程安全</p>\n<p><strong>AssociationsHashMap源码</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">class AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt; {\n    public:\n        void *operator new(size_t n) { return ::malloc(n); }\n        void operator delete(void *ptr) { ::free(ptr); }\n    };\n    </code></pre></div>\n<p><code class=\"language-text\">AssociationsHashMap</code> 是一个map类型，用于保存对象的对象的 <code class=\"language-text\">disguised_ptr_t</code> 到 <code class=\"language-text\">ObjectAssociationMap</code> 的映射</p>\n<p><strong>ObjectAssociationMap源码</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">class ObjectAssociationMap : public std::map&lt;void *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt; {\n    public:\n        void *operator new(size_t n) { return ::malloc(n); }\n        void operator delete(void *ptr) { ::free(ptr); }\n    };</code></pre></div>\n<p><code class=\"language-text\">ObjectAssociationMap</code> 则保存了从 key 到关联对象  <code class=\"language-text\">ObjcAssociation</code>      的映射，这个数据结构保存了当前对象对应的所有关联对象</p>\n<p><strong>ObjcAssociation源码</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">class ObjcAssociation {\n        uintptr_t _policy;\n        id _value;\n    public:\n        ObjcAssociation(uintptr_t policy, id value) : _policy(policy), _value(value) {}\n        ObjcAssociation() : _policy(0), _value(nil) {}\n\n        uintptr_t policy() const { return _policy; }\n        id value() const { return _value; }\n        \n        bool hasValue() { return _value != nil; }\n    };</code></pre></div>\n<p><code class=\"language-text\">ObjcAssociation</code>  就是真正的关联对象的类，上面的所有数据结构只是为了更好的存储它。</p>\n<p>最关键的 <code class=\"language-text\">ObjcAssociation</code> 包含了 <code class=\"language-text\">policy</code> 以及 <code class=\"language-text\">value</code></p>\n<p>用一张图解释他们的关系就是：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/6/161f8d91dcd23a17?w=3272&#x26;h=513&#x26;f=png&#x26;s=164674\"></p>\n<p>从上图我们不难看出 <code class=\"language-text\">_object_get_associative_reference</code> 获取关联对象的步骤是：</p>\n<ol>\n<li><code class=\"language-text\">AssociationsHashMap &amp;associations(manager.associations())</code> 获取 <code class=\"language-text\">AssociationsHashMap</code> 的单例对象 <code class=\"language-text\">associations</code></li>\n<li><code class=\"language-text\">disguised_ptr_t disguised_object = DISGUISE(object)</code> 获取对象的地址</li>\n<li>通过对象的地址在 <code class=\"language-text\">associations</code> 中获取 <code class=\"language-text\">AssociationsHashMap</code>迭代器</li>\n<li>通过 <code class=\"language-text\">key</code>获取到 <code class=\"language-text\">ObjectAssociationMap</code>的迭代器</li>\n<li>最后得出关联对象类 <code class=\"language-text\">ObjcAssociation</code> 的实例 <code class=\"language-text\">entry</code>，再获取到 <code class=\"language-text\">value</code> 和 <code class=\"language-text\">policy</code> 的值</li>\n</ol>\n<h5 id=\"objectsetassociativereference\"><a href=\"#objectsetassociativereference\" aria-label=\"objectsetassociativereference permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><em>object</em>set<em>associative</em>reference</h5>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {\n    // retain the new value (if any) outside the lock.\n    uintptr_t old_policy = 0; // NOTE:  old_policy is always assigned to when old_value is non-nil.\n    id new_value = value ? acquireValue(value, policy) : nil, old_value = nil; // 调用 acquireValue 对 value 进行 retain 或者 copy\n    {\n\n        // &amp; 取地址 *是指针，就是地址的内容\n        AssociationsManager manager;  // 初始化一个 AssociationsManager 类型的变量 manager\n        AssociationsHashMap &amp;associations(manager.associations());   // 取得一个全局的 AssociationsHashMap 单例\n        if (new_value) {\n\n            // 如果new_value不为空，开始遍历associations指向的map，查找object对象是否存在保存联合存储数据的ObjectAssociationMap对象\n\n            // 查找map中是否包含某个关键字条目，用 find() 方法，传入的参数是要查找的key（被关联对象的内存地址），在这里需要提到的是begin()和end()两个成员，分别代表map对象中第一个条目和最后一个条目，这两个数据的类型是iterator.\n            // 定义一个条目变量 i (实际是指针)\n            AssociationsHashMap::iterator i = associations.find(object);  // AssociationsHashMap 是一个无序的哈希表，维护了从对象地址到 ObjectAssociationMap 的映射；\n\n\n            // iterator是 C++ 中的迭代器 ， 这句话是定义一个 AssociationsHashMap::iterator 类型的变量 i，初始化为 associations.find(object) ， associations是AssociationsHashMap类型对象。\n\n            // 通过map对象的方法获取的iterator数据类型 是一个std::pair对象\n            // 根据对象地址获取起对应的 ObjectAssociationMap对象\n            if (i != associations.end()) {\n                // 存在\n\n                // object对象在associations指向的map中存在一个ObjectAssociationMap对象refs\n\n                // ObjectAssociationMap 是一个 C++ 中的 map ，维护了从 key（就是外界传入的key） 到 ObjcAssociation 的映射，即关联记录\n                ObjectAssociationMap *refs = i-&gt;second;              //  指针 调用方法 需要用 -&gt;   i 是 AssociationsHashMap    i-&gt;second 表示ObjectAssociationMap  i-&gt;first 表示对象的地址\n                ObjectAssociationMap::iterator j = refs-&gt;find(key);  //  根据传入的关联对象的key（一个地址）获取其对应的关联对象  ObjectAssociationMap\n\n\n                // 关联对象是否存在\n                if (j != refs-&gt;end()) {\n                    // 使用过该key保存value，用新的value和policy替换掉原来的值\n                    // 如果存在 持有旧的关联对象\n                    ObjcAssociation &amp;old_entry = j-&gt;second;  \n                    old_policy = old_entry.policy;\n                    old_value = old_entry.value;\n\n                    // 存入新的关联对象\n                    old_entry.policy = policy;\n                    old_entry.value = new_value;\n                } else {\n                    // 没用使用过该key保存value，将value和policy保存到key映射的map中\n                    // 如果不存在 直接存入新的关联对象\n                    (*refs)[key] = ObjcAssociation(policy, new_value);   // 对map 插入元素\n                }\n            }\n            else {\n\n                // 不存在\n                // 没有object就创建\n                // create the new association (first time).\n                ObjectAssociationMap *refs = new ObjectAssociationMap;\n                associations[object] = refs;\n                (*refs)[key] = ObjcAssociation(policy, new_value);\n                _class_setInstancesHaveAssociatedObjects(_object_getClass(object));\n            }\n        } else {\n            // setting the association to nil breaks the association.\n            AssociationsHashMap::iterator i = associations.find(object);\n            if (i !=  associations.end()) {\n                ObjectAssociationMap *refs = i-&gt;second;\n                ObjectAssociationMap::iterator j = refs-&gt;find(key);\n                if (j != refs-&gt;end()) {\n                    ObjcAssociation &amp;old_entry = j-&gt;second;\n                    old_policy = old_entry.policy;\n                    old_value = (id) old_entry.value;\n\n                    // 从 map中删除该项\n                    refs-&gt;erase(j);\n                }\n            }\n        }\n    }\n\n    // 旧的关联对象是否存在，如果存在，释放旧的关联对象。\n    // release the old value (outside of the lock).\n    if (old_value) releaseValue(old_value, old_policy);\n}</code></pre></div>\n<p><code class=\"language-text\">_object_set_associative_reference</code>设置关联对象的流程参照图片：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/6/161f93d77f7144de?w=700&#x26;h=816&#x26;f=jpeg&#x26;s=61761\"></p>\n<h5 id=\"关联策略\"><a href=\"#%E5%85%B3%E8%81%94%E7%AD%96%E7%95%A5\" aria-label=\"关联策略 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>关联策略</h5>\n<p>在给一个对象添加关联对象时有五种关联策略可供选择：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">关联策略</th>\n<th align=\"left\">等价属性</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">OBJC<em>ASSOCIATION</em>ASSIGN</td>\n<td align=\"left\">@property (assign) or @property (unsafe_unretained)</td>\n<td align=\"left\">弱引用关联对象</td>\n</tr>\n<tr>\n<td align=\"left\">OBJC<em>ASSOCIATION</em>RETAIN_NONATOMIC</td>\n<td align=\"left\">@property (strong, nonatomic)</td>\n<td align=\"left\">强引用关联对象，且为非原子操作</td>\n</tr>\n<tr>\n<td align=\"left\">OBJC<em>ASSOCIATION</em>COPY_NONATOMIC</td>\n<td align=\"left\">@property (copy, nonatomic)</td>\n<td align=\"left\">复制关联对象，且为非原子操作</td>\n</tr>\n<tr>\n<td align=\"left\">OBJC<em>ASSOCIATION</em>RETAIN</td>\n<td align=\"left\">@property (strong, atomic)</td>\n<td align=\"left\">强引用关联对象，且为原子操作</td>\n</tr>\n<tr>\n<td align=\"left\">OBJC<em>ASSOCIATION</em>COPY</td>\n<td align=\"left\">@property (copy, atomic)</td>\n<td align=\"left\">复制关联对象，且为原子操作</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"objectremove_assocations\"><a href=\"#objectremove_assocations\" aria-label=\"objectremove_assocations permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><em>object</em>remove_assocations</h5>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">void _object_remove_assocations(id object) {\n    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;\n    {\n        AssociationsManager manager;\n        AssociationsHashMap &amp;associations(manager.associations());\n        if (associations.size() == 0) return;\n        disguised_ptr_t disguised_object = DISGUISE(object);\n        AssociationsHashMap::iterator i = associations.find(disguised_object);\n        if (i != associations.end()) {\n            // 获取到所有的关联对象的associations实例\n            ObjectAssociationMap *refs = i-&gt;second;\n            for (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) {\n                elements.push_back(j-&gt;second);\n            }\n            delete refs;    //删除ObjectAssociationMap\n            associations.erase(i);//删除AssociationsHashMap\n        }\n    }\n    //删除elements集合中的所有ObjcAssociation元素\n    for_each(elements.begin(), elements.end(), ReleaseValue());\n}</code></pre></div>\n<p>删除关联对象的流程相对就比较简单了，将获取到的关联对象ObjcAssociation的实例放入一个 <code class=\"language-text\">vector</code>中，删除对应的 <code class=\"language-text\">ObjectAssociationMap</code> 和 <code class=\"language-text\">AssociationsHashMap</code>,最后对 <code class=\"language-text\">vector</code> 中每个 <code class=\"language-text\">ObjcAssociation</code> 实例做release操作</p>\n<h3 id=\"总结\"><a href=\"#%E6%80%BB%E7%BB%93\" aria-label=\"总结 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>总结</h3>\n<p>Category在iOS开发中是比较常见的，用于给现有的类拓展新的方法和属性。本文从底层分析了Category的原理，以及关联对象实现，使大家对Category能有一个更深的认识，在以后的开发工作中能更好的使用这一特性。</p>","excerpt":"什么是category？ category是 Objective-C 2.0 之后添加的语言特性，主要作用是为已经存在的类添加方法。除此之外，Apple 还推荐了category…","headings":[{"value":"什么是category？","depth":3},{"value":"category特点","depth":3},{"value":"<code class=\"language-text\">Category</code>  VS  <code class=\"language-text\">Extension</code>","depth":3},{"value":"category原理","depth":3},{"value":"category和关联对象","depth":3},{"value":"objectgetassociativereference","depth":5},{"value":"objectsetassociativereference","depth":5},{"value":"关联策略","depth":5},{"value":"objectremove_assocations","depth":5},{"value":"总结","depth":3}],"timeToRead":8,"wordCount":{"paragraphs":67,"sentences":67,"words":213},"frontmatter":{"title":"从源码解读Category实现原理","cover":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsSAAALEgHS3X78AAAFFklEQVQ4yx2UaU9bZxqGz1+pRk3VtCkEiAnGGGzj5XjffezjY+PdeDdesHEwdlySACYEGjVNhkybaTqpZqKpWlXtLK3U5lP/1TWv5sMrPZ/e537uTSpVY+TqGTK1PJVhjUInQzyvkaymSVfS+JJ+zKFN7Mpd/PktQnmZRNuNI24k0/dx/nOFs7cqky80Bo+TSMfHVfoHOTLlFPlejmJTo1DPkaplSZUyxDJx1lyrGCN6bJEtlIzMTsOLI7zJ7LrMi3eHPPtPnZMfCxxfZ5Am94p0+2nyTZXSnkaprpKrpATCrPjAhi1oYXl7iRXbAquOZeJZG/WRRlm8F7+MmP/e4P7rCOOvgxxfBZAOehqzh0Wm5zXakyy5ZoJUPU2gpKKT9RhcG8iqA73nDnrfCtveDSbnLb749Yird20e/VHg/G2Y41duHr0KIVV3w8xPa3z1+ojO/TSZboJyf4faIM1WaB1zcBOvsk2k7EbpBLB5Hcxe7PHwtzZPfhly8t8yj98mOfmnxrOfU0ha3E27E2d/nKU3Uek+2CXZDOPJ2Mjuq6QaEbKVGPFqiGBdRvbZmb5ucP7vFs9/HHDytzxP/7XLZz+kefkuh5RNxWn3C/SnRfqzIruCG6UWwJN1obQUMQeFUBF2e3FMPh0blnVCSQ+Dyyzz70s8+UeGq58qzN+ojL8JI12eHjIYVjl7MmY6H1A9EHapB1B3PcjJLXLdMFrNi9YIYgoYWDesYXc7aTxQuHqbZfJtisFTTVzmZvSXCNKw32cyPKCU7nL66HNefnsubBFAyTkJZCzku16Uqkxkz09zppBQbQJhmFe/32f8LEb5xEVnHkWr6mm/1JCa3R7ToykhZ4pqscTV8xGH5wVaox0iOw7UuhOl6SJz4KN7HufoYgdfWGZ2UWL4LCgo0ROtrosL9KTu2ZBeXHzDyWyEGgnhc8iMZ3nGJ2W60zxK3ieQugXSLTaDy+hsi2TbHnwBB9XDFKM3UdIjK77CXUJ1I6HsEtLJ/jW9tkohGyQZ9tDdj9Hspdjt7KAJLuNFF8mSC0dkjQ37bUIJE36hdGGs0fkyxtG1n7Ov3CRbdwjndEil9IBWI8PhsEVBVaiKbGdbMUqtDIlimETJQ6Lgwhk1YA+uIwe38IZdWKNmQnsmpp8FOH4e4f5ZgJ26C2lQ6jJoFTmoF2lmw3z6qE4k58doN2ANOoQoeWz+dVa3b7NiXGHdvoHFY2fTZcEUNbJ/kWBwlqLQdxCvW5C6uy20dJismqSQFicKNP6EC4Nlg5trS6zKZnTWuyxuLvKnpRvYwxrj4ZfIMUFDykRjqtAdxYj17BxeepA6/R5+xYPZZCauCntkPDhEdu9sG/lkQxhZtrC4peMD3S3eX1nEFlIxWJ0sri+JOvPQn8SYPEhQn4Q4vYwhzSZTtJQXk9FAVLWLqCWEADJrdj13bXrMbi86i4H3F2/x3ocfcnN5gZtiXjKt4lS8hKo+7s2TTB5HOZqL+ro+/45iOYltW08s6SS7l/x/bVl8VoFEJMNiYkWg+fj2LRZWF/jokxvojctYxfKgcEb7QZ7aTAgiylYp25H+evErn86OqdQ0Kg3R1IUAobQTV1R86jKxsW1lYXkVOSBaRyxauv0RZquIn+bFmDCzI5J0+mbE4O8V8mPB4eXhn3l6+jn3DjtExQlxzUM0aSMalwmFHdjkLsbt79i0WLm1cINl3ceYzAZRYzJ21Up66OfhqyZz0Y8HPwz5H0DaV0DmWIpcAAAAAElFTkSuQmCC","aspectRatio":2.4,"src":"/static/6add2cd28c9348d9d9a8c43db700310e/e377d/cover.png","srcSet":"/static/6add2cd28c9348d9d9a8c43db700310e/59f52/cover.png 300w,\n/static/6add2cd28c9348d9d9a8c43db700310e/975a1/cover.png 600w,\n/static/6add2cd28c9348d9d9a8c43db700310e/e377d/cover.png 1000w","sizes":"(max-width: 1000px) 100vw, 1000px"}}},"date":"Mar 6","author":{"id":"westwood","nickname":"westwood","avatar":{"childImageSharp":{"resize":{"src":"/static/dcc5ea15ad3a22318ed1bbf58a6b2b8f/3c462/westwood.png"}}}},"tags":[],"series":{"id":"ios","name":"苹果"}}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"4a5097a1-d2f4-57da-a619-73d04f54a593","prevSlug":"/2018/02-27/Mach-O","nextSlug":"/2019/09-20/javascript-run-loop-ics"}}}